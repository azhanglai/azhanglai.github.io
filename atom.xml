<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azhanglai-github-io.vercel.app</id>
    <title>azhanglai</title>
    <updated>2021-09-11T08:11:07.727Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://azhanglai-github-io.vercel.app"/>
    <link rel="self" href="https://azhanglai-github-io.vercel.app/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://azhanglai-github-io.vercel.app/images/avatar.png</logo>
    <icon>https://azhanglai-github-io.vercel.app/favicon.ico</icon>
    <rights>All rights reserved 2021, azhanglai</rights>
    <entry>
        <title type="html"><![CDATA[C++]]></title>
        <id>https://azhanglai-github-io.vercel.app/post/c/</id>
        <link href="https://azhanglai-github-io.vercel.app/post/c/">
        </link>
        <updated>2021-09-11T07:38:51.000Z</updated>
        <content type="html"><![CDATA[<p>阻塞与非阻塞极简解释（烧开水例子）：</p>
<p>同步：就是普通水壶烧开水，要没事儿自己过来看开没开；</p>
<p>异步：就是响水壶烧开水，水开了水壶响了通知你；</p>
<p>阻塞：就是烧开水的过程中，你不能干其他事情（即你被阻塞住了），只能站那等水开；</p>
<p>非阻塞：就是烧开水的过程里可以干其他事情，比如去客厅看看电视。</p>
<p>同步与异步说的是获得水开了的方式不同。</p>
<p>阻塞与非阻塞说的是你得到结果之前能不能干其他事。</p>
<p>两组概念描述的是不同的内容</p>
<p>分析写文件的过程（open(打开文件)--&gt; write(写入) --&gt; close(关闭文件)）</p>
<p>1.其中write属于系统调用，具体过程：数据--&gt;内核--&gt;磁盘,内核拷贝数据，放在缓冲区（块缓冲），清刷缓冲时，调度IO设备，找到inode和block,将数据写入磁盘。（第一步数据--&gt;内核是用户态，第二步 内核--&gt;磁盘是内核态。存在转换）</p>
<p>2.NON_BLOCK设置的是用户态（数据--&gt;内核 或 内核 --&gt; 数据）的过程；大部分的阻塞是在从内核拿数据出来</p>
<p>3.内核--&gt;磁盘的过程实际是阻塞的。为了方便上层应用快速返回写的状态，内核将数据写到磁盘的过程，普通用户不需要感知；内核拷贝完数据，程序返回，普通用户就认为写成功了，但数据很有可能还在缓冲区（缓冲IO）</p>
<p>fcntl()函数（操作文件描述符，可以将文件变成非阻塞的）</p>
<p>1.函数原型：int fcntl(int fd, int cmd, .../* arg */);</p>
<p>参数cmd：操作方式</p>
<p>.../* arg */：可变参数，arg,指示该参数是前面参数（cmd）的参数，其含义取决于cmd</p>
<p>2.函数返回值：出错都是返回-1，设置操作成功都是返回0</p>
<p>select()函数（同步I/O多路复用接口）</p>
<p>1.函数原型：int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</p>
<p>参数nfds:文件描述符的数量</p>
<p>fd_set：文件描述符的集合， （可读、可写、异常）底层是用数组实现的</p>
<p>参数 timeout：时间间隔</p>
<p>描述：<br>
允许程序去监控多个文件描述符，等待一个或多个文件描述符的I/O操作“ready”的情况</p>
<p>ready：就绪，可以对文件进行相应的IO操作，如没有阻塞的读，或足够小的写。<br>
可监控的文件描述符数量小于FD_SETSIZE（一般为1024）</p>
<p>退出的时候，每个文件描述符集合会被修改，只留下状态发生变化的文件描述符，起指示作用；<br>
所以如果循环使用select，每次调用select前需要重新初始化每个集合。</p>
<p>集合可以是NULL，说明该类事件中没有文件被监控</p>
<p>宏用来操作集合</p>
<ol>
<li>FD_ZERO：清空一个集合<br>
2.FD_SET：向一个集合添加一个文件描述符<br>
3.FD_CLR：从一个集合移除一个文件描述符<br>
4.FD_ISSET：判断一个文件描述符的所属集合，可用于select返回后，因为集合已被修改</li>
</ol>
<p>nfds的值是三个集合中数字最大的文件描述符加1<br>
1.文件描述符的索引是从0开始的</p>
<p>struct timeval timeout<br>
1.指定select阻塞着等待每个文件描述符就绪的时间间隔；<br>
2.这里阻塞的含义就是单纯的阻塞，不是阻塞I/O的阻塞；<br>
3.同步I/O的多路复用的同步就体现在这</p>
<p>三个停止阻塞的情况<br>
1.一个文件描述符就绪<br>
2.信号中断（kill）<br>
3.超时</p>
<p>时间间隔不是精确的，很难做到真正的精确；系统时钟粒度、内核调度延迟。</p>
<p>timeval结构体中两个成员：秒、微妙，如果两者都为0，就会立即返回，可用于轮询（polling）<br>
如果为NULL，就会无期限等待<br>
timeout更新功能只在linux上生效，为了兼容性，尽量别用，尽量使用比较公共的功能。</p>
<p>函数返回值：返回此时所有集合文件描述符（ready）数量，根据数量，再通过宏定义FD_ISSET询问所有文件描述符的所在集合，来感知状态变化<br>
0：时间过完了，也没有感兴趣的事件发生<br>
-1：error，并设置error；此时集合不会改变，timeout变成未定义的了</p>
<p>（select--&gt;poll--&gt;epoll，越来越高级）</p>
<pre><code class="language-c">//common.h
#ifndef _COMMON_H
#define _COMMON_H

int make_nonblock(int fd); // 声明非阻塞
int make_block(int fd);   // 声明阻塞
~~~c


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[嘻嘻]]></title>
        <id>https://azhanglai-github-io.vercel.app/post/linux/</id>
        <link href="https://azhanglai-github-io.vercel.app/post/linux/">
        </link>
        <updated>2021-09-11T07:38:51.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-c"> 
```c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char *argv[]) {
    int opt;
    while (~(opt = getopt(argc, argv, &quot;alm:o::&quot;))) {
        switch(opt) {
            case 'a': {
                printf(&quot;a found!\n&quot;);
            }; break;
            case 'l': {
                printf(&quot;l found!\n&quot;);
            }; break;
            case 'm': {
                printf(&quot;m_msg = %s\n&quot;, optarg);
            }; break;
            case 'o': {
                printf(&quot;o_msg = %s\n&quot;, optarg);
            }; break;
            default: 
                fprintf(stderr, &quot;Usage : %s -al\n&quot;, argv[0]);
                exit(1);
        }
    }
    return 0;
}
/*
1. vim 1.getopt.c --创建源文件
2. gcc 1,getopt.c --编译
3. ./a.out -al -m &quot;xixi&quot; -o&quot;haha&quot; (m后面可以有空格， o后面不可以有空格)
*/
```xxxxxxxxxx10 1//common.h2#ifndef _COMMON_H3#define _COMMON_H45int make_nonblock(int fd); // 声明非阻塞6int make_block(int fd);   // 声明阻塞7~~~c8910c
</code></pre>
<h3 id="getopt函数命令行解析函数">getopt函数：命令行解析函数</h3>
<h3 id="头文件unistdh">头文件：&lt;unistd.h&gt;</h3>
<h4 id="原型int-getoptint-argc-char-const-argv-const-char-optstring">原型：int getopt(int argc, char *const argv[],  const char *optstring);</h4>
<h4 id="argc-argv-由main函数的参数直接传递而来">argc argv : 由main函数的参数直接传递而来</h4>
<h4 id="optstring-一个包含准确选项字符的字符串">optstring: 一个包含准确选项字符的字符串</h4>
<h4 id="返回值返回下一个选项">返回值：返回下一个选项</h4>
<h3 id="getopt设置的一些全局变量">getopt设置的一些全局变量</h3>
<h4 id="1char-optarg-指向当前选项参数如果有的指针">1.char *optarg : 指向当前选项参数（如果有）的指针。</h4>
<h4 id="2int-optind-再次调用getopt时的下一个argv指针的索引">2.int optind: 再次调用getopt()时的下一个argv指针的索引。</h4>
<h4 id="3int-optopt-最后一个已知选项">3.int optopt: 最后一个已知选项。</h4>
<h4 id="4-int-opterr-这个变量非零时向stderr打印错误-默认为1">4. int opterr: 这个变量非零时，向stderr打印错误。默认为1.</h4>
<h3 id="参数optstring详解">参数optstring详解</h3>
<h4 id="getopt函数的第三个参数optstring是一个有所有合法的可选字符所组成的字符串">getopt()函数的第三个参数optstring是一个有所有合法的“可选字符”所组成的字符串。</h4>
<h5 id="1-单个字符表示选项">1. 单个字符，表示选项。</h5>
<h5 id="2-单个字符后接一个冒号表示该选项后必须跟一个参数值-参数紧跟在选项后或者以空格隔开-该参数的指针赋给optarg">2. 单个字符后接一个冒号“：”，表示该选项后必须跟一个参数值。参数紧跟在选项后或者以空格隔开。该参数的指针赋给optarg。</h5>
<h5 id="3-单个字符后跟两个冒号表示该选项后可以带参数也可以不带-但参数必须紧跟在选项后不能以空格隔开-该参数的指针赋给optarg">3. 单个字符后跟两个冒号“：：”，表示该选项后可以带参数也可以不带。但参数必须紧跟在选项后不能以空格隔开。该参数的指针赋给optarg。</h5>
<h4 id="例子xyz-表示x选项没有选项参数y选项必须有选项参数中间可有空格可没有z参数可有参数选项也可没有参数选项但是如果有选项参数的话必须紧跟在选项之后不能有空格">例子：“xy:z::” 表示x选项没有选项参数，y选项必须有选项参数，中间可有空格可没有，z参数可有参数选项，也可没有参数选项，但是如果有选项参数的话必须紧跟在选项之后不能有空格。</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://azhanglai-github-io.vercel.app/post/hello-gridea/</id>
        <link href="https://azhanglai-github-io.vercel.app/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>