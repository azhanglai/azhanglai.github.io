<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Grideaé™æ€ä¸ªäººåšå®¢">
<meta name="description" content="æ¸©æ•…è€ŒçŸ¥æ–°">
<meta name="theme-color" content="#000">
<title>Hello Gridea | Bling</title>
<link rel="shortcut icon" href="/favicon.ico?v=1635761790195">
<link rel="stylesheet" href="/media/css/muse.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/yellow/pace-theme-corner-indicator.css" rel="stylesheet" />

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="Hello Gridea" />
  <meta name="keywords" content="Gridea" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="muse">
  <header class="header bg-color ">
    <div class="blog-header box-shadow-wrapper  " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Bling</span>
            </a>  
          
        </div>
        
          <p class="subtitle">ç²¾äºå¿ƒï¼Œç®€äºå½¢</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> é¦–é¡µ
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> å½’æ¡£
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> æ ‡ç­¾
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://azhanglai-github-io.vercel.app/about/" target="_self">
                  <i class="fa fa-globe"></i> å…³äº
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://azhanglai-github-io.vercel.app/LaiBDS//" target="_self">
                  <i class="fa fa-globe"></i> æ•°æ®ç»“æ„ä¸ç®—æ³•Cç‰ˆåŸºç¡€ç¯‡
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://azhanglai-github-io.vercel.app/LaiClearn//" target="_self">
                  <i class="fa fa-globe"></i> Cè¯­è¨€å­¦ä¹ ç¬”è®°
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://azhanglai-github-io.vercel.app/LaiDSOpt//" target="_self">
                  <i class="fa fa-globe"></i> æ•°æ®ç»“æ„åˆ·é¢˜é›†
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://azhanglai-github-io.vercel.app/LaiC++//" target="_self">
                  <i class="fa fa-globe"></i> C++å­¦ä¹ ç¬”è®°
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://azhanglai-github-io.vercel.app/Laialg//" target="_self">
                  <i class="fa fa-globe"></i> åˆ·é¢˜æ±‡æ€»
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> å‹æƒ…é“¾æ¥
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">æœç´¢</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout muse bg-color">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper  right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">æ–‡ç« ç›®å½•</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">ç«™ç‚¹æ¦‚è§ˆ</span>
          </div>
        </div>
      
      <div class="sidebar-body muse" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper ">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">å°å¼ </p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">29</span>
        <span class="site-item-stat-name language" data-lan="article">æ–‡ç« </span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">6</span>
        <span class="site-item-stat-name language" data-lan="category">åˆ†ç±»</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">6</span>
        <span class="site-item-stat-name language" data-lan="tag">æ ‡ç­¾</span>
      </a>
    </div>
  </div>
  
  


  <div class="sidebar-item">
    <script src="https://myhkw.cn/player/js/player.js" id="myhk" key="demo" m="1"></script>
  </div>


</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number no_compress"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%89%B9%E6%80%A7">ç‰¹æ€§ğŸ‘‡</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // ä¿å­˜liå…ƒç´ 
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // å¤„ç†ä¸æ˜¯ä»#ä¸€çº§æ ‡é¢˜å¼€å§‹ç›®å½•
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://azhanglai-github-io.vercel.app/hello-gridea/">
      Hello Gridea
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">å‘å¸ƒäº</span>
      <span class="publish-time" data-t="2018-12-12 00:00:00">2018-12-12</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">åˆ†ç±»äº</span>
      
      
      <a href="https://azhanglai-github-io.vercel.app/wDapr16Um/">
        <span>Gridea</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>2<span class="language" data-lan="minute">åˆ†é’Ÿ</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>298<span class="pc-show language" data-lan="words">å­—æ•°</span></span>
    </span>
    
    
    
    <span id="/hello-gridea/" data-flag-title="Hello Gridea" class="meta-item pc-show leancloud_visitors">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span><span class="language" data-lan="view">æµè§ˆé‡</span>ï¼š<span class="leancloud-visitors-count"></span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea ä¸»é¡µ</a><br>
<a href="http://fehey.com/">ç¤ºä¾‹ç½‘ç«™</a></p>
<h2 id="ç‰¹æ€§">ç‰¹æ€§ğŸ‘‡</h2>
<p>ğŸ“  ä½ å¯ä»¥ä½¿ç”¨æœ€é…·çš„ <strong>Markdown</strong> è¯­æ³•ï¼Œè¿›è¡Œå¿«é€Ÿåˆ›ä½œ</p>
<p>ğŸŒ‰  ä½ å¯ä»¥ç»™æ–‡ç« é…ä¸Šç²¾ç¾çš„å°é¢å›¾å’Œåœ¨æ–‡ç« ä»»æ„ä½ç½®æ’å…¥å›¾ç‰‡</p>
<p>ğŸ·ï¸  ä½ å¯ä»¥å¯¹æ–‡ç« è¿›è¡Œæ ‡ç­¾åˆ†ç»„</p>
<p>ğŸ“‹  ä½ å¯ä»¥è‡ªå®šä¹‰èœå•ï¼Œç”šè‡³å¯ä»¥åˆ›å»ºå¤–éƒ¨é“¾æ¥èœå•</p>
<p>ğŸ’»  ä½ å¯ä»¥åœ¨ <strong>Windows</strong>ï¼Œ<strong>MacOS</strong> æˆ– <strong>Linux</strong> è®¾å¤‡ä¸Šä½¿ç”¨æ­¤å®¢æˆ·ç«¯</p>
<p>ğŸŒ  ä½ å¯ä»¥ä½¿ç”¨ <strong>ğ–¦ğ—‚ğ—ğ—ğ—ğ–» ğ–¯ğ–ºğ—€ğ–¾ğ—Œ</strong> æˆ– <strong>Coding Pages</strong> å‘ä¸–ç•Œå±•ç¤ºï¼Œæœªæ¥å°†æ”¯æŒæ›´å¤šå¹³å°</p>
<p>ğŸ’¬  ä½ å¯ä»¥è¿›è¡Œç®€å•çš„é…ç½®ï¼Œæ¥å…¥ <a href="https://github.com/gitalk/gitalk">Gitalk</a> æˆ– <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> è¯„è®ºç³»ç»Ÿ</p>
<p>ğŸ‡¬ğŸ‡§  ä½ å¯ä»¥ä½¿ç”¨<strong>ä¸­æ–‡ç®€ä½“</strong>æˆ–<strong>è‹±è¯­</strong></p>
<p>ğŸŒ  ä½ å¯ä»¥ä»»æ„ä½¿ç”¨åº”ç”¨å†…é»˜è®¤ä¸»é¢˜æˆ–ä»»æ„ç¬¬ä¸‰æ–¹ä¸»é¢˜ï¼Œå¼ºå¤§çš„ä¸»é¢˜è‡ªå®šä¹‰èƒ½åŠ›</p>
<p>ğŸ–¥  ä½ å¯ä»¥è‡ªå®šä¹‰æºæ–‡ä»¶å¤¹ï¼Œåˆ©ç”¨ OneDriveã€ç™¾åº¦ç½‘ç›˜ã€iCloudã€Dropbox ç­‰è¿›è¡Œå¤šè®¾å¤‡åŒæ­¥</p>
<p>ğŸŒ± å½“ç„¶ <strong>Gridea</strong> è¿˜å¾ˆå¹´è½»ï¼Œæœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡ï¼Œå®ƒä¼šä¸åœå‘å‰ ğŸƒ</p>
<p>æœªæ¥ï¼Œå®ƒä¸€å®šä¼šæˆä¸ºä½ ç¦»ä¸å¼€çš„ä¼™ä¼´</p>
<p>å°½æƒ…å‘æŒ¥ä½ çš„æ‰åå§ï¼</p>
<p>ğŸ˜˜ Enjoy~</p>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">æœ¬æ–‡ä½œè€…ï¼š</strong>
      å°å¼ 
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">æœ¬æ–‡é“¾æ¥ï¼š</strong>
      <a href="https://azhanglai-github-io.vercel.app/hello-gridea/" title="Hello Gridea">https://azhanglai-github-io.vercel.app/hello-gridea/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">ç‰ˆæƒå£°æ˜ï¼š </strong>
      æœ¬åšå®¢æ‰€æœ‰æ–‡ç« é™¤ç‰¹åˆ«å£°æ˜å¤–ï¼Œå‡é‡‡ç”¨<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> è®¸å¯åè®®ã€‚è½¬è½½è¯·æ³¨æ˜å‡ºå¤„ï¼
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://azhanglai-github-io.vercel.app/wDapr16Um/"># Gridea</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Cè¯­è¨€-1.è¾“å…¥è¾“å‡ºå­¦ä¹ " href="https://azhanglai-github-io.vercel.app/Cè¯­è¨€-1.è¾“å…¥è¾“å‡ºå­¦ä¹ /">Cè¯­è¨€-1.è¾“å…¥è¾“å‡ºå­¦ä¹ </a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Cè¯­è¨€-1.è¾“å…¥è¾“å‡ºå­¦ä¹ " href="https://azhanglai-github-io.vercel.app/Cè¯­è¨€-1.è¾“å…¥è¾“å‡ºå­¦ä¹ /">ä¸Šä¸€ç¯‡</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="äºŒå‰æ ‘-åˆ·é¢˜é›†" href="https://azhanglai-github-io.vercel.app/äºŒå‰æ ‘-åˆ·é¢˜é›† /">äºŒå‰æ ‘-åˆ·é¢˜é›†</a>
        <a class="nav-mobile-next" title="äºŒå‰æ ‘-åˆ·é¢˜é›†" href="https://azhanglai-github-io.vercel.app/äºŒå‰æ ‘-åˆ·é¢˜é›† /">ä¸‹ä¸€ç¯‡</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  <script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>

<style>
  .v .veditor {
    min-height: 10rem;
    background-image: url('');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
    background-color: rgba(255, 255, 255, 0);
    resize: none;
  }

  .v .vwrap {
    border: 1px solid #000 !important;
  }

  .v .vbtn {
    padding: .4rem 1.2rem !important;
    border-color: #fff !important;
    background-color: #49b1f5 !important;
    color: #fff !important;
    font-size: .7rem !important;
  }

  .v .vcards .vcard .vh .vmeta .vat {
    padding: 0 .8rem !important;
    border: 1px solid #00c4b6 !important;
    border-radius: 5px !important;
    color: #00c4b6 !important;
  }
</style>
<script>
  new Valine({
    el: '#vcomments',
    appId: 'C2yIoDu5Gzzdf8TAxMWoEd1w-gzGzoHsz',
    appKey: '38eqXPT7vq0raXMj2txOP2LI',
    avatar: '',
    placeholder: 'Say something...',
    pageSize: '',
    lang: 'zh-cn',
    enableQQ: 'true' === 'true',
    visitor: 'true' === 'true',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'true',
  });
</script>

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <span id="busuanzi_container_site_pv">æµè§ˆæ•° <span id="busuanzi_value_site_pv"></span> æ¬¡</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">è®¿å®¢æ•° <span id="busuanzi_value_site_uv"></span> äºº</span>
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
  
  <div class="drawer-box left" id="drawer_box">
    <span class="muse-line muse-line-first"></span>
    <span class="muse-line muse-line-middle"></span>
    <span class="muse-line muse-line-last"></span>
  </div>
  
  <div class="muse back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
  </div>
  
  
  
  <div class="bg-img">
    <img src="media\images\1.jpg" />
  </div>
  
  
  
  
  

  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.addEventListener('resize', function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // åŠ¨æ€è°ƒæ•´ç«™ç‚¹æ¦‚è§ˆé«˜åº¦
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, 'stop');
      jQuery.Velocity(viewport, 'stop');
      jQuery.Velocity(rightMotions, 'stop');
      if (open) {
        jQuery.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            jQuery.Velocity(rightMotions, transitionDir, {});
          }
        })
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        jQuery.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            jQuery.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // é“¾æ¥è·³è½¬
  let newWindow = 'true'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch && faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // ä»£ç é«˜äº®
  hljs.initHighlightingOnLoad();
  
  // ç¦»å¼€å½“å‰é¡µtitleå˜åŒ–
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll('.section img');
  images.forEach(image => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'images';
    aelem.dataset['rel'] = 'fancybox-button';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  })
</script>

    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>æ„Ÿè°¢æ‚¨çš„æ”¯æŒï¼Œæˆ‘ä¼šç»§ç»­åŠªåŠ›çš„!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">æ‰«ç æ‰“èµï¼Œä½ è¯´å¤šå°‘å°±å¤šå°‘</p>
      <p class="reward-tip">æ‰“å¼€å¾®ä¿¡æ‰«ä¸€æ‰«ï¼Œå³å¯è¿›è¡Œæ‰«ç æ‰“èµå“¦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="æœç´¢">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">æ¡ç›¸å…³æ¡ç›®ï¼Œä½¿ç”¨äº†</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">æ¯«ç§’</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/ç®—æ³•æ¡†æ¶/"" data-c="
          &lt;p&gt;â€‹&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&#34;ç®—æ³•ç¬”è®°10&#34;&gt;ç®—æ³•ç¬”è®°1.0&lt;/h3&gt;
&lt;h4 id=&#34;1æ’åºç®—æ³•&#34;&gt;1.æ’åºç®—æ³•&lt;/h4&gt;
&lt;h5 id=&#34;11-ç¨³å®šæ’åº&#34;&gt;1.1 ç¨³å®šæ’åº&lt;/h5&gt;
&lt;h6 id=&#34;111-å†’æ³¡æ’åº&#34;&gt;1.1.1 å†’æ³¡æ’åº&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void bubble_sort(int *num, int n) {
    int flag = 1;
    for (int i = 1; i &amp;lt; n &amp;amp;&amp;amp; flag == 1; ++i) {
        flag = 0;
        for (int j = 0; j &amp;lt; n - i; ++j) {
            if (num[j] &amp;gt; num[j + 1]) {
                swap(num[j], num[j + 1]);
                flag = 1;
            }
        }
    }
    return ;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;112-æ’å…¥æ’åº&#34;&gt;1.1.2 æ’å…¥æ’åº&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void insert_sort(int *num, int n) {
    for (int i = 1; i &amp;lt; n; ++i) {
        for (int j = i; j &amp;gt; 0; --j) {
            if (num[j] &amp;lt; num[j - 1]) {
                swap(num[j], num[j - 1]);
            }
        }
    }
    return ;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;113å½’å¹¶æ’åº&#34;&gt;1.1.3å½’å¹¶æ’åº&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void merge_sort(int *num, int l, int r) {
    if (r - l &amp;lt;= 1) {
        if (r - l == 1 &amp;amp;&amp;amp; num[l] &amp;gt; num[r]) {
            swap(num[l], num[r]);
        }
        return ;
    }
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    merge_sort(num, l, mid);
    merge_sort(num, mid + 1, r);
    
    int *temp = (int *)malloc(sizeof(int) * (r - l + 1));
    int p1 = 1, p2 = mid + 1, k = 0;
    while (p1 &amp;lt;= mid || p2 &amp;lt;= r) {
        if (p2 &amp;gt; r || (p1 &amp;lt;= mid &amp;amp;&amp;amp; num[p1] &amp;lt;= num[p2])) {
            temp[k++] = num[p1++];
        } else {
            temp[k++] = num[p2++];
        }
    }
    memcpy(num + l, temp, sizeof(int) * (r - l + 1));
    free(temp);
    return ;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;12éç¨³å®šæ’åº&#34;&gt;1.2éç¨³å®šæ’åº&lt;/h5&gt;
&lt;h6 id=&#34;121é€‰æ‹©æ’åº&#34;&gt;1.2.1é€‰æ‹©æ’åº&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void select_sort(int *num, int n) {
    for (int i = 0; i &amp;lt; n - 1; ++i) {
        int ind = i;
        for (int j = i; j &amp;lt; n; ++j) {
            if (num[j] &amp;lt; num[ind]) ind = j;
        }
        swap(num[i], num[ind]);
    }
    return ;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;122åŸºç¡€å¿«æ’&#34;&gt;1.2.2åŸºç¡€å¿«æ’&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void quick_sort1(int *num, int l, int r) {
    if (l &amp;gt;= r) return ;
    int x = l, y = r, z = num[x];
    while (x &amp;lt; y) {
        while (x &amp;lt; y &amp;amp;&amp;amp; num[y] &amp;gt; z) y--;
        if (x &amp;lt; y) num[x++] = num[y];
        while (x &amp;lt; y &amp;amp;&amp;amp; num[x] &amp;lt; z) x++;
        if (x &amp;lt; y) num[y--] = num[x];
    }
    num[x] = z;
    quick_sort1(num, l, x - 1);
    quick_sort1(num, x + 1, r);
    return ;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;123ä¼˜åŒ–åçš„å¿«æ’&#34;&gt;1.2.3ä¼˜åŒ–åçš„å¿«æ’&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void quick_sort2(int *num, int l, int r) {
    while (l &amp;lt; r) {
        int x = l, y = r, z = num[l + (r - l) / 2];
        do {
            while (x &amp;lt;= y &amp;amp;&amp;amp; num[x] &amp;lt; z) x++;
            while (x &amp;lt;= y &amp;amp;&amp;amp; z &amp;lt; num[y]) y--;
            if (x &amp;lt;= y) {
                swap(num[x], num[y]);
                x++, y--;
            }
        } while (x &amp;lt;= y);
        quick_sort2(num, x, r);
        r = y;
    }
    return ;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;124å †æ’åº&#34;&gt;1.2.4å †æ’åº&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// çº¿æ€§å»ºå † (è‡ªé¡¶å‘ä¸‹è°ƒæ•´)
void nHeap(int *arr, int ind, int size) {
    while (ind &amp;lt;&amp;lt; 1 &amp;lt;= size) {
        int temp = ind, dl = ind &amp;lt;&amp;lt; 1, dr = ind &amp;lt;&amp;lt; 1 | 1;
        if (arr[temp] &amp;lt; arr[dl]) temp = d1;
        if (dr &amp;lt;= size &amp;amp;&amp;amp; arr[temp] &amp;lt; arr[dr]) temp = dr;
        if (temp == ind) break;
        swap(arr[ind], arr[temp]);
        ind = temp;
    }
    return ;
}
// å †æ’åº
void heap_sort(int *arr, int n) {
    arr -= 1;
    // ä»å€’æ•°ç¬¬äºŒæ’å¼€å§‹å»ºå †ï¼ˆå€’æ•°ç¬¬ä¸€æ’ä¸éœ€è¦ç»´æŒï¼‰
    for (int i = n &amp;gt;&amp;gt; 1; i &amp;gt; 0; --i) {
        nHeap(arr, i, n);
    }
    // ç¬¬ä¸€æ¬¡å»ºå †å®Œæ¯•ä¹‹åï¼Œæœ€å¤§ï¼ˆå°ï¼‰åœ¨å †é¡¶äº†
    for (int i = n; i &amp;gt; 0; --i) {
        // æŠŠæœ€åä¸€ä¸ªå…ƒç´ å’Œç¬¬ä¸€ä¸ªå…ƒç´ äº¤æ¢ï¼Œè¿™æ ·æœ€åä¸€ä¸ªå…ƒç´ å°±å˜æˆæœ€å¤§ï¼ˆå°ï¼‰äº†
        swap(arr[i], arr[1]);
        // ä¿æŒå †çš„çŠ¶æ€ï¼Œä»ç¬¬ä¸€å…ƒç´ å¼€å§‹äº†ï¼Œ å…ƒç´ ä¸ªæ•°ä¹Ÿæ˜¯å‡ä¸€äº†
        nHeap(arr, 1, i - 1);
    }
    return ;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•&#34;&gt;2.å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•&lt;/h4&gt;
&lt;h5 id=&#34;21-æœ´ç´ åŒ¹é…ç®—æ³•&#34;&gt;2.1 æœ´ç´ åŒ¹é…ç®—æ³•&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int brute_force(const char *s, const char *t) {
    for (int i = 0; s[i]; ++i) {
        int flag = 1;
        for (int j = 0; t[j]; ++j) {
            if (s[i + j] != t[j]) {
                flag = 0;
                break;
            }
        }
        if (flag == 1) return i;
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;22-kmpåŒ¹é…ç®—æ³•&#34;&gt;2.2 KMPåŒ¹é…ç®—æ³•&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int Kmp(const char *s, const char *t) {
    int next[manx];
    next[0] = -1;
    // æ ¸å¿ƒæ€æƒ³ï¼šåˆå§‹ä½ç½®:i = 0, j = -1, åˆ¤æ–­t[i] ?= t[j + 1],ç­‰äºj++, ä¸ç­‰äºj = next[j]
    for (int i = 1; j = -1; t[i]; ++i) {
        while (j != -1 &amp;amp;&amp;amp; t[i] != t[j + 1]) j = next[j];
        if (t[i] == t[j + 1]) j++;
        next[i] = j;
    }
    //æ ¸å¿ƒæ€æƒ³ï¼šåˆå§‹ä½ç½®:i = 0, j = -1, åˆ¤æ–­s[i] ?= t[j + 1],ç­‰äºj++,ä¸ç­‰äºj = next[j]
    for (int i = 0; j = -1; s[i]; i++) {
        while (j != -1 &amp;amp;&amp;amp; s[i] != t[j + 1]) j = next[j];
        if (s[i] == t[j + 1]) j++;
        if (t[j + 1] == &#39;\0&#39;) return i - j;
    }
    return -1;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;23-sundayåŒ¹é…ç®—æ³•&#34;&gt;2.3 SundayåŒ¹é…ç®—æ³•&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int Sunday(const char *s, const char *t) {
    int len_s = strlen(s), len_t = strlen(t);
    int ind[256];
    for (int i = 0; i &amp;lt; 256; ++i) ind[i] = len_t + 1;
    for (int i = 0; t[i]; ++i) ind[t[i]] = len_t - i;
    int i = 0;
    while (i + len_t &amp;lt;= len_s) {
        int flag = 1;
        for (int j = 0; t[j]; ++j) {
            if (s[i + j] == t[j]) continue;
            flag = 0;
        	break;
        }
        if (flag == 1) return i;
        //æ ¸å¿ƒä»£ç ï¼šï¼ˆå› ä¸ºæ•°ç»„ä»0å¼€å§‹ï¼‰ï¼Œæ¨¡å¼ä¸²ä¼šæ ¹æ®æ¯ä¸²len_tä½ç½®çš„å­—ç¬¦é€‰æ‹©ç§»ä½
        i += ind[s[i + len_t]]; // sä¸²ä¸­len_tçš„ä¸‹ä¸€ä¸ª
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;24-shift_and-åŒ¹é…ç®—æ³•&#34;&gt;2.4 Shift_and åŒ¹é…ç®—æ³•&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int shift_and(const char *s, const char *t) {
    int code[256] = {0};
    for (int i = 0; t[i]; ++i) code[t[i]] |= (1 &amp;lt;&amp;lt; i); // ç¼–ç 
    int p = 0; // æ ‡å¿—ä½
    // æ ¸å¿ƒæ€æƒ³ï¼šPï¼Œå½“P = 10 æˆ– 11æ—¶å·²ç»æˆåŠŸåŒ¹é…2ä½å­—ç¬¦ï¼Œp = 1000æˆ–1010æ—¶å·²ç»æˆåŠŸåŒ¹é…4ä½
    // è‹¥æ¨¡å¼ä¸²çš„é•¿åº¦ä¸º5ï¼Œé‚£ä¹ˆ p = 10000,é‚£ä¹ˆåŒ¹é…æˆåŠŸ
    int len_t = strlen(t);
    for (int i = 0; s[i]; ++i) {
    // pæ¯æ¬¡éƒ½å‘å·¦ç§»1ä½å¹¶æˆ–ä¸Šä¸€ä¸ª1ï¼Œæœ€å³è¾¹æ˜¯1ï¼Œå› ä¸ºæ¯æ¬¡éƒ½å·¦ç§»1ä½ï¼Œå¦‚æœä¸èµ·æ¥ä¹Ÿä¸º1é‚£ä¹ˆå•å­—ç¬¦åŒ¹é…æˆåŠŸ 
        p = ((p &amp;lt;&amp;lt; 1) | 1) &amp;amp; code[s[i]];
        if (p &amp;amp; (1 &amp;lt;&amp;lt; (len_t - 1))) {
            return i - len_t + 1;
        }
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;25-acè‡ªåŠ¨æœº&#34;&gt;2.5 ACè‡ªåŠ¨æœº&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// ç»“æ„å®šä¹‰
typedef struct node {
    const char *str;
    struct node *next[base], *fail;
} Node;
// åˆ›å»ºèŠ‚ç‚¹
Node *getNewNode() {
    Node *p = (Node *)malloc(sizeof(Node));
    p-&amp;gt;str = NULL;
    p-&amp;gt;fail = NULL;
    memset(p-&amp;gt;next, 0, sizeof(Node *) * base);
    return p;
}
// é”€æ¯ï¼ˆå›æ”¶å†…å­˜ç©ºé—´ï¼‰
void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i &amp;lt; base; ++i) {
        clear(root-&amp;gt;next[i]);
    }
    if (root-&amp;gt;fail) free(root-&amp;gt;fail);
    free(root);
    return ;
}
// å¤åˆ¶å­—ç¬¦ä¸²
const char *Copystr(const char *s) {
    int n = strlen(s);
    char *buff = (char *)malloc(sizeof(n + 1));
    strcpy(buff, s);
    return buff;
}
// æ’å…¥æ“ä½œ
void insert(Node *root, const char *s) {
    Node *p = root;
    for (int i = 0; s[i]; ++i) {
        int ind = s[i] - &#39;a&#39;;
        if (p-&amp;gt;next[ind] == NULL) {
            p-&amp;gt;next[ind] = getNewNode();
        }
        p = p-&amp;gt;next[ind];
    }
    p-&amp;gt;str = Copystr(s);
}
// æ„å»ºAC_tree, ä½¿ç”¨é˜Ÿåˆ—å±‚åºéå†
void build_fail(Node *root) {
    root-&amp;gt;fail = NULL;
    queue&amp;lt;Node *&amp;gt; que;
    for (int i = 0; i &amp;lt; base; ++i) {
        if (root-&amp;gt;next[i] == NULL) {
            root-&amp;gt;next[i] = root;
            continue;
        }
        root-&amp;gt;next[i]-&amp;gt;fail = root;
        que.push(root-&amp;gt;next[i]);
    }
    while (!que.empty()) {
        Node *p = que.front();
        for (int i = 0; i &amp;lt; base; ++i) {
            Node *ch = p-&amp;gt;next[i], *fn = p-&amp;gt;fail-&amp;gt;next[i];
            if (p-&amp;gt;next[i] == NULL) {
                p-&amp;gt;next[i] = fn;
                continue;
            }
            p-&amp;gt;next[i]-&amp;gt;fail = fn;
            que.push(p-&amp;gt;next[i]);
        }
        que.pop();
    }
    return ;
}
// ACåŒ¹é…
void ac_match(Node *root, const char *s) {
    Node *p = root, *q;
    for (int i = 0; s[i]; ++i) {
        int ind = s[i] - &#39;a&#39;;
        p = p-&amp;gt;next[ind];
        q = p;
        while (q) {
            if (q-&amp;gt;str) printf(&amp;quot;find %s\n&amp;quot;, q-&amp;gt;str);
            q = q-&amp;gt;fail;
        }
    }
    return ;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;26-å›æ–‡ä¸²åŒ¹é…é©¬æ‹‰è½¦&#34;&gt;2.6 å›æ–‡ä¸²åŒ¹é…ï¼ˆé©¬æ‹‰è½¦ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    // 1.å¤„ç†åŸå­—ç¬¦ä¸²ï¼Œå¦‚abba,å¤„ç†æˆ#a#b#b#a#,è¿™æ ·åªæœ‰ä¸€ç§æƒ…å†µäº†ï¼ˆåªæœ‰å•æ•°ï¼‰ï¼Œæ¯”è¾ƒå¥½å¤„ç†
    string getNewstr(string &amp;amp;str) {
    	string gns = &amp;quot;#&amp;quot;;
        for (int i = 0; str[i]; ++i) {
            (gns += str[i]) += &amp;quot;#&amp;quot;;
        }
        return gns;
    } 
    
    string longestPalindrome(string s){
        if (s.size() == 0) return &amp;quot;&amp;quot;; // å¦‚æœè¾“å…¥çš„å­—ç¬¦ä¸²ä¸ºç©ºï¼Œåˆ™è¿”å›â€œâ€
        string gns = getNewstr(s); // å¤„ç†åŸå­—ç¬¦ä¸²
        int n = gns.size();
        vector&amp;lt;int&amp;gt; dis(n); // ç”¨ä¸€ç»´æ•°ç»„å­˜æ¯ä¸ªä½ç½®çš„å›æ–‡ä¸²çš„é•¿åº¦
        int l = 0, r = -1; // æ¯ä¸ªå­å›æ–‡ä¸²çš„å·¦å³è¾¹ç•Œ
        for (int i = 0; i &amp;lt; n; ++i) {
            if (i &amp;gt; r) dis[i] = 1; // å½“i &amp;gt; ræ—¶ï¼Œå¤§äºå³è¾¹ç•Œï¼Œåªèƒ½ç”¨æœ´ç´ çš„æ–¹å¼ï¼Œä¸€ä¸ªä¸€ä¸ªçš„å»åˆ¤æ–­
             // åœ¨lå’Œrä¹‹é—´çš„æ˜¯å›æ–‡ä¸²ï¼Œæ‰€ä»¥å·¦å³å¯¹ç§°ï¼Œiçš„ä½ç½®disç­‰äºl+r-iä½ç½®çš„dis,åªèƒ½å–lå’Œrä¹‹é—´çš„ï¼Œ
            // æ‰€ä»¥éœ€è¦å’Œ r-i æ¯”è¾ƒ
            else dis[i] = min(dis[l + r - i], r - i);
            // i + dis[i] å’Œ i - dis[i]ä¸èƒ½è¶…å­—ç¬¦ä¸²è¾¹ç•Œ
            // å¦‚æœi - dis[i] å’Œ i + dis[i] ä½ç½®çš„å­—ç¬¦ç›¸ç­‰ï¼Œé‚£ä¹ˆè¯¥å­å›æ–‡å­—ç¬¦ä¸²é•¿åº¦+1
            while (i + dis[i] &amp;lt; n &amp;amp;&amp;amp; i - dis[i] &amp;gt;= 0 &amp;amp;&amp;amp; gns[i - dis[i]] == gns[i + dis[i]]) {
                dis[i]++;
            }
            // å¦‚æœ i + dis[i] è¶…è¿‡å³è¾¹ç•Œï¼Œ å¹¶ä¸” i - dis[i]è¦å¤§äº0ï¼Œä¸èƒ½è¶Šç•Œ
            // æ›´æ–°å­å›æ–‡ä¸²çš„å·¦å³è¾¹ç•Œï¼Œl å’Œ r
            if (i + dis[i] &amp;gt; r &amp;amp;&amp;amp; i - dis[i] &amp;gt; 0) {
                l = i - dis[i];
                r = i + dis[i];
            }
        }
        string ans; // å­˜ç­”æ¡ˆå­—ç¬¦ä¸²ï¼ˆæœ€é•¿çš„å›æ–‡ä¸²ï¼‰
        int tmp = 0; // å­˜ä¸´æ—¶dis[i]çš„é•¿åº¦
        for (int i = 0; i &amp;lt; n; ++i) {
            if (dis[i] &amp;lt;= tmp) continue; // å¦‚æœè¯¥dis[i]å°äºtmp, ä¸‹ä¸€ä¸ª 
            tmp = dis[i];
            ans = &amp;quot;&amp;quot;; // æ¯æ¬¡éƒ½è¦æ›´æ–°å­˜ä¸€ä¸‹å›æ–‡ä¸²ï¼ˆç›´è‡³æœ€é•¿å¾—ï¼‰
            // æ¯ä¸ªå­å›æ–‡ä¸²çš„ä½ç½® ä» i-dis[i]å¼€å§‹é¿å…è¶Šç•Œè¦+1ï¼Œåˆ°i+dis[i]ä½ç½®
            for (int j = i - dis[i] + 1; j &amp;lt; i + dis[i]; ++j) {
                if (gns[j] == &#39;#&#39;) continue;
                ans += gns[j];
            }
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3åˆ¤æ–­è¿é€šæ€§ä¸ç»¼åˆæœç´¢ç®—æ³•&#34;&gt;3.åˆ¤æ–­è¿é€šæ€§ä¸ç»¼åˆæœç´¢ç®—æ³•&lt;/h4&gt;
&lt;h5 id=&#34;31å¹¶æŸ¥é›†&#34;&gt;3.1å¹¶æŸ¥é›†&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// ç»“æ„å®šä¹‰
typedef struct UnionSet {
    int *data;
    int size;
} unionSet;
// åˆ›å»ºï¼ˆåˆå§‹åŒ–ï¼‰
unionSet *init(int n) {
    unionSet *u = (unionSet *)malloc(sizeof(unionSet));
    u-&amp;gt;data = (int *)malloc(sizeof(int) * (n + 1));
    u-&amp;gt;size = n;
    for (int i = 1; i &amp;lt;= n; ++i) {
        u-&amp;gt;data[i] = i;
    }
    return u;
}
// é”€æ¯ï¼ˆå›æ”¶ï¼‰
void clear(unionSet *u) {
    if (u == NULL) return ;
    free(u-&amp;gt;data);
    free(u);
    return ;
}
// æŸ¥é›†
int find(unionSet *u, int x) {
    return x == u-&amp;gt;data[x] ? x : (u-&amp;gt;data[x] = find(u, u-&amp;gt;data[x]));
}
// å¹¶é›†
void union_find(unionSet *u, int a, int b) {
    int fa = find(u, a), fb = find(u, b);
    if (fa == fb) return ;
    u-&amp;gt;data[fa] = fb;
    return ;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;32-æ·±æœæ¡†æ¶&#34;&gt;3.2 æ·±æœæ¡†æ¶&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int n, m, sx, sy;       // åœ°å›¾å¤§å°ï¼Œ èµ·å§‹ç‚¹
int dir[4][2] = {....}; // æ–¹å‘æ•°ç»„
char mmap[105][105];    // å­˜å‚¨è¾“å…¥çš„åœ°å›¾

// å­˜å‚¨åœ°å›¾ï¼Œ(1, 1)ç‚¹å¼€å§‹å­˜ï¼Œä¸€èˆ¬ä¸ç”¨åˆ¤æ–­è¾¹ç•Œ
for (int i = 1; i &amp;lt;= n; ++i) {
    for (int j = 1; j &amp;lt;= m; ++j) {
        cin &amp;gt;&amp;gt; mmap[i][j];
        if (mmap[i][j] == &#39;S&#39;) {
            sx = i, sy = j;
        }
    }
}

int dfs(int x, int y) {
    for (int i = 0; i &amp;lt; 4; ++i) {           // éå†æœç´¢
        int nx = x + dir[i][0];
        int ny = y + dir[i][1];
        if (mmap[nx][ny] == &#39;T&#39;) return 1;  // æ‰¾åˆ°ç»ˆç‚¹
        else if (mmap[nx][ny] == &#39;.&#39;) {     // å¯ä»¥èµ°  
            mmap[nx][ny] = &#39;!&#39;;             // åŸåœ°æ ‡è®°å»é‡
            if (dfs(nx, ny)) return 1;      // ç»§ç»­æ·±æœ
        }
    }
    return 0ï¼›
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;33-å¹¿æœæ¡†æ¶&#34;&gt;3.3 å¹¿æœæ¡†æ¶&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int n, m, sx, sy;       // åœ°å›¾å¤§å°ï¼Œ èµ·å§‹ç‚¹
int dir[4][2] = {....}; // æ–¹å‘æ•°ç»„
char mmap[105][105];    // å­˜å‚¨è¾“å…¥çš„åœ°å›¾
struct node {           // åŠ ä¸ªæ­¥æ•°
    int x, y, step;
};

// å­˜å‚¨åœ°å›¾ï¼Œ(1, 1)ç‚¹å¼€å§‹å­˜ï¼Œä¸€èˆ¬ä¸ç”¨åˆ¤æ–­è¾¹ç•Œ
for (int i = 1; i &amp;lt;= n; ++i) {
    for (int j = 1; j &amp;lt;= m; ++j) {
        cin &amp;gt;&amp;gt; mmap[i][j];
        if (mmap[i][j] == &#39;S&#39;) {
            sx = i, sy = j;
        }
    }
}
// BFS
queue&amp;lt;node&amp;gt; que;
que.push((node){sx, sy, 0});
while (!que.empty()) {
    node t = que.front(); que.pop();              // å‡ºé˜Ÿ
    for (int i = 0; i &amp;lt; 4; i++) {                 // éå†æœç´¢
        int nx = t.x + dir[i][0];
        int ny = t.y + dir[i][1];
        if (mmap[nx][ny] == &#39;T&#39;) {                // æ‰¾åˆ°ç»ˆç‚¹
            return t.step + 1;        
        } else if (mmap[nx][ny] == &#39;.&#39;) {
            que.push((node){nx, ny, t.step + 1}); // å…¥é˜Ÿï¼Œæ­¥æ•°+1
            mmap[nx][ny] = &#39;!&#39;;                   // åŸåœ°æ ‡è®°å»é‡
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4èƒŒåŒ…é—®é¢˜&#34;&gt;4.èƒŒåŒ…é—®é¢˜&lt;/h4&gt;
&lt;h5 id=&#34;41-0-1èƒŒåŒ…æ¯æ ·ç‰©å“åªæœ‰ä¸€ä»¶&#34;&gt;4.1 0-1èƒŒåŒ…ï¼ˆæ¯æ ·ç‰©å“åªæœ‰ä¸€ä»¶ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// 0-1èƒŒåŒ…çš„ ç©ºé—´å‹ç¼©
int n, vall, v[105], w[105], dp[10005];
// çŠ¶æ€å®šä¹‰ï¼šdp[i][j]:å‰iä»¶ç‰©å“ï¼Œåœ¨ä»£ä»·(é‡é‡æˆ–ä½“ç§¯)ä¸ºjæ—¶ï¼Œèƒ½è·å¾—çš„æœ€å¤§ä»·å€¼
// ä¸‹ä¸€è¡Œåªä¸ä¸Šä¸€è¡Œï¼ˆå·¦ä¸Šè§’å’Œæ­£ä¸Šæ–¹ï¼‰æœ‰å…³ï¼Œåªéœ€ä¸€è¡Œå°±å¯ä»¥äº†
int main() {
    cin &amp;gt;&amp;gt; vall &amp;gt;&amp;gt; n;                        // vallï¼šèƒŒåŒ…çš„æœ€å¤§æ‰¿é‡ï¼Œnä»¶ç‰©å“
    for (int i = 1; i &amp;lt;= n; i++) {
        cin &amp;gt;&amp;gt; v[i] &amp;gt;&amp;gt; w[i];                 // v[i]:ç¬¬iä»¶ç‰©å“çš„é‡é‡ï¼Œ w[i]:ç¬¬iä»¶ç‰©å“çš„ä»·æ ¼
    }
    for (int i = 1; i &amp;lt;= n; i++) {
        for (int j = vall; j &amp;gt;= v[i]; j--) {      // å…³é”®é€†åºï¼Œä»åå¾€å‰
            // j &amp;gt;= v[i]ï¼šè‚¯å®šä¹°å¾—èµ·
            dp[j] = max(dp[j], dp[j-v[i]] + w[i]);
        }
    }
    cout &amp;lt;&amp;lt; dp[vall] &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;42-å®Œå…¨èƒŒåŒ…æ¯æ ·ç‰©å“åªæœ‰æ— é™å¤š&#34;&gt;4.2 å®Œå…¨èƒŒåŒ…ï¼ˆæ¯æ ·ç‰©å“åªæœ‰æ— é™å¤šï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// å®Œå…¨èƒŒåŒ… ç©ºé—´å‹ç¼©
// çŠ¶æ€å®šä¹‰ï¼šdp[i][j]:å‰iä»¶ç‰©å“ï¼Œåœ¨ä»£ä»·(é‡é‡æˆ–ä½“ç§¯)ä¸ºjæ—¶ï¼Œèƒ½è·å¾—çš„æœ€å¤§ä»·å€¼
// ä¸‹ä¸€è¡Œä¸ä¸Šä¸€è¡Œï¼ˆæ­£ä¸Šæ–¹ï¼‰å’ŒåŒä¸€è¡Œçš„å·¦å‰æ–¹æœ‰å…³ï¼Œåªéœ€ä¸€è¡Œå°±å¯ä»¥äº†
int n, vall, v[10005], w[10005], dp[10005];
int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; vall;
    for (int i = 1; i &amp;lt;= n; i++) {
        cin &amp;gt;&amp;gt; v[i] &amp;gt;&amp;gt; w[i];
    }
    for (int i = 1; i &amp;lt;= n; ++i) {
        for (int j = v[i]; j &amp;lt;= vall; ++j) {       // å…³é”®æ­£åºï¼šä»å‰å¾€å
            // j = v[i],è‚¯å®šä¹°å¾—èµ·
 			dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
        }
    }
    cout &amp;lt;&amp;lt; dp[vall] &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;43å¤šé‡èƒŒåŒ…æ¯æ ·ç‰©å“æœ‰æ•°é‡&#34;&gt;4.3å¤šé‡èƒŒåŒ…ï¼ˆæ¯æ ·ç‰©å“æœ‰æ•°é‡ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// æŠŠå¤šé‡èƒŒåŒ…æ‹†æˆ 0-1èƒŒåŒ…ï¼ˆbitæ³•æ‹†ï¼‰
int n, vall, v[10005], w[10005], dp[100005];
int bit[25], ind = 1;
void init() {
    int t = 1;
    for (int i = 0; i &amp;lt; 21; i++) {
        bit[i] = t;
        t *= 2;
    }
    return ;
}
int main() {
    cin &amp;gt;&amp;gt; vall &amp;gt;&amp;gt; n;
 	init();
    for (int i = 1; i &amp;lt;= n; ++i) {
        int a, b, c, cnt = 0;
        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
        // äºŒè¿›åˆ¶æŠŠå¤šé‡èƒŒåŒ…æ‹†æˆ0-1èƒŒåŒ…
        while (c) {
            if (c &amp;gt; bit[cnt]) {
                v[ind] = a * bit[cnt];
                w[ind] = b * bit[cnt];
                c -= bit[cnt];
                cnt++;
            } else {
                v[ind] = a * c;
                w[ind] = b * c;
                c = 0;
            }
            ind++;
        }
    }
    for (int i = 1; i &amp;lt;= ind; ++i) {
        for (int j = vall; j &amp;gt;= v[i]; j--) {
            dp[j] = max(dp[j], dp[j-v[i]] + w[i]);
        }
    }
    cout &amp;lt;&amp;lt; dp[vall] &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5äºŒåˆ†ç®—æ³•&#34;&gt;5.äºŒåˆ†ç®—æ³•&lt;/h4&gt;
&lt;h5 id=&#34;51-åŸæœ¨åˆ‡å‰²&#34;&gt;5.1 åŸæœ¨åˆ‡å‰²&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const int maxn = 1e8 + 10;
int N[maxn], n, m, rr;
int check(int x) {
    int t = 0;
    for (int i = 0; i &amp;lt; n; ++i) {
        if (N[i] &amp;gt;= x) t += N[i] / x;
    }
    return t;
}
int binarySearch() {
    int l = 1, r = rr;
    while (l != r) {
        int mid = l + (r - l + 1) / 2;
        if (check(mid) &amp;gt;= m) l = mid;
        else r = mid - 1;
    }
    return r;
}
int main() {
    scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;n, &amp;amp;m);
    for (int i = 0; i &amp;lt; n; ++i) {
        scanf(&amp;quot;%d&amp;quot;, N + i);
        rr = max(rr, N[i]);
    }
    printf(&amp;quot;%d\n&amp;quot;, binarySearch());
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;52-åˆ‡ç»³å­&#34;&gt;5.2 åˆ‡ç»³å­&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const int maxn = 1e5 + 10;
double N[maxn], rr;
int n, k;
int check(double x) {
    int t = 0;
    for (int i = 0; i &amp;lt; n; ++i) {
        t += N[i] / x;
    }
    return t;
}
double binarySearch() {
    double l = 0, r = rr;
    // å°æ•°äºŒåˆ†ä¸èƒ½ +1ï¼Œ-1æ“ä½œï¼Œå½±å“å¾ˆå¤§
    while (abs(r - l) &amp;gt; 0.00005) { // å°æ•°äºŒåˆ†ï¼Œå³-å·¦ å¤§äº é¢„è®¾ç²¾åº¦
        double mid = l + (r - l) / 2;
        if (check(mid) &amp;gt;= k) l = mid;
        else r = mid;
    }
    return l;
}
int main() {
    scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;n, &amp;amp;k);
    for (int i = 0; i &amp;lt; n; ++i) {
        scanf(&amp;quot;%lf&amp;quot;, N + i);
        rr = max(rr, N[i]);
    }
    printf(&amp;quot;%.2lf\n&amp;quot;, binarySearch() - 0.005); // ç²¾åº¦
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;53-æ•°ç»„åˆ†æ®µ&#34;&gt;5.3 æ•°ç»„åˆ†æ®µ&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const long long maxn = 1e5 + 10;
long long N[maxn], n, m, l, r;
// åˆ†æ®µåæ¯æ®µçš„å€¼ï¼Œéƒ½å°äºç­‰äº x
long long check(long long x) {
    long long ans = 0, t = 0;
    for (int i = 0; i &amp;lt; n; ++i) {
        if (t + N[i] &amp;lt;= x) { t += N[i]; } // å°äºç­‰äºxï¼Œå¯ä»¥ä¸åˆ†æ®µ
        else { ans++; t = N[i]; } // t + N[i] &amp;gt; x,å¿…é¡»åˆ†æ®µï¼Œå¹¶ä¸”t = N[i] 
    }
    ans++; // æœ€åè‚¯å®šæœ‰ä¸€æ®µ
    return ans;
}
long long binarySearch() {
    while (l != r) {
        long long mid = l + (r - l) / 2;
        if (check(mid) &amp;lt;= m) r = mid; 
        else l = mid + 1;
    }
    return l;
}
int main() {
    scanf(&amp;quot;%lld %lld&amp;quot;, &amp;amp;n, &amp;amp;m);
    for (int i = 0; i &amp;lt; n; ++i) {
        scanf(&amp;quot;%lld&amp;quot;, &amp;amp;N[i]);
        l = max(l, N[i]);
        r += N[i];
    }
    printf(&amp;quot;%lld\n&amp;quot;, binarySearch());
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;6å›¾è®º&#34;&gt;6.å›¾è®º&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;using namespace std;
struct edge {
    int e, v;
};
struct node {
    int cur, dis; // cur:å½“å‰ç‚¹ï¼Œ dis: åˆ°å½“å‰ç‚¹èµ°è¿‡çš„æœ€çŸ­è·¯å¾„
    // å°é¡¶å †ï¼Œ é‡è½½å°äºå·è¿ç®—ç¬¦
    bool operator&amp;lt;(const node &amp;amp;b) const {
        return this-&amp;gt;dis &amp;gt; b.dis;
    }
};
int n, m, s, ans[100005]; // ç­”æ¡ˆæ•°ç»„å­˜ï¼Œèµ·å§‹ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„
int main() {
    scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;s);
    vector&amp;lt;vector&amp;lt;edge&amp;gt; &amp;gt; edg(n + 5, vector&amp;lt;edge&amp;gt;());
    // ç­”æ¡ˆæ•°ç»„ï¼Œ åˆå§‹åŒ–ä¸ºæœ€å¤§å€¼
    memset(ans, 0x3f, sizeof(ans));
    // é‚»æ¥è¡¨å­˜å›¾
    for (int i = 0; i &amp;lt; m; ++i) {
        int a, b, c;
        scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
        // åŒå‘è¾¹
        edg[a].emplace_back((edge){b, c}); 
        edg[b].emplace_back((edge){a, c});
    }
    priority_queue&amp;lt;node&amp;gt; que; // å°å †é¡¶
    que.emplace((node){s, 0}); // æŠŠåˆå§‹ç‚¹ æ”¾å…¥å°é¡¶å †ï¼Œ è·ç¦»ä¸º0
    ans[s] = 0; // åˆ°sçš„ è·ç¦»ä¸º0
    // æ¯æ¬¡æŠŠè·¯å¾„æœ€çŸ­çš„ ç‚¹å¼¹å‡º
    while (!que.empty()) {
        node t = que.top(); que.pop();
        // å¦‚æœå½“å‰åœ¨ç­”æ¡ˆæ•°ç»„å·²æœ‰ï¼Œ å¹¶ä¸”åˆ°å½“å‰ç‚¹çš„è·ç¦»å¤§äºä¹‹å‰çš„ï¼Œé‚£ä¹ˆä¸æ›´æ–°ï¼Œä¸‹ä¸€ä¸ª
        if (ans[t.cur] &amp;lt; t.dis) continue; 
        // æŠŠå½“å‰ç‚¹ï¼ˆæœ€å°è·¯å¾„çš„ç‚¹ï¼‰ï¼Œéå†ä¸€éå®ƒè¿æ¥çš„ç‚¹
        for (int i = 0; i &amp;lt; edg[t.cur].size(); ++i) {
            int e = edg[t.cur][i].e, v = edg[t.cur][i].v;
            // å¦‚æœç­”æ¡ˆæ•°ç»„é‡Œé¢çš„ç‚¹ å¤§äº è¯¥ç‚¹çš„è·¯å¾„ï¼ˆå½“å‰ç‚¹çš„è·ç¦» + å½“å‰ç‚¹å’Œè¿æ¥ç‚¹çš„è¾¹æƒå€¼ï¼‰
            if (ans[e] &amp;gt; t.dis + v) {
                ans[e] = t.dis + v;
                que.emplace((node){e, t.dis + v}); // æ”¾åˆ°å°é¡¶å †
            }
        }
    }
    // éå†ç­”æ¡ˆæ•°ç»„çš„æ¯ä¸ªç‚¹
    for (int i = 1; i &amp;lt;= n; ++i) {
        if (ans[i] == 0x3f3f3f3f) printf(&amp;quot;-1\n&amp;quot;);
        else printf(&amp;quot;%d\n&amp;quot;, ans[i]);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">åŸºç¡€ç®—æ³•æ¡†æ¶</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/åˆ·é¢˜é›†/"" data-c="
          &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&#34;åˆ·é¢˜é›†&#34;&gt;åˆ·é¢˜é›†&lt;/h3&gt;
&lt;h4 id=&#34;1ç»¼åˆæœç´¢&#34;&gt;1.ç»¼åˆæœç´¢&lt;/h4&gt;
&lt;h5 id=&#34;leetcode-417å¤ªå¹³æ´‹å¤§è¥¿æ´‹æ°´æµé—®é¢˜&#34;&gt;leetcode-417ï¼ˆå¤ªå¹³æ´‹å¤§è¥¿æ´‹æ°´æµé—®é¢˜ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/*
æœç´¢ä¸“é¢˜ï¼ˆåˆ¤æ–­è¿é€šæ€§ï¼‰
1. å­˜åœ°å›¾ ï¼ˆå¤–æ¡†ç•™0ï¼Œä»[1, 1]ç‚¹å¼€å§‹å­˜ï¼Œä¸ç”¨åˆ¤æ–­è¾¹ç•Œï¼‰
2.æ–¹å‘æ•°ç»„ï¼Œç”¨æ–¹å‘æ•°ç»„å»éå†
3.å»é‡ï¼šæ–¹æ³•1ï¼šåœ°å›¾æœç´¢å®Œå°±ä¸ç”¨äº†ï¼Œå¯ä»¥ç›´æ¥æ”¹åœ°å›¾ æ–¹æ³•2ï¼šç”¨markæ•°ç»„åšæ ‡è®°
*/

// äº”å­—è¯€
/*
å­˜ï¼šçŠ¶æ€æ˜¯å¦‚ä½•å­˜å‚¨çš„ ï¼ˆç»“æ„å®šä¹‰ï¼‰
èµ·ï¼šèµ·å§‹çŠ¶æ€
ç»ˆï¼šç»ˆæ­¢çŠ¶æ€
è½¬ï¼šçŠ¶æ€å¦‚ä½•è½¬ç§»çš„ ï¼ˆå€ŸåŠ©æ–¹å‘æ•°ç»„ï¼‰
é‡ï¼šå¦‚ä½•å»é‡ ï¼ˆå€ŸåŠ©æ ‡è®°æ•°ç»„ï¼‰
*/
    
class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; pacificAtlantic(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; heights) {
        typedef pair&amp;lt;int, int&amp;gt; PII;
        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; ans;
        if (heights.size() == 0) return ans;
        int m = heights.size(), n = heights[0].size(), mark[155][155] = {0};
        int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
        queue&amp;lt;PII&amp;gt; que;
        for (int i = 0; i &amp;lt; m; ++i) {
            que.emplace(i, 0);
            mark[i][0] = 1;
        }
        for (int i = 1; i &amp;lt; n; ++i) {
            que.emplace(0, i);
            mark[0][i] = 1;
        }
        while (!que.empty()) {
            auto t = que.front(); que.pop();
            for (int i = 0; i &amp;lt; 4; ++i) {
                int nx = t.first + dir[i][0];
                int ny = t.second + dir[i][1];
                if (nx &amp;lt; 0 || ny &amp;lt; 0 || nx &amp;gt; m - 1 || ny &amp;gt; n - 1 ||
                mark[nx][ny] || heights[nx][ny] &amp;lt; heights[t.first][t.second]) {
                    continue;
                }
                mark[nx][ny] = 1;
                que.emplace(nx, ny);
            }
        }
        for (int i = 0; i &amp;lt; m; ++i) {
            que.emplace(i, n - 1);
            mark[i][n-1] += 2;
        }
        for (int i = 0; i &amp;lt; n - 1; ++i) {
            que.emplace(m - 1, i);
            mark[m-1][i] += 2;
        }
        while (!que.empty()) {
            auto t = que.front(); que.pop();
            if (mark[t.first][t.second] == 3) {
                ans.push_back((vector&amp;lt;int&amp;gt;){t.first, t.second});
            }
            for (int i = 0; i &amp;lt; 4; ++i) {
                int nx = t.first + dir[i][0];
                int ny = t.second + dir[i][1];
                if (nx &amp;lt; 0 || ny &amp;lt; 0 || nx &amp;gt; m - 1 || ny &amp;gt; n - 1 ||
                (mark[nx][ny] &amp;amp; 2) || heights[nx][ny] &amp;lt; heights[t.first][t.second]) {
                    continue;
                }
                mark[nx][ny] += 2;
                que.emplace(nx, ny);
            }
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;leleetcode-127å•è¯æ¥é¾™&#34;&gt;leleetcode-127ï¼ˆå•è¯æ¥é¾™ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    struct node {
        int cnt;
        string s;
    };
    unordered_map&amp;lt;string, int&amp;gt; hash;
    int ladderLength(string beginWord, string endWord, vector&amp;lt;string&amp;gt;&amp;amp; wordList) {
        for (auto it : wordList) hash[it] = 1;
        if (hash[endWord] == 0) return 0;
        queue&amp;lt;node&amp;gt; que;
        que.push((node){1, beginWord});
        if (hash[beginWord] == 1) hash[beginWord] = 0;
        while (!que.empty()) {
            node t = que.front(); que.pop();
            if (t.s == endWord) return t.cnt;
            for (int i = 0; i &amp;lt; beginWord.size(); ++i) {
                string str = t.s;
                char ch = str[i];
                for (char j = &#39;a&#39;; j &amp;lt;= &#39;z&#39;; ++j) {  // æš´åŠ›æšä¸¾26ä¸ªå­—æ¯
                    if (j != ch) str[i] = j;
                    if (hash[str] == 1) {
                        hash[str] = 0;
                        que.push((node){t.cnt + 1, str});
                    }
                }
            }
        }
        return 0;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;leleetcode-130è¢«å›´ç»•çš„åŒºåŸŸ&#34;&gt;leleetcode-130ï¼ˆè¢«å›´ç»•çš„åŒºåŸŸï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// å¹¿æœ
class Solution {
public:
    struct node {
        int x, y;
    };
    int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
    void solve(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) {
        int m = board.size(), n = board[0].size();
        queue&amp;lt;node&amp;gt; que;
        for (int i = 0; i &amp;lt; m; ++i) {
            if (board[i][0] == &#39;O&#39;) {
                board[i][0] = &#39;A&#39;;
                que.push((node){i, 0});
            }
            if (board[i][n-1] == &#39;O&#39;) {
                board[i][n-1] = &#39;A&#39;;
                que.push((node){i, n-1});
            }
        }
        for (int i = 1; i &amp;lt; n - 1; ++i) {
            if (board[0][i] == &#39;O&#39;) {
                board[0][i] = &#39;A&#39;;
                que.push((node){0, i});
            }
            if (board[m-1][i] == &#39;O&#39;) {
                board[m-1][i] = &#39;A&#39;;
                que.push((node){m-1, i});
            }
        }
        while (!que.empty()) {
            node t = que.front(); que.pop();
            for (int i = 0; i &amp;lt; 4; ++i) {
                int nx = t.x + dir[i][0];
                int ny = t.y + dir[i][1];
                if (nx &amp;lt; 0 || ny &amp;lt; 0 || nx &amp;gt; m - 1 || ny &amp;gt; n - 1) continue;
                if (board[nx][ny] == &#39;O&#39;) {
                    board[nx][ny] = &#39;A&#39;;
                    que.push((node){nx, ny});
                }
            }
        }
        for (int i = 0; i &amp;lt; m; ++i) {
            for (int j = 0; j &amp;lt; n; ++j) {
                if (board[i][j] == &#39;A&#39;) board[i][j] = &#39;O&#39;;
                else if (board[i][j] == &#39;O&#39;) board[i][j] = &#39;X&#39;;
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;leleetcode-200å²›å±¿æ•°é‡&#34;&gt;leleetcode-200ï¼ˆå²›å±¿æ•°é‡ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// å¹¿æœ
class Solution {
public:
    struct node {
        int x, y;
    };
    int m, n, ans = 0, dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};

    void bfs(vector&amp;lt;vector&amp;lt;char&amp;gt; &amp;gt; &amp;amp;grid, int x, int y) {
        queue&amp;lt;node&amp;gt; que;
        que.push((node){x, y});
        while (!que.empty()) {
            node t = que.front(); que.pop();
            for (int i = 0; i &amp;lt; 4; ++i) {
                int nx = t.x + dir[i][0];
                int ny = t.y + dir[i][1];
                if (nx &amp;lt; 0 || ny &amp;lt; 0 || nx &amp;gt; m - 1 || ny &amp;gt; n - 1) continue;
                if (grid[nx][ny] == &#39;1&#39;) {
                    grid[nx][ny] = &#39;2&#39;;
                    que.push((node){nx, ny});
                }
            } 
        }
        return ;
    }

    int numIslands(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid) {
        m = grid.size(), n = grid[0].size();
        for (int i = 0; i &amp;lt; m; ++i) {
            for (int j = 0; j &amp;lt; n; ++j) {
                if (grid[i][j] == &#39;1&#39;) {
                    ans++;
                    grid[i][j] = &#39;2&#39;;
                    bfs(grid, i, j);
                }
            }
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;leleetcode-529æ‰«é›·æ¸¸æˆ&#34;&gt;leleetcode-529ï¼ˆæ‰«é›·æ¸¸æˆï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    struct node {
        int x, y;
    };
    int dir[8][2] = {0, 1, 1, 0, 0, -1, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1};
    int m, n;
    int dfs(vector&amp;lt;vector&amp;lt;char&amp;gt; &amp;gt; &amp;amp;smap, node t) {
        // ç‰¹åˆ¤é™„è¿‘æ˜¯å¦æœ‰ç‚¸å¼¹ï¼Œæœ‰å¤šå°‘ç‚¸å¼¹
        int cnt = 0;
        for (int i = 0; i &amp;lt; 8; ++i) {
            int nx = t.x + dir[i][0];
            int ny = t.y + dir[i][1];
            if (nx &amp;lt; 0 || ny &amp;lt; 0 || nx &amp;gt; m - 1 || ny &amp;gt; n - 1) continue;
            if (smap[nx][ny] == &#39;M&#39;) {
                cnt++;
            }
        }
        return cnt;
    }
    vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; updateBoard(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, vector&amp;lt;int&amp;gt;&amp;amp; click) {
        m = board.size(), n = board[0].size();
        if (board[click[0]][click[1]] == &#39;M&#39;) {
            board[click[0]][click[1]] = &#39;X&#39;;
            return board;
        }
        queue&amp;lt;node&amp;gt; que;
        que.push((node){click[0], click[1]});
        board[click[0]][click[1]] = &#39;B&#39;;
        while (!que.empty()) {
            node t = que.front(); que.pop();
            int cnt = dfs(board, t); // ç‰¹åˆ¤ï¼ˆæ˜¯å¦é™„è¿‘æœ‰ç‚¸å¼¹ï¼‰
            if (cnt) { // æœ‰ç‚¸å¼¹
                board[t.x][t.y] = (char)(cnt + &#39;0&#39;);
                continue;
            }
            // é™„è¿‘æ²¡æœ‰ç‚¸å¼¹çš„æƒ…å†µ
            for (int i = 0; i &amp;lt; 8; ++i) {
                int nx = t.x + dir[i][0];
                int ny = t.y + dir[i][1];
                if (nx &amp;lt; 0 || ny &amp;lt; 0 || nx &amp;gt; m - 1 || ny &amp;gt; n - 1) continue;
                if (board[nx][ny] == &#39;E&#39;) {
                    board[nx][ny] = &#39;B&#39;;
                    que.push((node){nx, ny});
                }
            }
        }
        return board;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;leleetcode-752æ‰“å¼€è½¬ç›˜é”&#34;&gt;leleetcode-752ï¼ˆæ‰“å¼€è½¬ç›˜é”ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    struct node {
        int cnt;
        string s;
    };
    unordered_map&amp;lt;string, int&amp;gt; hash; // å»é‡
    int openLock(vector&amp;lt;string&amp;gt;&amp;amp; deadends, string target) {
        for (auto it : deadends) hash[it] = 1;
        if (target == &amp;quot;0000&amp;quot;) return 0;
        if (hash[&amp;quot;0000&amp;quot;] == 1) return -1;
        if (hash[target] == 1) return -1;
        queue&amp;lt;node&amp;gt; que;
        que.push((node){0, &amp;quot;0000&amp;quot;});
        hash[&amp;quot;0000&amp;quot;] = 1;
        while (!que.empty()) {
            node t = que.front(); que.pop();
            if (t.s == target) return t.cnt;
            for (int i = 0; i &amp;lt; 4; ++i) {
                // æ¯ä¸ªæ•°å­—å‘ä¸Šæ‹¨ï¼ˆæ¯è½®4æ¬¡ï¼‰
                string str1 = t.s;
                str1[i]++;
                if (str1[i] &amp;gt; &#39;9&#39;) str1[i] = &#39;0&#39;; 
                if (hash[str1] == 0) {
                    hash[str1] = 1; // å»é‡
                    que.push((node){t.cnt + 1, str1});
                }
                // æ¯ä¸ªæ•°å­—å‘ä¸‹æ‹¨ï¼ˆæ¯è½®4æ¬¡ï¼‰
                string str2 = t.s;
                str2[i]--;
                if (str2[i] &amp;lt; &#39;0&#39;) str2[i] = &#39;9&#39;;
                if (hash[str2] == 0) {
                    hash[str2] = 1;
                    que.push((node){t.cnt + 1, str2});
                }
                
            }
        }
        return -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;leleetcode-934æœ€çŸ­çš„æ¡¥&#34;&gt;leleetcode-934ï¼ˆæœ€çŸ­çš„æ¡¥ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    struct node {
        int x, y, cnt;
    };
    int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
    int m, n;
    queue&amp;lt;node&amp;gt; que;
    void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;nmap, int x, int y) {
        for (int i = 0; i &amp;lt; 4; ++i) {
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            if (nx &amp;lt; 0 || ny &amp;lt; 0 || nx &amp;gt; m - 1 || ny &amp;gt; n - 1) continue;
            if (nmap[nx][ny] == 1) {
                nmap[nx][ny] = 2;
                que.push((node){nx, ny, 0});
                dfs(nmap, nx, ny);
            }
        }
        return ;
    }
    int shortestBridge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) {
        m = grid.size(), n = grid[0].size();
        for (int i = 0; i &amp;lt; m; ++i) {
            for (int j = 0; j &amp;lt; n; ++j) {
                if (grid[i][j] == 1) { // æŠŠç¬¬ä¸€æ³¢1æ”¾å…¥é˜Ÿåˆ—
                    grid[i][j] = 2;
                    que.push((node){i, j, 0});
                    dfs(grid, i, j);
                    break;
                }
            }
            if (!que.empty()) break;
        }
        // å¹¿æœç¬¬äºŒæ³¢1
        while (!que.empty()) {
            node t = que.front(); que.pop();
            for (int i = 0; i &amp;lt; 4; ++i) {
                int nx = t.x + dir[i][0];
                int ny = t.y + dir[i][1];
                if (nx &amp;lt; 0 || ny &amp;lt; 0 || nx &amp;gt; m - 1 || ny &amp;gt; n - 1 || grid[nx][ny] == 2) {
                    continue;
                } 
                if (grid[nx][ny] == 1) return t.cnt;
                if (grid[nx][ny] == 0) {
                    grid[nx][ny] = 2;
                    que.push((node){nx, ny, t.cnt + 1});
                }
            }
        }
        return 1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;leleetcode-967è¿ç»­å·®ç›¸åŒçš„æ•°å­—&#34;&gt;leleetcode-967ï¼ˆè¿ç»­å·®ç›¸åŒçš„æ•°å­—ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; ans;

    void dfs(int num, int left, int k) {
        if (left == 0) { // é€‰å¤Ÿæ•°å­—äº†
            ans.push_back(num);
            return ;
        }
        if (num % 10 + k &amp;lt; 10) { // æœ€åä¸€ä¸ªæ•°å­—+k
            dfs(num * 10 + num % 10 + k, left - 1, k);
        } 
        if (k &amp;amp;&amp;amp; num % 10 - k &amp;gt;= 0) { // æœ€åä¸€ä¸ªæ•°å­—-k
            dfs(num * 10 + num % 10 - k, left - 1, k);
        }
    } 

    vector&amp;lt;int&amp;gt; numsSameConsecDiff(int n, int k) {
        for (int i = 1; i &amp;lt; 10; ++i) { // éå†äºŒå‰æ ‘
            dfs(i, n - 1, k);
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;leleetcode-994è…çƒ‚çš„æ©˜å­&#34;&gt;leleetcode-994ï¼ˆè…çƒ‚çš„æ©˜å­ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    struct node {
        int x, y, cnt;
    };
    int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
    int orangesRotting(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) {
        int m = grid.size(), n = grid[0].size(), ans = 0;
        queue&amp;lt;node&amp;gt; que;
        for (int i = 0; i &amp;lt; m; ++i) {
            for (int j = 0; j &amp;lt; n; ++j) {
                if (grid[i][j] == 2) {
                    que.push((node){i, j, 0});
                }
            }
        }
        while (!que.empty()) {
            node t = que.front(); que.pop();
            ans = t.cnt;
            for (int i = 0; i &amp;lt; 4; ++i) {
                int nx = t.x + dir[i][0];
                int ny = t.y + dir[i][1];
                if (nx &amp;lt; 0 || ny &amp;lt; 0 || nx &amp;gt; m - 1 || ny &amp;gt; n - 1) continue;
                if (grid[nx][ny] == 1) {
                    grid[nx][ny] = 2;
                    que.push((node){nx, ny, t.cnt + 1});
                }
            }
        }
        for (int i = 0; i &amp;lt; m; ++i) {
            for (int j = 0; j &amp;lt; n; ++j) {
                if (grid[i][j] == 1) {
                    return -1;
                }
            }
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;leleetcode-1091äºŒè¿›åˆ¶çŸ©é˜µä¸­çš„æœ€çŸ­è·¯å¾„&#34;&gt;leleetcode-1091ï¼ˆäºŒè¿›åˆ¶çŸ©é˜µä¸­çš„æœ€çŸ­è·¯å¾„ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    struct node {
        int x, y, cnt;
    };
    int dir[8][2] = {0, 1, 1, 0, 0, -1, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1};
    int shortestPathBinaryMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) {
        if (grid[0][0] == 1) return -1;
        int n = grid.size();
        queue&amp;lt;node&amp;gt; que;
        que.push((node){0, 0, 1});
        grid[0][0] = 2;
        while (!que.empty()) {
            node t = que.front(); que.pop();
            if (t.x == n - 1 &amp;amp;&amp;amp; t.y == n - 1) {
                return t.cnt;
            }
            for (int i = 0; i &amp;lt; 8; ++i) {
                int nx = t.x + dir[i][0];
                int ny = t.y + dir[i][1];
                if (nx &amp;lt; 0 || ny &amp;lt; 0 || nx &amp;gt; n - 1 || ny &amp;gt; n - 1) continue;
                if (grid[nx][ny] == 0) {
                    grid[nx][ny] = 2;
                    que.push((node){nx, ny, t.cnt + 1});
                }
            }
        }
        return -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;leleetcode-1162åœ°å›¾åˆ†æ&#34;&gt;leleetcode-1162ï¼ˆåœ°å›¾åˆ†æï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    struct node {
        int x, y, cnt;
    };
    int n, dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
    int bfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;grid, int x, int y) {
        int mark[105][105] = {0};
        mark[x][y] = 1;
        queue&amp;lt;node&amp;gt; que;
        que.push((node){x, y, 0});
        while(!que.empty()) {
            node t = que.front(); que.pop();
            for (int i = 0; i &amp;lt; 4; ++i) {
                int nx = t.x + dir[i][0];
                int ny = t.y + dir[i][1];
                if (nx &amp;lt; 0 || ny &amp;lt; 0 || nx &amp;gt; n - 1 || ny &amp;gt; n - 1 || mark[nx][ny]) continue;
                if (grid[nx][ny] == 1) return t.cnt + 1;
                if (grid[nx][ny] == 0) {
                    mark[nx][ny] = 1;
                    que.push((node){nx, ny, t.cnt + 1});
                }
            }
        }
        return 0;
    }

    int maxDistance(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) {
        n = grid.size();
        int ans = 0;
        for (int i = 0; i &amp;lt; n; ++i) {
            for (int j = 0; j &amp;lt; n; ++j) {
                if (grid[i][j] == 0) {
                    ans = max(ans, bfs(grid, i, j));
                }
            }
        }
        return ans ? ans : -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;oj40501è¿·å®«&#34;&gt;OJ.405ï¼ˆ01è¿·å®«ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/*
æœç´¢ä¸“é¢˜ï¼ˆåˆ¤æ–­è¿é€šæ€§ï¼‰
1. å­˜åœ°å›¾ ï¼ˆå¤–æ¡†ç•™0ï¼Œä»[1, 1]ç‚¹å¼€å§‹å­˜ï¼Œä¸ç”¨åˆ¤æ–­è¾¹ç•Œï¼‰
2.æ–¹å‘æ•°ç»„ï¼Œç”¨æ–¹å‘æ•°ç»„å»éå†
3.å»é‡ï¼šæ–¹æ³•1ï¼šåœ°å›¾æœç´¢å®Œå°±ä¸ç”¨äº†ï¼Œå¯ä»¥ç›´æ¥æ”¹åœ°å›¾ æ–¹æ³•2ï¼šç”¨markæ•°ç»„åšæ ‡è®°
*/
// å¹¿æœ
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;
typedef pair&amp;lt;int, int&amp;gt; PII;
int n, nmap[35][35];
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
int main() {
    cin &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; ++i) {
        for (int j = 1; j &amp;lt;= n; ++j) {
            cin &amp;gt;&amp;gt; nmap[i][j];
        }
    }
    queue&amp;lt;PII&amp;gt; que;
    que.emplace(0, 0);
    nmap[0][0] = 3;
    while (!que.empty()) {
        auto t = que.front();
        que.pop();
        for (int i = 0; i &amp;lt; 4; ++i) {
            int nx = t.first + dir[i][0];
            int ny = t.second + dir[i][1];
            if (nx &amp;lt; 0 || ny &amp;lt; 0 || nx &amp;gt; n + 1 || ny &amp;gt; n + 1) continue;
            if (nmap[nx][ny] == 0) {
                nmap[nx][ny] = 3;
                que.emplace(nx, ny);
            }
        }
    }
    for (int i = 1; i &amp;lt;= n; ++i) {
        for (int j = 1; j &amp;lt;= n; ++j) {
            j != 1 &amp;amp;&amp;amp; cout &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            if (nmap[i][j] == 1) cout &amp;lt;&amp;lt; 1;
            else if (nmap[i][j] == 3) cout &amp;lt;&amp;lt; 0;
            else if (nmap[i][j] == 0) cout &amp;lt;&amp;lt; 2;
        }
        cout &amp;lt;&amp;lt; endl;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;oj396å¡«æ¶‚é¢œè‰²&#34;&gt;OJ.396ï¼ˆå¡«æ¶‚é¢œè‰²ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// æ·±æœ
#include &amp;lt;iostream&amp;gt;
using namespace std;
int n, nmap[35][35];
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
void dfs(int x, int y) {
    for (int i = 0; i &amp;lt; 4; ++i) {
        int nx = x + dir[i][0];
        int ny = y + dir[i][1];
        if (nx &amp;lt; 0 || ny &amp;lt; 0 || nx &amp;gt; n + 1 || ny &amp;gt; n + 1) continue;
        if (nmap[nx][ny] == 0) {
            nmap[nx][ny] = 3;
            dfs(nx, ny);
        } 
    }
    return ;
}
int main() {
    cin &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; ++i) {
        for (int j = 1; j &amp;lt;= n; ++j) {
            cin &amp;gt;&amp;gt; nmap[i][j];
        }
    }
    dfs(0, 0);
    for (int i = 1; i &amp;lt;= n; ++i) {
        for (int j = 1; j &amp;lt;= n; ++j) {
            j != 1 &amp;amp;&amp;amp; cout &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            if (nmap[i][j] == 1) cout &amp;lt;&amp;lt; 1;
            else if (nmap[i][j] == 3) cout &amp;lt;&amp;lt; 0;
            else if (nmap[i][j] == 0) cout &amp;lt;&amp;lt; 2;
        }
        cout &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;oj305ä¹³è‰çš„å…¥ä¾µ&#34;&gt;OJ.305ï¼ˆä¹³è‰çš„å…¥ä¾µï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/*
æœç´¢ä¸“é¢˜ï¼ˆåˆ¤æ–­è¿é€šæ€§ï¼‰
1. å­˜åœ°å›¾ ï¼ˆå¤–æ¡†ç•™0ï¼Œä»[1, 1]ç‚¹å¼€å§‹å­˜ï¼Œä¸ç”¨åˆ¤æ–­è¾¹ç•Œï¼‰
2.æ–¹å‘æ•°ç»„ï¼Œç”¨æ–¹å‘æ•°ç»„å»éå†
3.å»é‡ï¼šæ–¹æ³•1ï¼šåœ°å›¾æœç´¢å®Œå°±ä¸ç”¨äº†ï¼Œå¯ä»¥ç›´æ¥æ”¹åœ°å›¾ æ–¹æ³•2ï¼šç”¨markæ•°ç»„åšæ ‡è®°
*/
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

int n, m, ans[1005][1005];
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
char nmap[1005][1005];

struct node {
    int x, y, step;
};

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    queue&amp;lt;node&amp;gt; que;
    for (int i = 1; i &amp;lt;= n; ++i) {
        for (int j = 1; j &amp;lt;= m; ++j) {
            cin &amp;gt;&amp;gt; nmap[i][j];
            if (nmap[i][j] == &#39;1&#39;) {
                que.push((node){i, j, 0});
                ans[i][j] = -1;
            }
        }
    }
    while (!que.empty()) {
        node t = que.front(); que.pop();
        for (int i = 0; i &amp;lt; 4; ++i) {
            int nx = t.x + dir[i][0];
            int ny = t.y + dir[i][1];
            if (nx &amp;lt; 1 || ny &amp;lt; 1 || nx &amp;gt; n || ny &amp;gt; m || ans[nx][ny]) continue;
            ans[nx][ny] = t.step + 1;
            que.push((node){nx, ny, ans[nx][ny]});
        }
    }
    for (int i = 1; i &amp;lt;= n; ++i) {
        for (int j = 1; j &amp;lt;= m; ++j) {
            j != 1 &amp;amp;&amp;amp; cout &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            if (ans[i][j] == -1) cout &amp;lt;&amp;lt; 0;
            else cout &amp;lt;&amp;lt; ans[i][j];
        }
        cout &amp;lt;&amp;lt; endl;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;oj81å°æ˜å›å®¶&#34;&gt;OJ.81ï¼ˆå°æ˜å›å®¶ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/*
æœç´¢ä¸“é¢˜ï¼ˆåˆ¤æ–­è¿é€šæ€§ï¼‰
1. å­˜åœ°å›¾ ï¼ˆå¤–æ¡†ç•™0ï¼Œä»[1, 1]ç‚¹å¼€å§‹å­˜ï¼Œä¸ç”¨åˆ¤æ–­è¾¹ç•Œï¼‰
2.æ–¹å‘æ•°ç»„ï¼Œç”¨æ–¹å‘æ•°ç»„å»éå†
3.å»é‡ï¼šæ–¹æ³•1ï¼šåœ°å›¾æœç´¢å®Œå°±ä¸ç”¨äº†ï¼Œå¯ä»¥ç›´æ¥æ”¹åœ°å›¾ æ–¹æ³•2ï¼šç”¨markæ•°ç»„åšæ ‡è®°
*/

// äº”å­—è¯€
/*
å­˜ï¼šçŠ¶æ€æ˜¯å¦‚ä½•å­˜å‚¨çš„ ï¼ˆç»“æ„å®šä¹‰ï¼‰ï¼ˆx, y, step, flagï¼‰
èµ·ï¼šèµ·å§‹çŠ¶æ€ (sx, sy, 0, 0)
ç»ˆï¼šç»ˆæ­¢çŠ¶æ€ (ex, ey, ?, 1)
è½¬ï¼šçŠ¶æ€å¦‚ä½•è½¬ç§»çš„ ï¼ˆå€ŸåŠ©æ–¹å‘æ•°ç»„ï¼‰
é‡ï¼šå¦‚ä½•å»é‡ ï¼ˆå€ŸåŠ©æ ‡è®°æ•°ç»„ï¼‰(mark[][],)
*/
    

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

// å­˜
struct node {
    int x, y, step, flag; // æ ‡è®°flag: 0 è¡¨ç¤º æ²¡æœ‰æ‰‹æœºï¼Œ 1è¡¨ç¤ºæœ‰æ‰‹æœº
};

// markæ•°ç»„ï¼š 1ä»£è¡¨æ²¡æœ‰æ‰‹æœºèµ°è¿‡ï¼Œ 2 ä»£è¡¨æœ‰æ‰‹æœºèµ°è¿‡ï¼Œ 3 ä»£è¡¨æ²¡æœ‰å’Œæœ‰æ‰‹æœºéƒ½èµ°è¿‡
int n, m, sx, sy, mark[2005][2005];
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
char smap[2005][2005];

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 1; i &amp;lt;= n; ++i) {
        for (int j = 1; j &amp;lt;= m; ++j) {
            cin &amp;gt;&amp;gt; smap[i][j];
            if (smap[i][j] == &#39;S&#39;) {
                sx = i, sy = j;
            }
        }
    }
    queue&amp;lt;node&amp;gt; que;
    que.push((node){sx, sy, 0, 0}); // èµ·
    mark[sx][sy] = 1;
    while (!que.empty()) {
        node t = que.front(); que.pop();
        for (int i = 0; i &amp;lt; 4; ++i) {
            int nx = t.x + dir[i][0];
            int ny = t.y + dir[i][1];
            if (smap[nx][ny] == &#39;T&#39; &amp;amp;&amp;amp; t.flag) { // ç»ˆ
                cout &amp;lt;&amp;lt; t.step + 1 &amp;lt;&amp;lt; endl;
                return 0;
            }
            if (t.flag == 0 &amp;amp;&amp;amp; (mark[nx][ny] &amp;amp; 1)) continue; // æ²¡æœ‰æ‰‹æœºèµ°è¿‡äº†
            if (t.flag &amp;amp;&amp;amp; (mark[nx][ny] &amp;amp; 2)) continue; // æœ‰æ‰‹æœºèµ°è¿‡äº†
            if (smap[nx][ny] == &#39;S&#39; || smap[nx][ny] == &#39;T&#39; || smap[nx][ny] == &#39;.&#39;) {
                mark[nx][ny] += t.flag + 1; // ä¸¤ç§æƒ…å†µçš„å»é‡
                que.push((node){nx, ny, t.step + 1, t.flag}); // è½¬
            }
            if (smap[nx][ny] == &#39;P&#39;) { 
                mark[nx][ny] = 3; // æ²¡æœ‰æ‰‹æœºå’Œæœ‰æ‰‹æœºéƒ½èµ°è¿‡çš„æƒ…å†µ
                que.push((node){nx, ny, t.step + 1, 1}); // è½¬ï¼ˆæœ‰æ‰‹æœºäº†ï¼‰
            }
        }
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;oj303çŸ©é˜µè·ç¦»ä¸€&#34;&gt;OJ.303ï¼ˆçŸ©é˜µè·ç¦»ä¸€ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/*
æœç´¢ä¸“é¢˜ï¼ˆåˆ¤æ–­è¿é€šæ€§ï¼‰
1. å­˜åœ°å›¾ ï¼ˆå¤–æ¡†ç•™0ï¼Œä»[1, 1]ç‚¹å¼€å§‹å­˜ï¼Œä¸ç”¨åˆ¤æ–­è¾¹ç•Œï¼‰
2.æ–¹å‘æ•°ç»„ï¼Œç”¨æ–¹å‘æ•°ç»„å»éå†
3.å»é‡ï¼šæ–¹æ³•1ï¼šåœ°å›¾æœç´¢å®Œå°±ä¸ç”¨äº†ï¼Œå¯ä»¥ç›´æ¥æ”¹åœ°å›¾ æ–¹æ³•2ï¼šç”¨markæ•°ç»„åšæ ‡è®°
*/
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

int n, m, sx, sy, ans;
int dir[8][2] = {0, 1, 1, 0, 0, -1, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1};

char smap[105][105];

struct node {
    int x, y, step;
};

int main() {
    cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n &amp;gt;&amp;gt; sy &amp;gt;&amp;gt; sx; // åè¿‡æ¥è¾“å…¥
    for (int i = 1; i &amp;lt;= n; ++i) {
        cin &amp;gt;&amp;gt; &amp;amp;smap[i][1];
    }
    int nsx = n - sx + 1;
    queue&amp;lt;node&amp;gt; que;
    que.push((node){nsx, sy, 0});
    smap[nsx][sy] = &#39;M&#39;;
    while (!que.empty()) {
        node t = que.front(); que.pop();
        ans = t.step;
        for (int i = 0; i &amp;lt; 8; ++i) {
            int nx = t.x + dir[i][0];
            int ny = t.y + dir[i][1];
            if (smap[nx][ny] == &#39;.&#39;) {
                smap[nx][ny] = &#39;M&#39;;
                que.push((node){nx, ny, t.step + 1});
            }
        }
    }
    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;oj398é©¬çš„éå†&#34;&gt;OJ.398ï¼ˆé©¬çš„éå†ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/*
æœç´¢ä¸“é¢˜ï¼ˆåˆ¤æ–­è¿é€šæ€§ï¼‰
1. å­˜åœ°å›¾ ï¼ˆå¤–æ¡†ç•™0ï¼Œä»[1, 1]ç‚¹å¼€å§‹å­˜ï¼Œä¸ç”¨åˆ¤æ–­è¾¹ç•Œï¼‰
2.æ–¹å‘æ•°ç»„ï¼Œç”¨æ–¹å‘æ•°ç»„å»éå†
3.å»é‡ï¼šæ–¹æ³•1ï¼šåœ°å›¾æœç´¢å®Œå°±ä¸ç”¨äº†ï¼Œå¯ä»¥ç›´æ¥æ”¹åœ°å›¾ æ–¹æ³•2ï¼šç”¨markæ•°ç»„åšæ ‡è®°
*/
// å¹¿æœ
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

int n, m, sx, sy, ans[405][405];
int dir[8][2] = {1, 2, 1, -2, -1, 2, -1, -2, 2, 1, 2, -1, -2, 1, -2, -1};

struct node {
    int x, y, step;
};

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; sx &amp;gt;&amp;gt; sy;
    queue&amp;lt;node&amp;gt; que;
    que.push((node){sx, sy, 0});
    ans[sx][sy] = -1;
    while (!que.empty()) {
        node t = que.front(); que.pop();
        for (int i = 0; i &amp;lt; 8; ++i) {
            int nx = t.x + dir[i][0];
            int ny = t.y + dir[i][1];
            if (nx &amp;lt; 1 || ny &amp;lt; 1 || nx &amp;gt; n || ny &amp;gt; m || ans[nx][ny]) {
                continue;      
            }
            ans[nx][ny] = t.step + 1;
            que.push((node){nx, ny, ans[nx][ny]});
        }
    }
    
    for (int i = 1; i &amp;lt;= n; ++i) {
        for (int j = 1; j &amp;lt;= m; ++j) {
            j != 1 &amp;amp;&amp;amp; cout &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            if (ans[i][j] == -1) cout &amp;lt;&amp;lt; 0;
            else if (ans[i][j] == 0) cout &amp;lt;&amp;lt; -1;
            else cout &amp;lt;&amp;lt; ans[i][j];
        }
        cout &amp;lt;&amp;lt; endl;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2ä½“è‚²èµ›äº‹&#34;&gt;2.ä½“è‚²èµ›äº‹&lt;/h4&gt;
&lt;h5 id=&#34;oj479ä¹’ä¹“çƒ&#34;&gt;OJ.479ï¼ˆä¹’ä¹“çƒï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;
const int maxn = 1e5 + 10;
// å®šä¹‰å­˜å‚¨ç­”æ¡ˆçš„æ•°ç»„
int ans11[maxn][2], ans21[maxn][2], cnt11, cnt21;

void print() {
    for (int i = 0; i &amp;lt;= cnt11; ++i) {
        cout &amp;lt;&amp;lt; ans11[i][0] &amp;lt;&amp;lt; &amp;quot;:&amp;quot; &amp;lt;&amp;lt; ans11[i][1] &amp;lt;&amp;lt; endl;
    }
    cout &amp;lt;&amp;lt; endl;
    for (int i = 0; i &amp;lt;= cnt21; ++i) {
        cout &amp;lt;&amp;lt; ans21[i][0] &amp;lt;&amp;lt; &amp;quot;:&amp;quot; &amp;lt;&amp;lt; ans21[i][1] &amp;lt;&amp;lt; endl;
    }
    return ;
}
int main() {
    string s;
    while (cin &amp;gt;&amp;gt; s) {
        for (int i = 0; i &amp;lt; s.size(); ++i) {
            if (s[i] == &#39;E&#39;) {
                print();
                return 0;
            } else if (s[i] == &#39;W&#39;) { // æˆ‘æ–¹è®¡åˆ†
                ans11[cnt11][0]++;
                ans21[cnt21][0]++;
            } else {                 // æ•Œæ–¹è®¡åˆ†
                ans11[cnt11][1]++;
                ans21[cnt21][1]++;
            }
            // æ ¹æ®ç§¯åˆ†åˆ¶å¤„ç†æ¯å±€ç»“æœ
            if ((ans11[cnt11][0] &amp;gt;= 11 || ans11[cnt11][1] &amp;gt;= 11) &amp;amp;&amp;amp; abs(ans11[cnt11][0] - ans11[cnt11][1]) &amp;gt;= 2) {
                cnt11++;    
            }
            if ((ans21[cnt21][0] &amp;gt;= 21 || ans21[cnt21][1] &amp;gt;= 21) &amp;amp;&amp;amp; abs(ans21[cnt21][0] - ans21[cnt21][1]) &amp;gt;= 2) {
                cnt21++;
            }
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;oj480ä¿é¾„çƒ&#34;&gt;OJ.480ï¼ˆä¿é¾„çƒï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

// æ¯ä¸ªæ•°æ®çš„å­˜å‚¨æ–¹å¼ï¼Œæ¯æ¬¡æœ‰ä¸¤æ¬¡è®¡åˆ’
// char s[4]: ä¸¤æ¬¡æœºä¼šï¼Œå­˜å‚¨è¾“å…¥å­—ç¬¦
// n1: è¡¨ç¤º ç¬¬ä¸€æ¬¡ çš„åˆ†æ•°
// n2: è¡¨ç¤º ä¸¤æ¬¡ä¹‹å’Œï¼ˆæœ€å¤š10åˆ†ï¼‰
// flag: è¡¨ç¤º åŠ åˆ†æ¬¡æ•°
struct node {
    char s[4];
    int n1, n2, flag;
} arr[15];

int main() {
    int n = 0, ans = 0;
    while (cin &amp;gt;&amp;gt; arr[n].s) {
        if (arr[n].s[0] == &#39;/&#39;) { // ç¬¬1æ¬¡æœºä¼šå°±10åˆ†ï¼Œæœ‰ä¸¤æ¬¡åŠ åˆ†
            arr[n].n1 = 10;
            arr[n].n2 = 10;
            arr[n].flag = 2; 
        } else if (arr[n].s[1] == &#39;/&#39;) { // ç¬¬2æ¬¡æœºä¼š10åˆ†ï¼Œæœ‰ä¸€æ¬¡åŠ åˆ†æœºä¼š
            arr[n].n1 = arr[n].s[0] - &#39;0&#39;;
            arr[n].n2 = 10;
            arr[n].flag = 1;
        } else {  // ä¸¤æ¬¡æœºä¼šéƒ½æ²¡æœ‰ 10 åˆ†ï¼Œ æ²¡æœ‰åŠ åˆ†æœºä¼š
            arr[n].n1 = arr[n].s[0] - &#39;0&#39;;
            arr[n].n2 = (arr[n].s[1] - &#39;0&#39;) + arr[n].n1;
            arr[n].flag = 0;
        }
        n++;
    }
    // åŠ åˆ†å¤„ç†
    for (int i = 0; i &amp;lt; 10; ++i) {
        ans += arr[i].n2; // è¿™æ˜¯æ²¡æœ‰åŠ åˆ†å‰çš„åˆ†æ•°
        if (arr[i].flag == 2) { // ä¸¤æ¬¡åŠ åˆ†
            if (arr[i+1].flag == 2) ans += 10 + arr[i+2].n1;
            else ans += arr[i+1].n2; 
        } else if (arr[i].flag == 1) { // ä¸€æ¬¡åŠ åˆ†
            ans += arr[i+1].n1;
        }
    }
    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; 

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;oj481å†°å£¶æ¯”èµ›&#34;&gt;OJ.481ï¼ˆå†°å£¶æ¯”èµ›ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
int ans[15][2], num1[10], num2[10], r;

void print(int n) {
    int a = 0, b = 0;
    for (int i = 0; i &amp;lt; n; ++i) {
        cout &amp;lt;&amp;lt; ans[i][0] &amp;lt;&amp;lt; &amp;quot;:&amp;quot; &amp;lt;&amp;lt; ans[i][1] &amp;lt;&amp;lt; endl;
        a += ans[i][0]; b += ans[i][1];
    }
    cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;quot;:&amp;quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl;
    return ;
}
int main() {
    cin &amp;gt;&amp;gt; r;
    for (int i = 0; i &amp;lt; 10; ++i) {
        for (int j = 0; j &amp;lt; 8; ++j) {
            cin &amp;gt;&amp;gt; num1[j];
            if (num1[j] == -1) {
                print(i);
                return 0;
            }
        }
        for (int j = 0; j &amp;lt; 8; ++j) {
            cin &amp;gt;&amp;gt; num2[j];
        }
        sort(num1, num1 + 8);
        sort(num2, num2 + 8);
        if (num1[0] == num2[0]) continue;
        if (num1[0] &amp;lt; num2[0]) {
            for (int j = 0; j &amp;lt; 8; ++j) {
                if (num1[j] &amp;lt; num2[0] &amp;amp;&amp;amp; num1[j] &amp;lt;= r) {
                    ans[i][0]++;
                }
            }
        } else {
            for (int j = 0; j &amp;lt; 8; ++j) {
                if (num2[j] &amp;lt; num1[0] &amp;amp;&amp;amp; num2[j] &amp;lt;= r) {
                    ans[i][1]++;
                }
            }
        }
    }
    print(10);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;oj484æŸ±çŠ¶ç»Ÿè®¡å›¾&#34;&gt;OJ.484ï¼ˆæŸ±çŠ¶ç»Ÿè®¡å›¾ï¼‰&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

int arr[128] = {0}, maxn;
string s;

int main() {
    // è¾“å…¥å¤„ç†
    while (cin &amp;gt;&amp;gt; s) {
        for (int i = 0; i &amp;lt; s.size(); ++i) {
            arr[s[i]]++;
        }
    }
    // éå†å­—ç¬¦ï¼Œæ‰¾åˆ°æœ€å¤šçš„å­—ç¬¦ï¼ˆæŸ±å½¢é«˜åº¦ï¼‰
    for (int i = &#39;A&#39;; i &amp;lt;= &#39;Z&#39;; ++i) {
        maxn = max(maxn, arr[i]);
    }
  
    for (int i = 0; i &amp;lt; maxn; ++i) {
        int last = -1;
        // éå†å­—ç¬¦ï¼Œæ‰¾åˆ°å®½åº¦
        for (int j = &#39;A&#39;; j &amp;lt;= &#39;Z&#39;; ++j) {
            if (arr[j] &amp;gt;= maxn - i) last = j;
        }
        for (int j = &#39;A&#39;; j &amp;lt;= last; ++j) {
            if (arr[j] &amp;gt;= maxn - i) cout &amp;lt;&amp;lt; &amp;quot;*&amp;quot;;
            else cout &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            if (j != last) cout &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        }
        cout &amp;lt;&amp;lt; endl;
    }
    for (int i = &#39;A&#39;; i &amp;lt;= &#39;Z&#39;; ++i) {
        if (i != &#39;A&#39;) cout &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        cout &amp;lt;&amp;lt; (char)i ;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3å›¾è®º&#34;&gt;3.å›¾è®º&lt;/h4&gt;
&lt;h5 id=&#34;1-floydæ±‚å¤šæºæœ€çŸ­è·¯&#34;&gt;1-floyd(æ±‚å¤šæºæœ€çŸ­è·¯)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;

int arr[10005][10005], n, m, s; // s ä¸ºèµ·ç‚¹

int main() {
    memset(arr, 0x3F, sizeof(arr)); // æŠŠçŸ©é˜µçš„å€¼ åˆå§‹åŒ–ä¸ºæœ€å¤§å€¼
    scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;s);
    for (int i = 0; i &amp;lt; m; ++i) {
        int a, b, c;
        scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
        if (arr[a][b] &amp;gt; c) { // å»é‡è¾¹ï¼ŒæŠŠæƒå€¼å¤§çš„è¾¹å»æ‰
            arr[a][b] = c;
            arr[b][a] = c; // åŒå‘
        }
    }
	// floyd, ä¸‰é‡å¾ªç¯ï¼Œå¯ä»¥æ±‚å¤šæºæœ€çŸ­è·¯ï¼ˆä»»æ„ç‚¹åˆ°ä»»æ„ç‚¹ï¼‰ï¼Œï¼ˆOï¼ˆn^3ï¼‰ï¼‰æ…¢å¾—ç¦»è°±
    for (int i = 1; i &amp;lt;= n; ++i) {
        for (int j = 1; j &amp;lt;= n; ++j) {
            for (int k = 1; k &amp;lt;= n; ++k) {
                // j ç›´æ¥åˆ° k å’Œ j ç»è¿‡iä¸­è½¬ åˆ°k,æ¯”è¾ƒé‚£ä¸ªè·¯ç¨‹çŸ­
                arr[j][k] = min(arr[j][k], arr[j][i] + arr[i][k]);
            }
        }
    } 
    // å¯¹è§’çº¿åˆå§‹åŒ–ä¸º 0 ï¼ˆè‡ªå·±åˆ°è‡ªå·±çš„ è·¯ç¨‹ ä¸º0ï¼‰
    for (int i = 1; i &amp;lt;= n; ++i) { arr[i][i] = 0; }
    // ä» èµ·ç‚¹s åˆ°æ¯ä¸ªç‚¹çš„ æœ€çŸ­è·¯ï¼Œ éå†æ‰€æœ‰ç‚¹
    for (int i = 1; i &amp;lt;= n; ++i) {
        // æƒå€¼è¿˜æ˜¯ åˆå§‹åŒ–çš„å€¼ï¼Œ è¯´æ˜ä¸å¯åˆ°è¾¾ï¼Œ ä¸º -1
        if (arr[s][i] == 0x3F3F3F3F) cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
        else cout &amp;lt;&amp;lt; arr[s][i] &amp;lt;&amp;lt; endl;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2-dijkstraæ±‚å•æºæºæœ€çŸ­è·¯&#34;&gt;2-dijkstra(æ±‚å•æºæºæœ€çŸ­è·¯)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct edge {
    int e, v;
};

struct node {
    int cur, dis; // cur:å½“å‰ç‚¹ï¼Œ dis: åˆ°å½“å‰ç‚¹èµ°è¿‡çš„æœ€çŸ­è·¯å¾„
    // å°é¡¶å †ï¼Œ é‡è½½å°äºå·è¿ç®—ç¬¦
    bool operator&amp;lt;(const node &amp;amp;b) const {
        return this-&amp;gt;dis &amp;gt; b.dis;
    }
};

int n, m, s, ans[100005]; // ç­”æ¡ˆæ•°ç»„å­˜ï¼Œèµ·å§‹ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„

int main() {
    scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;s);
    vector&amp;lt;vector&amp;lt;edge&amp;gt; &amp;gt; edg(n + 5, vector&amp;lt;edge&amp;gt;());
    // ç­”æ¡ˆæ•°ç»„ï¼Œ åˆå§‹åŒ–ä¸ºæœ€å¤§å€¼
    memset(ans, 0x3f, sizeof(ans));
    // é‚»æ¥è¡¨å­˜å›¾
    for (int i = 0; i &amp;lt; m; ++i) {
        int a, b, c;
        scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
        // åŒå‘è¾¹
        edg[a].emplace_back((edge){b, c}); 
        edg[b].emplace_back((edge){a, c});
    }
    priority_queue&amp;lt;node&amp;gt; que; // å°å †é¡¶
    que.emplace((node){s, 0}); // æŠŠåˆå§‹ç‚¹ æ”¾å…¥å°é¡¶å †ï¼Œ è·ç¦»ä¸º0
    ans[s] = 0; // åˆ°sçš„ è·ç¦»ä¸º0
    // æ¯æ¬¡æŠŠè·¯å¾„æœ€çŸ­çš„ ç‚¹å¼¹å‡º
    while (!que.empty()) {
        node t = que.top(); que.pop();
        // å¦‚æœå½“å‰åœ¨ç­”æ¡ˆæ•°ç»„å·²æœ‰ï¼Œ å¹¶ä¸”åˆ°å½“å‰ç‚¹çš„è·ç¦»å¤§äºä¹‹å‰çš„ï¼Œé‚£ä¹ˆä¸æ›´æ–°ï¼Œä¸‹ä¸€ä¸ª
        if (ans[t.cur] &amp;lt; t.dis) continue; 
        // æŠŠå½“å‰ç‚¹ï¼ˆæœ€å°è·¯å¾„çš„ç‚¹ï¼‰ï¼Œéå†ä¸€éå®ƒè¿æ¥çš„ç‚¹
        for (int i = 0; i &amp;lt; edg[t.cur].size(); ++i) {
            int e = edg[t.cur][i].e, v = edg[t.cur][i].v;
            // å¦‚æœç­”æ¡ˆæ•°ç»„é‡Œé¢çš„ç‚¹ å¤§äº è¯¥ç‚¹çš„è·¯å¾„ï¼ˆå½“å‰ç‚¹çš„è·ç¦» + å½“å‰ç‚¹å’Œè¿æ¥ç‚¹çš„è¾¹æƒå€¼ï¼‰
            if (ans[e] &amp;gt; t.dis + v) {
                ans[e] = t.dis + v;
                que.emplace((node){e, t.dis + v}); // æ”¾åˆ°å°é¡¶å †
            }
        }
    }
    // éå†ç­”æ¡ˆæ•°ç»„çš„æ¯ä¸ªç‚¹
    for (int i = 1; i &amp;lt;= n; ++i) {
        if (ans[i] == 0x3f3f3f3f) printf(&amp;quot;-1\n&amp;quot;);
        else printf(&amp;quot;%d\n&amp;quot;, ans[i]);
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2-dijkstraæ±‚å•æºæºæœ€çŸ­è·¯-star&#34;&gt;2-dijkstra(æ±‚å•æºæºæœ€çŸ­è·¯)-star&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct star {
    int e, v, next;
} edg[100005];
struct node {
    int cur, dis;
    bool operator&amp;lt;(const node &amp;amp;b) const {
        return this-&amp;gt;dis &amp;gt; b.dis;
    }
};
int n, m, s, ans[100005], head[100005], cnt;
void add_edg(int a, int b, int c) {
    edg[cnt].e = b;
    edg[cnt].v = c;
    edg[cnt].next = head[a];
    head[a] = cnt++;
    return ;
}
int main() {
    memset(head, -1, sizeof(head));
    memset(ans, 0x3f, sizeof(ans));
    scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;s);
    for (int i = 0; i &amp;lt; m; ++i) {
        int a, b, c;
        scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
        add_edg(a, b, c);
        add_edg(b, a, c);
    }
    priority_queue&amp;lt;node&amp;gt; pq;
    pq.emplace((node){s, 0});
    ans[s] = 0;
    while (!pq.empty()) {
        node t = pq.top(); pq.pop();
        if (ans[t.cur] &amp;lt; t.dis) continue;
        for (int i = head[t.cur]; i &amp;gt; -1; i = edg[i].next) {
            int e = edg[i].e, v = edg[i].v;
            if (ans[e] &amp;gt; t.dis + v) {
                ans[e] = t.dis + v;
                pq.emplace((node){e, t.dis + v});
            }
        }
    }
    for (int i = 1; i &amp;lt;= n; ++i) {
        if (ans[i] == 0x3f3f3f3f) printf(&amp;quot;%d\n&amp;quot;, -1);
        else printf(&amp;quot;%d\n&amp;quot;, ans[i]);
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4æ¬§æ‹‰è®¡åˆ’&#34;&gt;4.æ¬§æ‹‰è®¡åˆ’&lt;/h4&gt;
&lt;h5 id=&#34;13-eulerå¤§å’Œ&#34;&gt;13-euler(å¤§å’Œ)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;
// å®šä¹‰æ•°ç»„
char str1[1005], str2[1005];
int nums1[1005], nums2[1005], sum[1005];

int main() {
    cin &amp;gt;&amp;gt; str1 &amp;gt;&amp;gt; str2;
    // å­˜æ•°å­—ï¼ˆæ•°ç»„ç¬¬ä¸€ä¸ªæ•°ç»„å­˜çš„æ˜¯ æ•°å­—çš„ä½æ•°ï¼ˆarr[0] = strlen(s)ï¼‰ï¼Œæ•°å­—å€’ç€å­˜ï¼‰
    nums1[0] = strlen(str1), nums2[0] = strlen(str2);
    for (int i = 1, j = nums1[0] - 1; j &amp;gt;= 0; ++i, --j) {
        nums1[i] = str1[j] - &#39;0&#39;;
    }
    for (int i = 1, j = nums2[0] - 1; j &amp;gt;= 0; ++i, --j) {
        nums2[i] = str2[j] - &#39;0&#39;;
    }
    // ä¸¤æ•°ç»„åŠ æ³•æ“ä½œ
    sum[0] = max(nums1[0], nums2[0]);
    for (int i = 1; i &amp;lt;= sum[0]; ++i) {
        sum[i] = nums1[i] + nums2[i];
    }
    // åŠ å®Œåï¼Œè¿›ä½å¤„ç†
    for (int i = 1; i &amp;lt;= sum[0]; ++i) {
        if (sum[i] &amp;gt; 9) {
            sum[i+1] += (sum[i] / 10);
            sum[i] %= 10;
            if (i == sum[0]) sum[0]++;
        }
    }
	// å€’ç€è¾“å‡º
    for (int i = sum[0]; i &amp;gt; 0; --i) {
        cout &amp;lt;&amp;lt; sum[i];
    }
    cout &amp;lt;&amp;lt; endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;11-euleræ–¹é˜µä¸­æœ€å¤§çš„ä¹˜ç§¯&#34;&gt;11-euler(æ–¹é˜µä¸­æœ€å¤§çš„ä¹˜ç§¯)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

int nums[30][30];
int dir[4][2] = {-1, 1, 0, 1, 1, 1, 1, 0}; // æ–¹å‘æ•°ç»„
int main() {
    int ans = 0;
    // è¾“å‡ºæ•°ç»„ï¼Œå¹¶å››å‘¨å¡«å……0
    for (int i = 5; i &amp;lt; 25; ++i) {
        for (int j = 5; j &amp;lt; 25; ++j) {
            cin &amp;gt;&amp;gt; nums[i][j];
        } 
    }
	// éå†æ•°ç»„
    for (int i = 5; i &amp;lt; 25; ++i) {
        for (int j = 5; j &amp;lt; 25; ++j) {
            for (int k = 0; k &amp;lt; 4; ++k) { // K æ§åˆ¶æ–¹å‘ ï¼ˆKä¸ªæ–¹å‘ï¼‰
                int t = nums[i][j];
                for (int l = 1; l &amp;lt; 4; ++l) { // L æ§åˆ¶è·¯ç¨‹ ï¼ˆLæ­¥ï¼‰
                    // åœ¨[i][j]çš„ä½ç½®ä½œä¸ºèµ·ç‚¹ä¸Š å»èµ°
                    int x = i + dir[k][0] * l, y = j + dir[k][1] * l; 
                    t *= nums[x][y];
                }
                ans = max(ans, t);
            }
        }
    }
    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;18-euleræœ€å¤§è·¯å¾„å’Œi&#34;&gt;18-euler(æœ€å¤§è·¯å¾„å’Œâ… )&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

int nums[20][20];
// è‡ªé¡¶å‘ä¸‹ï¼š dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]);
// è‡ªåº•å‘ä¸Šï¼š dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]);
int main() {
    int ans = 0;
    for (int i = 1; i &amp;lt;= 15; ++i) {
        for (int j = 1; j &amp;lt;= i; ++j) {
            cin &amp;gt;&amp;gt; nums[i][j];
        }
    }
    /* // è‡ªé¡¶åˆ°åº•é€’æ¨
    for (int i = 2; i &amp;lt;= n; ++i) {
        for (int j = 1; j &amp;lt;= i; ++j) {
            nums[i][j] += max(nums[i-1][j-1], nums[i-1][j]);
        }
    }

    for (int i = 1; i &amp;lt;= n; ++i) {
        ans = max(ans, nums[n][i]);  
    }
    */ 
    // è‡ªåº•å‘é¡¶é€’æ¨
    for (int i = 15 - 1; i &amp;gt; 0; --i) {
        for (int j = 1; j &amp;lt;= i; ++j) {
            nums[i][j] += max(nums[i+1][j], nums[i+1][j+1]);
        }
    }
    ans = nums[1][1];
    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;25-euler1000ä½æ–æ³¢é‚£å¥‘æ•°&#34;&gt;25-euler(1000ä½æ–æ³¢é‚£å¥‘æ•°)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
// ç”¨ä¸€ä¸ªäºŒç»´æ•°ç»„å­˜å‚¨ï¼Œ ä¸¤è¡Œæ•°æ®ï¼Œ æ¯è¡Œç¬¬1ä¸ªæ•°æ˜¯è®°å½•é•¿åº¦çš„
int nums[2][1005] = {{1, 1}, {1, 1}};  // ç¬¬ä¸€é¡¹å’Œç¬¬äºŒé¡¹
int a = 0, b = 1; // ä»£è¡¨ç¬¬ä¸€è¡Œå’Œç¬¬äºŒè¡Œ

// æ•°ç»„ç¬¬ä¸€è¡Œæ•°å­— + æ•°ç»„ç¬¬äºŒè¡Œæ•°å­—
// ä¾‹å¦‚ ï½›1, 8ï½ + ï½›1ï¼Œ 5ï½ = ï½›2ï¼Œ1ï¼Œ3ï½,ç¬¬1ä¸ªæ•°å­—æ˜¯é•¿åº¦ï¼Œåé¢æ˜¯ç›¸åŠ åçš„ç»“æœ
int func(int x, int y) {
    // ä¼ å…¥æ—¶ï¼Œç¬¬ä¸€è¡Œæ˜¯è¾ƒå¤§çš„
    nums[y][0] = nums[x][0];
    for (int i = 1; i &amp;lt;= nums[y][0]; ++i) {
        nums[y][i] += nums[x][i];
        if (nums[y][i] &amp;gt; 9) {
            nums[y][i+1] += nums[y][i] / 10;
            nums[y][i] %= 10;
            if (i == nums[y][0]) nums[y][0]++;
        }
    }
    return nums[y][0] == 1000;
}


int main() {
    for (int i = 3; 1; ++i) {
        if (func(b, a)) { // ç›¸åŠ 
            cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;
            break;
        }
        // æ¯æ¬¡ç›¸åŠ å æ›´æ¢ä½ç½®ï¼Œæ¯æ¬¡è®©ç¬¬ä¸€è¡Œçš„æ•°å­—æ˜¯æœ€å¤§çš„
        // ä¾‹å¦‚ {{1, 8}, {1, 5}} = {{1, 5}, {2, 1, 3}} æ›´æ¢ä½ç½®å
        // {{2, 1, 3}, {1, 8}}
        swap(a, b); 
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;4-euleræœ€å¤§å›æ–‡ä¹˜ç§¯&#34;&gt;4-euler(æœ€å¤§å›æ–‡ä¹˜ç§¯)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;*å›æ–‡æ•°çš„è¯»æ³•æ˜¯ä¸€æ ·çš„ã€‚ç”±ä¸¤ä¸ªä¸¤ä½æ•°çš„ä¹˜ç§¯æ„æˆçš„æœ€å¤§å›æ–‡æ•°æ˜¯ 9009 = 91 Ã— 99ã€‚
æ‰¾å‡ºç”±ä¸¤ä¸ª 3 ä½æ•°å­—çš„ä¹˜ç§¯æ„æˆçš„æœ€å¤§å›æ–‡æ•°ã€‚ã€‚*/

#include &amp;lt;iostream&amp;gt;
using namespace std;

// æ•´æ•°ç¿»è½¬
int check(int x) {
    int a = x, t = 0;
    while (x) {
        t = t * 10 + x % 10;
        x /= 10;
    }
    return a == t;
}

int main() {
    int ans = 0;
    for (int i = 100; i &amp;lt; 1000; ++i) {
        for (int j = i; j &amp;lt; 1000; ++j) { // é¿å…é‡å¤ j ä» i å¼€å§‹
            if (check(i * j)) {
                ans = max(ans, i * j);
            }
        }
    }
    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;590-ojæ ‘å¡”ç‹‚æƒ³æ›²&#34;&gt;590-OJ(æ ‘å¡”ç‹‚æƒ³æ›²)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
using namespace std;
// numsæ•°ç»„ï¼šå­˜åŸå§‹æ•°æ®ï¼Œ utdæ•°ç»„ï¼šå­˜è‡ªé¡¶å‘ä¸‹æ•°æ®
// dtuæ•°ç»„ï¼šå­˜è‡ªåº•å‘ä¸‹æ•°æ®ï¼Œ ansæ•°ç»„ï¼šå­˜ è¯¥å…ƒç´ è·¯å¾„çš„æœ€å¤§å€¼
int nums[1005][1005], utd[1005][1005], dtu[1005][1005], ans[1005][1005];
// fin[x][0]:å­˜æ¯è¡Œæœ€å¤§å…ƒç´ çš„çš„åˆ—ç´¢å¼•
// fin[x][1]:å­˜æ¯è¡Œæœ€å¤§çš„å…ƒç´ 
// fin[x][2]:å­˜æ¯è¡Œçš„ç¬¬2å¤§å…ƒç´ 
int M, N, fin[1005][3]; 

int main() {
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;
    // è¾“å…¥æ•°æ®ï¼Œå­˜åˆ°numsæ•°ç»„
    for (int i = 1; i &amp;lt;= N; ++i) {
        for (int j = 1; j &amp;lt;= i; ++j) {
            scanf(&amp;quot;%d&amp;quot;, &amp;amp;nums[i][j]);
        }
    }
	// è‡ªé¡¶å‘ä¸‹ï¼Œè®¡ç®—æœ€å¤§è·¯å¾„å’Œï¼Œå­˜åˆ°utdæ•°ç»„
    for (int i = 1; i &amp;lt;= N; ++i) {
        for (int j = 1; j &amp;lt;= i; ++j) {
            utd[i][j] = max(utd[i-1][j-1], utd[i-1][j]) + nums[i][j];
        }
    }
    // è‡ªåº•å‘ä¸Šï¼Œè®¡ç®—æœ€å¤§è·¯å¾„å’Œï¼Œå­˜åˆ°dtuæ•°ç»„
    for (int i = N; i &amp;gt; 0; --i) {
        for (int j = i; j &amp;gt; 0; --j) {
            dtu[i][j] = max(dtu[i+1][j], dtu[i+1][j+1]) + nums[i][j];
        }
    }
	// è®¡ç®—ç»è¿‡æ¯ä¸ªå…ƒç´ çš„æœ€å¤§è·¯å¾„å’Œï¼Œå­˜åˆ°ansæ•°ç»„
    for (int i = 1; i &amp;lt;= N; ++i) {
        for (int j = 1; j &amp;lt;= i; ++j) {
            ans[i][j] = utd[i][j] + dtu[i][j] - nums[i][j];
        }
    }
    // æŠŠæ¯è¡Œå…ƒç´ çš„æœ€å¤§å…ƒç´ çš„åˆ—ç´¢å¼•å­˜åˆ°fin[i][0],
    // æŠŠæ¯è¡Œå…ƒç´ çš„æœ€å¤§çš„å…ƒç´ å­˜åˆ°fin[i][1],
    // æŠŠæ¯è¡Œå…ƒç´ çš„ç¬¬äºŒå¤§çš„å…ƒç´ å­˜åˆ°fin[i][2],
    for (int i = 2; i &amp;lt;= N; ++i) {
        int max1 = 0, max2 = 0, ind = 0;
        for (int j = 1; j &amp;lt;= i; ++j) {
            // éå†æ¯è¡Œæ•°æ®ï¼Œå¯»æ‰¾
            if (ans[i][j] &amp;gt; max1) {
                max2 = max1; // æ³¨æ„å…ˆæŠŠ ä¹‹å‰æœ€å¤§çš„ç»™åˆ°max2
                max1 = ans[i][j];
                ind = j;
            }
            else if (ans[i][j] &amp;gt; max2) {
                max2 = ans[i][j];
            }
        }
        // æ‰¾åˆ°æ¯è¡Œçš„æœ€å¤§åï¼Œå­˜å‚¨æ“ä½œ
        fin[i][0] = ind, fin[i][1] = max1, fin[i][2] = max2;
    }
    
    for (int i = 1; i &amp;lt;= M; ++i) {
        int x, y;
        scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;x, &amp;amp;y);
        if (x == 1 &amp;amp;&amp;amp; y == 1) printf(&amp;quot;-1\n&amp;quot;); // å µä½é¡¶ç‚¹ï¼Œæ²¡æœ‰è·¯å¾„
        else if (fin[x][0] == y) printf(&amp;quot;%d\n&amp;quot;, fin[x][2]); // å µåˆ°æœ€å¤§è·¯å¾„ä¸­çš„å…ƒç´ 
        else printf(&amp;quot;%d\n&amp;quot;, fin[x][1]); // æ²¡æœ‰å µåˆ°æœ€å¤§è·¯å¾„ä¸­çš„å…ƒç´ 
    }
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;eulerå¤§ä¹˜&#34;&gt;euler(å¤§ä¹˜)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;
// å®šä¹‰æ•°ç»„
char str1[1005], str2[1005];
int nums1[1005], nums2[1005], ans[2010];

int main() {
    cin &amp;gt;&amp;gt; str1 &amp;gt;&amp;gt; str2;
    // å­˜æ•°æ®ï¼Œï¼ˆç¬¬1ä¸ªå­˜é•¿åº¦ï¼Œ åé¢å€’ç€å­˜ï¼‰
    nums1[0] = strlen(str1), nums2[0] = strlen(str2);
    for (int i = 1, j = nums1[0] - 1; j &amp;gt;= 0; ++i, --j) {
        nums1[i] = str1[j] - &#39;0&#39;;
    }
    for (int i = 1, j = nums2[0] - 1; j &amp;gt;= 0; ++i, --j) {
        nums2[i] = str2[j] - &#39;0&#39;;
    }
    // ä¹˜æ³•æ“ä½œ (i * jçš„ä½ç½®åœ¨ i + j - 1)
    ans[0] = nums1[0] + nums2[0] - 1;
    for (int i = 1; i &amp;lt;= nums1[0]; ++i) {
        for (int j = 1; j &amp;lt;= nums2[0]; ++j) {
            ans[i+j-1] += nums1[i] * nums2[j]; // å…³é”®
        }
    }
    // è¿›ä½æ“ä½œ
    for (int i = 1; i &amp;lt;= ans[0]; ++i) {
        if (ans[i] &amp;gt; 9) {
            ans[i+1] += ans[i] / 10;
            ans[i] %= 10;
            if (i == ans[0]) ans[0]++;
        }
    }
    // å€’ç€è¾“å‡º
    for (int i = ans[0]; i &amp;gt; 0; --i) {
        cout &amp;lt;&amp;lt; ans[i];
    }
    cout &amp;lt;&amp;lt; endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5å­—å…¸æ ‘&#34;&gt;5.å­—å…¸æ ‘&lt;/h4&gt;
&lt;h5 id=&#34;haizei_oj_281å‰ç¼€å’ŒæŒ‡é’ˆç»“æ„è§£æ³•&#34;&gt;Haizei_OJ_281(å‰ç¼€å’Œï¼ŒæŒ‡é’ˆç»“æ„è§£æ³•)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;
const int maxn = 1e6 + 5; // æ•°æ®èŒƒå›´
const int base = 26; // 26ä¸ªå°å†™å­—æ¯

// 1.ç»“æ„å®šä¹‰
typedef struct Node { 
    int flag; // æ ‡è®°æ˜¯å¦æˆè¯ï¼Œæ ‡è®°1ä¸ºæˆè¯
    struct Node *next[base]; // nextæ•°ç»„å­˜æ”¾26ä¸ªNode* æŒ‡é’ˆ
} Node;

// 2.æ„å»ºæ–°çš„èŠ‚ç‚¹
Node *getNewNode() {
    Node *p = (Node *)malloc(sizeof(Node)); // ç”³è¯·å†…å­˜ç©ºé—´
    p-&amp;gt;flag = 0; // é»˜è®¤æ ‡è®°ä¸º0
    memset(p-&amp;gt;next, 0, sizeof(Node *) * base); // åˆå§‹åŒ–nextæ•°ç»„ä¸º0
    return p;
}

// 3.å›æ”¶ç©ºå†…å­˜é—´ï¼Œ å±‚åºéå†å›æ”¶
void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i &amp;lt; base; ++i) {
        clear(root-&amp;gt;next[i]);
    }
    free(root);
    return ;
}

// æ’å…¥å­—ç¬¦ä¸²ï¼Œç”Ÿæˆå­—å…¸æ ‘
void insert(Node *root, const char *str) {
    Node *p = root;
    for (int i = 0; str[i]; ++i) {
        int ind = str[i] - &#39;a&#39;;
        if (p-&amp;gt;next[ind] == NULL) {
            p-&amp;gt;next[ind] = getNewNode();
        }
        p = p-&amp;gt;next[ind];
    }
    p-&amp;gt;flag += 1; // æœ‰ç›¸åŒå­—ç¬¦ä¸²æ—¶ï¼Œflag+1
    return ;
}
// ç›®æ ‡å­—ç¬¦ä¸²åœ¨å­—å…¸æ ‘ä¸ŠåŒ¹é…ï¼ŒæŸ¥æ‰¾
int find(Node *root, const char *str) {
    Node *p = root, *q;
    int ans = 0;
    for (int i = 0; str[i]; ++i) {
        int ind = str[i] - &#39;a&#39;;
        p = p-&amp;gt;next[ind];
        if (p == 0) return ans; // p == 0æ—¶è¯´æ˜å·²ç»æ²¡æœ‰åŒ¹é…äº†
        ans += p-&amp;gt;flag; // ç»Ÿè®¡åŒ¹é…äº†å¤šå°‘ä¸ªå­—ç¬¦
    }
    return ans;
}
int N, M;
char str[maxn];

int main() {
    Node *root = getNewNode();
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;N, &amp;amp;M);
    for (int i = 0; i &amp;lt; N; ++i) {
        scanf(&amp;quot;%s&amp;quot;, str);
        insert(root, str);
    }
    for (int i = 0; i &amp;lt; M; ++i) {
        scanf(&amp;quot;%s&amp;quot;, str);
        int ans = find(root, str);
        printf(&amp;quot;%d\n&amp;quot;, ans);
    }
    clear(root);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;haizei_oj_282æœ€å¤§å¼‚æˆ–å¯¹æŒ‡é’ˆç»“æ„è§£æ³•&#34;&gt;Haizei_OJ_282(æœ€å¤§å¼‚æˆ–å¯¹ï¼ŒæŒ‡é’ˆç»“æ„è§£æ³•)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;

// æ ¹æ®æ•°æ®èŒƒå›´å®šä¹‰å¸¸é‡
const int maxn = 32e5 + 10;
const int maxk = 30;
const int base = 2;

// 1.ç»“æ„å®šä¹‰
typedef struct Node {
    struct Node *next[base];
} Node;

// 2.æ„å»ºèŠ‚ç‚¹
Node *getNewNode() {
    Node *p = (Node *)malloc(sizeof(Node)); // ç”³è¯·å†…å­˜ç©ºé—´
    memset(p-&amp;gt;next, 0, sizeof(Node *) * base); // åˆå§‹åŒ–nextæ•°ç»„
    return p;
}

// 3.å›æ”¶å†…å­˜ç©ºé—´ï¼Œå±‚åºéå†
void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i &amp;lt; base; ++i) {
        clear(root-&amp;gt;next[i]);
    }
    free(root);
    return ;
}

// æ’å…¥äºŒè¿›åˆ¶æ•°å­—ï¼ˆ0ï¼Œ1ï¼‰
void insert(Node *root, int val) {
    Node *p = root;
    // int 32ä½,ä»å·¦åˆ°å³ç¬¬ä¸€ä½æ˜¯ç¬¦å·ä½ï¼ˆ32ä½ç½®ï¼‰ï¼Œ1å³ç§»30ä½å°±æ˜¯31ä½ç½®
    for (int i = maxk; i &amp;gt;= 0; --i) {
        //æ’å…¥çš„æ•°å­—é™¤äº†ç¬¦å·ä½ï¼Œä»å·¦åˆ°å³æ¯ä¸€ä½éƒ½å…¥1ä¸æ“ä½œ
        int ind = !!(val &amp;amp; (1 &amp;lt;&amp;lt; i)); 
        // åˆ¤æ–­æ˜¯å¦æœ‰æ’å…¥ï¼Œæœ‰æ’å…¥å°±ä¸éœ€è¦æ’å…¥
        if (p-&amp;gt;next[ind] == NULL) {
            p-&amp;gt;next[ind] = getNewNode();
        }
        p = p-&amp;gt;next[ind]; // ä¸‹ä¸€ä½
    }
    return ;
}

int find(Node *root, int val) {
    Node *p = root;
    int ans = 0;
    // æŸ¥æ‰¾è¯¥æ•°å­—çš„æœ€å¤§çš„å¼‚æˆ–å€¼ï¼Œï¼ˆä¸¤ä¸ªæ•°å­—ä¸ä¸€æ ·ï¼Œå¼‚æˆ–æœ€å¤§ï¼‰
    for (int i = maxk; i &amp;gt;= 0; --i) {
        int ind = !(val &amp;amp; (1 &amp;lt;&amp;lt; i)); 
        if (p-&amp;gt;next[ind] != NULL) {
            ans |= (1 &amp;lt;&amp;lt; i); // èƒ½æ‰¾åˆ°ç›¸åçš„æ•°å­—ï¼Œè¯¥ä½ç½®æŠŠ1æˆ–åˆ°ans
            p = p-&amp;gt;next[ind]; // ä»è¯¥è·¯å¾„å¾€ä¸‹æ‰¾
        } else {
            p = p-&amp;gt;next[!ind]; // æ²¡æœ‰æ‰¾åˆ°ç›¸åçš„æ•°å­—ï¼Œç›´æ¥å¾€ä¸‹æ‰¾
        }
    }
    return ans;
}

int main() {
    Node *root = getNewNode();
    int N, A, fval = 0, ans = 0;
    cin &amp;gt;&amp;gt; N;
    for (int i = 0; i &amp;lt; N; ++i) {
        scanf(&amp;quot;%d&amp;quot;, &amp;amp;A);
        if (i) fval = find(root, A);
        ans = (fval &amp;gt; ans) ? fval : ans;
        insert(root, A);
    }
    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">åˆ·é¢˜é›†</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/BDS-9.å“ˆå¸Œè¡¨/"" data-c="
          &lt;h2 id=&#34;å“ˆå¸Œè¡¨&#34;&gt;å“ˆå¸Œè¡¨&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
// ç”¨æ‹‰é“¾æ³•è§£å†³å“ˆå¸Œå†²çª
/*
å“ˆå¸Œè¡¨ç»“æ„å®šä¹‰ï¼šæœ‰ä¸€ä¸ªå“ˆå¸Œè¡¨ï¼ˆåŠ¨æ€ç”³è¯·å†…å­˜ï¼Œå“ˆå¸Œè¡¨å¤§å°ä¸ºsizeï¼‰ï¼Œå­˜æ”¾é“¾è¡¨çš„é¦–åœ°å€ **dataã€‚
é“¾è¡¨ç»“æ„å®šä¹‰ï¼šèŠ‚ç‚¹å€¼åŸŸå­˜æ”¾ å­—ç¬¦ä¸²ï¼ˆåŒä¸€é“¾è¡¨çš„å­—ç¬¦ä¸²å“ˆå¸Œå€¼ç›¸ç­‰ï¼‰ï¼Œ æŒ‡é’ˆåŸŸ ç›´çº¿ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
*/
typedef struct Node {
    char *str; // å€¼åŸŸ å­˜æ”¾ å­—ç¬¦ä¸²
    struct Node *next; // æŒ‡é’ˆåŸŸ
} Node;

typedef struct Hash {
    Node **data; // å­˜æ”¾ æ¯æ¡é“¾è¡¨çš„ é¦–åœ°å€
    int size; // å“ˆå¸Œè¡¨å¤§å°
} Hash;
// æ„å»ºæ–°èŠ‚ç‚¹ï¼Œå€¼åŸŸå­˜æ”¾å­—ç¬¦ä¸²ï¼ŒæŒ‡é’ˆåŸŸæŒ‡å‘ åŒä¸€å“ˆå¸Œå€¼çš„ é“¾è¡¨head
Node *getNewNode(const char *str, Node *head) {
    Node *p = (Node *)malloc(sizeof(Node));
    p-&amp;gt;str = strdup(str); // strdup ç”¨åˆ°äº† malloc,éœ€è¦free
    p-&amp;gt;next = head; // æŒ‡å‘ é“¾è¡¨å¤´
    return p;
}
// æ„å»ºhashtable
Hash *getHash(int n) {
    Hash *h = (Hash *)malloc(sizeof(Hash));
    h-&amp;gt;size = 2 * n; // è€ƒè™‘å“ˆå¸Œè¡¨çš„ç©ºé—´åˆ©ç”¨ç‡50% ~ 90%ï¼Œå¼€è¾Ÿç©ºé—´å¤§ä¸€å€
     // callocå¼€è¾Ÿï¼Œåˆå§‹åŒ–ä¸º0ï¼Œå¯ä»¥æ¯ä¸ªé“¾è¡¨å¤´éƒ¨ç½®ç©ºï¼Œå®‰å…¨
    h-&amp;gt;data = (Node **)calloc(h-&amp;gt;size, sizeof(Node *));
    return h;
}
// é“¾è¡¨å†…å­˜å›æ”¶
void clear_node(Node *node) {
    if (node == NULL) return ;
    Node *p = node, *q;
    while (p) {
        q = p-&amp;gt;next;
        free(p-&amp;gt;str); // strdup()å‡ºæ¥çš„ä¹Ÿè¦free
        free(p);
        p = q;
    }
    return ;
}

void clear(Hash *h) {
    if (h == NULL) return ;
    for (int i = 0; i &amp;lt; h-&amp;gt;size; ++i) {
        clear_node(h-&amp;gt;data[i]); // å›æ”¶æ¯æ¡é“¾è¡¨
    }
    free(h-&amp;gt;data); // å›æ”¶å“ˆå¸Œè¡¨
    free(h); // å›æ”¶å“ˆå¸Œè¡¨
    return ;
}
// BKDRHash
/*
æŠŠå­—ç¬¦ä¸²çš„æ¯ä¸ªå­—ç¬¦å“ˆå¸Œæˆä¸€ä¸ªæ•°å­—
// å“ˆå¸Œå…¬å¼ï¼š hash = hash * seed + str[i]
// seed åˆå§‹åŒ–ä¸€ä¸ª ç´ æ•°ï¼ˆä¾‹å¦‚31ï¼‰ï¼Œ hashåˆå§‹åŒ–ä¸º0
*/
// å“ˆå¸Œå‡½æ•°
int BKDRHash(const char *str) {
    int seed = 31, hash = 0; 
    for (int i = 0; str[i]; i++) {
        hash = hash * sedd + str[i];
    }
    return hash &amp;amp; 0x7fffffff; // é˜²æ­¢å“ˆå¸Œå€¼æº¢å‡º æŒ‰ä½ä¸ 0111111111å˜æˆæ•´æ•°
}

int insert(Hash *h, const char *str) {
    int hash = BKDRHash(str); // å°†å­—ç¬¦ä¸²é€šè¿‡å“ˆå¸Œå‡½æ•°ï¼Œæ˜ å°„æˆå“ˆå¸Œå€¼
    int ind = hash % h-&amp;gt;size; // æ ¹æ®å“ˆå¸Œè¡¨çš„å¤§å°ï¼Œå¯¹å“ˆå¸Œå€¼å–æ¨¡,å¾—åˆ°ç´¢å¼•å€¼
    // p-&amp;gt;next = old_head, new_head-&amp;gt;next = p
    h-&amp;gt;data[ind] = getNewNode(str, h-&amp;gt;data[ind]); // å»åˆ°ç´¢å¼•å€¼ä½ç½®çš„é“¾è¡¨ç”¨å¤´æ’æ³•
    return 1;
}

int find(Hash *h, const char *str) {
    int hash = BKDRHash(str);  // å°†å­—ç¬¦ä¸²é€šè¿‡å“ˆå¸Œå‡½æ•°ï¼Œæ˜ å°„æˆå“ˆå¸Œå€¼
    int ind = hash % h-&amp;gt;size;  // æ ¹æ®å“ˆå¸Œè¡¨çš„å¤§å°ï¼Œå¯¹å“ˆå¸Œå€¼å–æ¨¡,å¾—åˆ°ç´¢å¼•å€¼
    Node *p = h-&amp;gt;data[ind]; // å»åˆ°ç´¢å¼•å€¼ä½ç½®çš„é“¾è¡¨å¤´éƒ¨
    while (p &amp;amp;&amp;amp; strcmp(p-&amp;gt;str, str) != 0) p = p-&amp;gt;next; // éå†é“¾è¡¨æŸ¥æ‰¾
    return p != NULL; // pä¸ºç©ºï¼Œè¯´æ˜å­—ç¬¦ä¸²æ²¡æœ‰æ’å…¥è¿›æ¥ï¼Œæ²¡æœ‰æ‰¾åˆ°
}

int main() {
    #define maxn 105
    int op;
    char str[maxn] = {0};
    Hash *h = getHash(maxn);
    while (~scanf(&amp;quot;%d %s&amp;quot;, &amp;amp;op, str)) {
        switch (op) {
            case 0: insert(h, str); break;
            case 1: printf(&amp;quot;%d\n&amp;quot;, find(h, str)); break;
        }
    }
    clear(h);
    #undef maxn
    return 0;
}


&lt;/code&gt;&lt;/pre&gt;
">BDS-9.å“ˆå¸Œè¡¨</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/BDS-3.é˜Ÿåˆ—/"" data-c="
          &lt;h2 id=&#34;é˜Ÿåˆ—queue&#34;&gt;é˜Ÿåˆ—ï¼ˆQueueï¼‰&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;time.h&amp;gt;

#define COLOR(a, b) &amp;quot;\e[&amp;quot; #b &amp;quot;m&amp;quot; a &amp;quot;\e[0m&amp;quot;
#define GREEN(a) COLOR(a, 32)

// ç»“æ„å®šä¹‰
/*
åŠ¨æ€å¼€è¾Ÿå­˜å‚¨å…ƒç´ çš„å®¹å™¨ï¼š*data
æŒ‡å‘é˜Ÿåˆ—å¤´çš„æŒ‡é’ˆï¼šhead
æŒ‡å‘é˜Ÿåˆ—å°¾çš„æŒ‡é’ˆï¼štail
å®¹å™¨å¤§å°ï¼šsize
ç›®å‰å­˜å‚¨å…ƒç´ çš„ä¸ªæ•°ï¼šcount
*/
typedef struct queue {
    int *data;
    int head, tail, size, count;
} queue;

// ç»“æ„æ“ä½œ
/*
ç»™é˜Ÿåˆ—åŠ¨æ€ç”³è¯·å†…å­˜ç©ºé—´å¹¶åˆå§‹åŒ–: *init(int);
å›æ”¶å†…å­˜ç©ºé—´ï¼švoid clear(que *);
é˜Ÿåˆ—æ‰©å®¹ï¼šint expand(que *);
é˜Ÿåˆ—åˆ¤ç©ºæ“ä½œï¼šint empty(que *);
å°¾éƒ¨å…ƒç´ å…¥é˜Ÿï¼šint push(que *, int);
å¤´éƒ¨å…ƒç´ å‡ºé˜Ÿï¼šint pop(que *);
æŸ¥çœ‹é˜Ÿé¦–å…ƒç´ ï¼šint front(que *);
æ‰“å°è¾“å‡ºé˜Ÿåˆ—çš„å…ƒç´ ï¼š void output(que *);
*/

queue *init(int);  
void clear(queue *);
int empty(queue *);
int front(queue *);
int push(queue *, int);
int expand(queue *);
int pop(queue *);
void output(queue *);

int main() {
    srand(time(0));
    #define max_op 20
    queue *que = init(max_op);
    for (int i = 0; i &amp;lt; max_op * 2; ++i) {
        int val = rand() % 100;
        int op = rand() % 4;
        switch(op) {
            case 0:
            case 1:
            case 2: {
                printf(&amp;quot;push %d to the Queue = %d\n&amp;quot;, val, push(que, val));
            } break;
            case 3: {
                printf(&amp;quot;pop %d from the Queu = &amp;quot;, front(que));
                printf(&amp;quot;%d\n&amp;quot;, pop(que));
            }
        }
        output(que);
    } 
    clear(que);
    #undef max_op
    return 0;
}

queue *init(int n) {
    queue *que = (queue *)malloc(sizeof(queue));
    que-&amp;gt;data = (int *)malloc(sizeof(int) * n);
    que-&amp;gt;size = n;
    que-&amp;gt;head = que-&amp;gt;tail = que-&amp;gt;count = 0;
    return que;
}

void clear(queue *que) {
    if (que == NULL) return ;
    free(que-&amp;gt;data);
    free(que);
    return ;
}

int empty(queue *que) {
    return que-&amp;gt;count == 0;
}

int front(queue *que) {
    return que-&amp;gt;data[que-&amp;gt;head];
}

int push(queue *que, int val) {
    if (que == NULL) return 0;
    if (que-&amp;gt;count &amp;gt;= que-&amp;gt;size) {
        if (!expand(que)) return 0;
        printf(GREEN(&amp;quot;expand successfully! queue-&amp;gt;size(%d)&amp;quot;) &amp;quot;\n&amp;quot;, que-&amp;gt;size);
    }
    que-&amp;gt;data[que-&amp;gt;tail++] = val;
    if (que-&amp;gt;tail == que-&amp;gt;size) que-&amp;gt;tail = 0;
    que-&amp;gt;count++;
    return 1;
}

int expand(queue *que) {
    int ex_size = que-&amp;gt;size;
    int *p;
    while (ex_size) {
        p = (int *)malloc(sizeof(int) * (que-&amp;gt;size + ex_size));
        if (p) break;
        ex_size &amp;gt;&amp;gt;= 1;
    }
    if (p == NULL) return 0;
    // æŠŠåŸæ¥çš„å…ƒç´ å¤åˆ¶åˆ° P ä¸­
    for (int i = que-&amp;gt;head, j = 0; j &amp;lt; que-&amp;gt;size; ++j) {
        p[j] = que-&amp;gt;data[(i + j) % que-&amp;gt;size];
    }
    free(que-&amp;gt;data);
    que-&amp;gt;data = p; 
    que-&amp;gt;head = 0; 
    que-&amp;gt;tail = que-&amp;gt;count;
    que-&amp;gt;size += ex_size;
    return 1;
}

int pop(queue *que) {
    if (que == NULL) return 0;
    if (empty(que)) return 0;
    que-&amp;gt;head++;
    if (que-&amp;gt;head == que-&amp;gt;size) que-&amp;gt;head = 0;
    que-&amp;gt;count--;
    return 1;
}

void output(queue *que) {
    if (que == NULL) return ;
    printf(&amp;quot;Queue : [&amp;quot;);
    for (int i = que-&amp;gt;head, j = 0;j &amp;lt; que-&amp;gt;count; ++j) {
        j &amp;amp;&amp;amp; printf(&amp;quot;, &amp;quot;);
        printf(&amp;quot;%d&amp;quot;, que-&amp;gt;data[(i + j) % que-&amp;gt;size]);
    }
    printf(&amp;quot;]\n&amp;quot;);
    return ;
}


&lt;/code&gt;&lt;/pre&gt;
">BDS-3.é˜Ÿåˆ—</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/BDS-12.å¹¶æŸ¥é›†/"" data-c="
          &lt;h2 id=&#34;å¹¶æŸ¥é›†&#34;&gt;å¹¶æŸ¥é›†&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;time.h&amp;gt;

typedef struct UnionSet {
    int *data;
    int size;
} unionSet;

unionSet *init(int n) {
    unionSet *u = (unionSet *)malloc(sizeof(unionSet));
    u-&amp;gt;data = (int *)malloc(sizeof(int) * (n + 1));
    u-&amp;gt;size = n;
    for (int i = 1; i &amp;lt;= n; ++i) u-&amp;gt;data[i] = i;
    return u;
}

void clear(unionSet *u) {
    if (u == NULL) return ;
    free(u-&amp;gt;data);
    free(u);
    return ;
}

int find(unionSet *u, int x) {
    return x == u-&amp;gt;data[x] ? x : (u-&amp;gt;data[x] = find(u, u-&amp;gt;data[x]));
}

void union_find(unionSet *u, int a, int b) {
    int fa = find(u, a), fb = find(u, b);
    if (fa == fb) return ;
    u-&amp;gt;data[fa] = fb;
    return ;
}

int main() {

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
">BDS-12.å¹¶æŸ¥é›†</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/BDS-11.å †æ’åº/"" data-c="
          &lt;h2 id=&#34;å †æ’åº&#34;&gt;å †æ’åº&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;time.h&amp;gt;

#define SWAP(a, b) {\
    __typeof(a) _t = a;\
    a = b; b = _t;\
}
// çº¿æ€§å»ºå †ï¼Œï¼ˆè‡ªé¡¶å‘ä¸‹ï¼Œå’Œpopæ“ä½œä¸€æ ·ï¼‰
// ä¼ å…¥æ•°ç»„é¦–åœ°å€ï¼Œ è°ƒæ•´å¼€å§‹çš„ä½ç½®ï¼Œ æ•°ç»„å¤§å°
void nHeap(int *arr, int ind, int size) {
    while (ind &amp;lt;&amp;lt; 1 &amp;lt;= size) {
        int temp = ind, dl = ind &amp;lt;&amp;lt; 1, dr = ind &amp;lt;&amp;lt; 1 | 1;
        if (arr[temp] &amp;lt; arr[dl]) temp = dl;
        if (dr &amp;lt;= size &amp;amp;&amp;amp; arr[temp] &amp;lt; arr[dr]) temp = dr;
        if (temp == ind) break;
        SWAP(arr[ind], arr[temp]);
        ind = temp;
    }
    return ;
}
// å †æ’åº
void heap_sort(int *arr, int n) {
    arr -= 1; //arr = arr - 1æŠŠæ•°ç»„é¦–åœ°å€å·¦ç§»çš„ä¸€ä¸ªä½ç½®,å½“è®¿é—®arr[1] å…¶å®æ˜¯è®¿é—® arr[0]
    // ä»å€’æ•°ç¬¬äºŒæ’å¼€å§‹å»ºå †ï¼ˆä¸€ç›´å¾€å‰ï¼‰ï¼Œ å› ä¸ºå€’æ•°ç¬¬ä¸€æ’ä¸éœ€è¦ç»´æŒ
    for (int i = n &amp;gt;&amp;gt; 1; i &amp;gt; 0; --i) {
        nHeap(arr, i, n);
    }
    // ç¬¬ä¸€æ¬¡å»ºå †å®Œæ¯•ä¹‹åï¼Œæœ€å¤§ï¼ˆå°ï¼‰åœ¨å †é¡¶äº†
    for (int i = n; i &amp;gt; 0; --i) {
        // æŠŠæœ€åä¸€ä¸ªå…ƒç´ å’Œç¬¬ä¸€ä¸ªå…ƒç´ äº¤æ¢ï¼Œè¿™æ ·æœ€åä¸€ä¸ªå…ƒç´ å°±å˜æˆæœ€å¤§ï¼ˆå°ï¼‰äº†
        // ä¾æ¬¡ç±»æ¨
        SWAP(arr[i], arr[1]);
        // ä¿æŒå †çš„çŠ¶æ€ï¼Œä»ç¬¬ä¸€å…ƒç´ å¼€å§‹äº†ï¼Œ å…ƒç´ ä¸ªæ•°ä¹Ÿæ˜¯å‡ä¸€äº†
        nHeap(arr, 1, i - 1);
    }
    return ;
}

void output(int *arr, int n) {
    printf(&amp;quot;arr: [&amp;quot;);
    for (int i = 0; i &amp;lt; n; ++i) {
        i &amp;amp;&amp;amp; printf(&amp;quot;, &amp;quot;);
        printf(&amp;quot;%d&amp;quot;, arr[i]);
    }
    printf(&amp;quot;]\n&amp;quot;);
    return ;
}


int main() {
    #define maxn 10
    srand(time(0));
    int nums[maxn];
    for (int i = 0; i &amp;lt; maxn; ++i) {
        int val = rand() % 100;
        nums[i] = val;
    }
    output(nums, maxn);
    heap_sort(nums, maxn);
    output(nums, maxn);

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
">BDS-11.å †æ’åº</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/BDS-10.å †ä¼˜å…ˆé˜Ÿåˆ—/"" data-c="
          &lt;h2 id=&#34;å †ä¼˜å…ˆé˜Ÿåˆ—&#34;&gt;å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;time.h&amp;gt;

#define SWAP(a, b) {\
    __typeof(a) _t = a;\
    a = b; b = _t;\
}
// ç”¨é¡ºåºè¡¨å®ç°
/*
å¼€è¾Ÿå®¹å™¨ *data
å…ƒç´ ä¸ªæ•° cnt, å®¹å™¨å¤§å° size
*/  
typedef struct priority_queue {
    int *data;
    int cnt, size;
} priority_queue;

// å¼€è¾Ÿç©ºé—´å¹¶åˆå§‹åŒ–
priority_queue *init(int n) {
    priority_queue *q = (priority_queue *)malloc(sizeof(priority_queue));
    q-&amp;gt;data = (int *)malloc(sizeof(int) * (n + 1));
    q-&amp;gt;cnt = 0;
    q-&amp;gt;size = n;
    return q;
}
// å›æ”¶å†…å­˜ç©ºé—´
void clear(priority_queue *q) {
    if (q == NULL) return ;
    free(q-&amp;gt;data);
    free(q);
    return ;
}
// ä¼˜å…ˆé˜Ÿåˆ— åˆ¤ç©º
int empty(priority_queue *q) {
    return q-&amp;gt;cnt == 0;
}
// å †é¡¶å…ƒç´ 
int top(priority_queue *q) {
    return q-&amp;gt;data[1];
}
// å…¥å †
int push(priority_queue *q, int val) {
    if (q == NULL) return 0;
    if (q-&amp;gt;cnt == q-&amp;gt;size) return 0;
    q-&amp;gt;data[++(q-&amp;gt;cnt)] = val; // ä»é˜Ÿå°¾æ’å…¥å…ƒç´ ï¼ˆä»ç¬¬ä¸€ä¸ªå…ƒç´ å¼€å§‹æ’å…¥ï¼‰
    int ind = q-&amp;gt;cnt; 
    // è‡ªåº•å‘ä¸Šç»´æŠ¤ å †çš„çŠ¶æ€ 
    while (ind &amp;gt;&amp;gt; 1 &amp;amp;&amp;amp; q-&amp;gt;data[ind] &amp;gt; q-&amp;gt;data[ind &amp;gt;&amp;gt; 1]) {
        // ind / 2 &amp;gt;= 1 é˜²æ­¢è¶Šç•Œ
        // å¦‚æœå„¿å­å¤§äºçˆ¸çˆ¸ï¼Œå¾€ä¸Šæµ®
        SWAP(q-&amp;gt;data[ind], q-&amp;gt;data[ind &amp;gt;&amp;gt; 1]);
        ind &amp;gt;&amp;gt;= 1; // å‘ä¸Šä¼ é€’
    }
    return 1;
}
// å‡ºé˜Ÿ
int pop(priority_queue *q) {
    if (q == NULL) return 0;
    if (empty(q)) return 0;
    // ç”¨é˜Ÿå°¾å…ƒç´ æŠŠå †é¡¶å…ƒç´ è¦†ç›–ï¼Œå¹¶å…ƒç´ ä¸ªæ•°å‡ä¸€
    q-&amp;gt;data[1] = q-&amp;gt;data[(q-&amp;gt;cnt)--];
    // è‡ªé¡¶å‘ä¸‹ ç»´æŠ¤ å †çš„çŠ¶æ€
    int ind = 1;
    // ind ä»1å¼€å§‹ï¼Œ ind * 2 &amp;lt;= cnt(å…ƒç´ ä¸ªæ•°)
    while (ind &amp;lt;&amp;lt; 1 &amp;lt;= q-&amp;gt;cnt) {
        int temp = ind, dl = ind &amp;lt;&amp;lt; 1, dr = ind &amp;lt;&amp;lt; 1 | 1;
        // çˆ¸çˆ¸å…ˆè·Ÿå·¦å­©å­æ¯”è¾ƒï¼Œæ»¡è¶³æ¡ä»¶çš„è¯ï¼Œäº¤æ¢ä¸€ä¸‹
        // å’Œå·¦å­©å­æ¯”è¾ƒå®Œåï¼Œå†ä¸å³å­©å­æ¯”è¾ƒï¼Œæ»¡è¶³æ¡ä»¶çš„è¯ï¼Œäº¤æ¢ä¸€ä¸‹
        // æ³¨æ„å³å­©å­çš„ ind * 2 + 1 &amp;lt;= cnt(å…ƒç´ ä¸ªæ•°)ï¼Œä¹Ÿä¸èƒ½è¶Šç•Œ
        if (q-&amp;gt;data[temp] &amp;lt; q-&amp;gt;data[dl]) temp = dl;
        if (dr &amp;lt;= q-&amp;gt;cnt &amp;amp;&amp;amp; q-&amp;gt;data[temp] &amp;lt; q-&amp;gt;data[dr]) temp = dr;
        if (temp == ind) break; // å¦‚æœéƒ½æ²¡æœ‰äº¤æ¢ï¼Œè¯´æ˜æ»¡è¶³å †çš„çŠ¶æ€ï¼Œç›´æ¥ç»“æŸ
        SWAP(q-&amp;gt;data[ind], q-&amp;gt;data[temp]); // çœŸæ­£çš„äº¤æ¢æ“ä½œ
        ind = temp; // å‘ä¸‹ä¼ é€’
    }
    return 1;
}

int main() {
    #define maxn 10 
    srand(time(0));
    priority_queue *q = init(maxn);
    printf(&amp;quot;push: &amp;quot;);
    for (int i = 0; i &amp;lt; maxn; ++i) {
        int val = rand() % 100;
        printf(&amp;quot;%d &amp;quot;, val);
        push(q, val);
    }
    printf(&amp;quot;\npop: &amp;quot;);
    for (int i = 0; i &amp;lt; maxn; ++i) {
        printf(&amp;quot;%d &amp;quot;, top(q));
        pop(q);
    }
    printf(&amp;quot;\n&amp;quot;);
    clear(q);
    #undef maxn
    return 0;
}


&lt;/code&gt;&lt;/pre&gt;
">BDS-10.å †ä¼˜å…ˆé˜Ÿåˆ—</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/BDS-8.ç¨³å®šæ’åº/"" data-c="
          &lt;h2 id=&#34;ç¨³å®šæ’åº&#34;&gt;ç¨³å®šæ’åº&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;time.h&amp;gt;

#define swap(a, b) {\
    __typeof(a) _temp = a;\
    a = b;\
    b = _temp;\
}

#define TEST(arr, n, func, args...) {\
    int *num = (int *)malloc(sizeof(int) * n);\
    memcpy(num, arr, sizeof(int) * n);\
    output(num, n);\
    printf(&amp;quot;%s = &amp;quot;, #func);\
    func(args);\
    output(num, n);\
    free(num);\
}
// å†’æ³¡æ’åº
/* å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO(n^2)
å‰ï¼šå¾…æ’åºåŒºï¼› åï¼šå·²æ’åºåŒº
ä¼˜åŒ–ç‚¹ï¼šå½“æŸä¸€è½®å†’æ³¡æ²¡æœ‰äº¤æ¢æ“ä½œï¼Œè¯´æ˜å·²æ’åºå®Œæˆï¼Œå¯ä»¥ç›´æ¥ç»“æŸ
æœ€åæ—¶é—´å¤æ‚åº¦ï¼šå®Œå…¨é€†åº O(n^2)
**æ’å…¥æ’åºå¯ç†è§£ä¸ºæ–¹å‘å†’æ³¡
*/
void bubble_sort(int *num, int n) {
    int flag = 1; // æ ‡è®°
    // n-1è½®å†’æ³¡
    for (int i = 1; i &amp;lt; n &amp;amp;&amp;amp; flag == 1; ++i) {
        flag = 0;  // ä¸äº¤æ¢æ—¶ï¼Œæ ‡è®°0
        for (int j = 0; j &amp;lt; n - i; ++j) {
            // æ•°å€¼å¤§çš„å…ƒç´ å¾€åå†’æ³¡
            if (num[j] &amp;gt; num[j+1]) {
                swap(num[j], num[j+1]);
                flag = 1; // æœ‰äº¤æ¢ï¼Œæ ‡è®°1
            }
        }
    }
    return ;
}

// æ’å…¥æ’åº
/*å¹³å‡å¤æ‚åº¦O(n^2)
å‰ï¼šå·²æ’åºåŒºï¼› åï¼šå¾…æ’åºåŒº
æ³¨æ„ï¼šå¿…é¡»ä¸€ä¸ªä¸€ä¸ªæ¯”è¾ƒäº¤æ¢ï¼Œå†æ’å…¥
*/
void insert_sort(int *num, int n) {
    // n-1è½®æ’å…¥
    for (int i = 1; i &amp;lt; n; ++i ) {
        for (int j = i; j &amp;gt; 0; --j) {
            // åé¢å…ƒç´ æ¯”å‰é¢å°ï¼Œå¾€å‰äº¤æ¢ä½ç½®
            if (num[j] &amp;lt; num[j-1]) {
                swap(num[j], num[j-1]);
            }
        }
    }
    return ;
}
// å½’å¹¶æ’åº
/*
ç¨³å®šæ’åº
å…ˆåˆ†æ²»åˆ°ä¸¤ä¸¤å¯ä»¥æ¯”è¾ƒå¤§å°ï¼Œå†æŠŠæœ‰åºçš„æ•°ç»„ä¸¤ä¸¤åˆå¹¶
æ—¶é—´å¤æ‚åº¦(æœ€ä¼˜ï¼Œæœ€å·®ï¼Œå¹³å‡):Oï¼ˆnlognï¼‰
åˆ†æ²»lognå±‚ï¼Œæ¯å±‚åˆå¹¶æ—¶é—´ä¸ºO(n)
*/
void merge_sort(int *num, int l, int r) {
    // åˆ†æ²»é€’å½’å‡ºå£ï¼ˆå½“å…ƒç´ åªæœ‰ä¸€ä¸ªæˆ–ä¸¤ä¸ªï¼‰
    if (r - l &amp;lt;= 1) {
        // å½“æœ‰ä¸¤ä¸ªæ—¶ï¼Œå·¦è¾¹å…ƒç´ å¤§äºå³è¾¹æ—¶ï¼Œäº¤æ¢ä½ç½®
        if (r - l == 1 &amp;amp;&amp;amp; num[l] &amp;gt; num[r]) {
            swap(num[l], num[r]);
        }
        return ;
    }
    int mid = (l + r) &amp;gt;&amp;gt; 1; // åˆ†æ²»æ“ä½œï¼Œå¹³å‡åˆ†
    merge_sort(num, l, mid); // å·¦è¾¹éƒ¨åˆ†æ”¾å…¥é€’å½’
    merge_sort(num, mid + 1, r); // å³è¾¹éƒ¨åˆ†æ”¾å…¥é€’å½’
    // åˆ†æ²»åï¼Œl ~ mid, å’Œ mid + 1 ~ r,è¿™ä¸¤ä¸ªåŒºé—´åˆ†åˆ«æœ‰åºçš„
    // ä¸‹é¢å¼€å§‹åˆå¹¶æ“ä½œï¼Œå…ˆç”³è¯·r-l+1å¤§å°çš„ç©ºé—´
    int *temp = (int *)malloc(sizeof(int) * (r-l+1));
    // ç»™å·¦è¾¹åŒºé—´ p1æŒ‡é’ˆï¼Œ å³è¾¹åŒºé—´ p2æŒ‡é’ˆï¼ŒKæ˜¯åˆå¹¶ååŒºé—´çš„æŒ‡é’ˆ
    int p1 = l, p2 = mid + 1, k = 0;
    while (p1 &amp;lt;= mid || p2 &amp;lt;= r) {
        if (p2 &amp;gt; r || (p1 &amp;lt;= mid &amp;amp;&amp;amp; num[p1] &amp;lt;= num[p2])) {
            temp[k++] = num[p1++];
        } else {
            temp[k++] = num[p2++];
        }
    }
    // æŠŠåˆå¹¶åçš„temp æ‹·è´å›æ¥ï¼Œ num + l æ˜¯é¦–åœ°å€
    memcpy(num + l, temp, sizeof(int) * (r-l+1));
    free(temp); // å›æ”¶tempå†…å­˜ç©ºé—´
    return ;

}

void randint(int *num, int n) {
    while (n--) num[n] = rand() % 100;
    return ;
}

void output(int *num, int n) {
    printf(&amp;quot;[&amp;quot;);
    for (int i = 0; i &amp;lt; n; ++i) {
        printf(&amp;quot; %d&amp;quot;, num[i]);
    }
    printf(&amp;quot;]\n&amp;quot;);
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    int arr[max_op];
    randint(arr, max_op);
    TEST(arr, max_op, bubble_sort, num, max_op);
    TEST(arr, max_op, insert_sort, num, max_op);
    TEST(arr, max_op, merge_sort, num, 0, max_op - 1);
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
">BDS-8.ç¨³å®šæ’åº</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/BDS-7.ä¸ç¨³å®šæ’åº/"" data-c="
          &lt;h2 id=&#34;ä¸ç¨³å®šæ’åº&#34;&gt;ä¸ç¨³å®šæ’åº&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;time.h&amp;gt;

#define SWAP(a, b) {\
    __typeof(a) _t = a;\
    a = b; b = _t;\
}

#define COLOR(a, b) &amp;quot;\e[&amp;quot; #b &amp;quot;m&amp;quot; a &amp;quot;\e[0m&amp;quot;
#define GREEN(a) COLOR(a, 32)

#define TEST(arr, n, func, args...) {\
    int *num = (int *)malloc(sizeof(int) * n);\
    memcpy(num, arr, sizeof(int) * n);\
    output(num, n);\
    printf(&amp;quot;%s: &amp;quot;, #func);\
    func(args);\
    output(num, n);\
    printf(&amp;quot;\n&amp;quot;);\
    free(num);\
}
// é€‰æ‹©æ’åº
/* æ—¶é—´å¤æ‚åº¦ï¼ˆæœ€ä¼˜ï¼Œæœ€åï¼Œå¹³å‡ï¼‰O(n^2)
å‰ï¼šå·²æ’åºï¼Œåï¼šå¾…æ’åº
ä¸ç¨³å®šï¼šä¾‹å¦‚ 22&#39;1 ç¬¬ä¸€æ¬¡å 12&#39;2
æ¯è½®æ‰¾ä¸€ä¸ªæœ€å°çš„å…ƒç´ ï¼Œä¸å¾…æ’åºåŒºçš„ç¬¬ä¸€ä¸ªå…ƒç´ äº¤æ¢
*/
void select_sort(int *nums, int n) {
    for (int i = 0; i &amp;lt; n - 1; ++i) {
        int ind = i;
        for (int j = i; j &amp;lt; n; ++j) {
            if (nums[j] &amp;lt; nums[ind]) ind = j;
        }
        SWAP(nums[i], nums[ind]);
    }
    return ;
}
// åŸºç¡€å¿«æ’
/*æ—¶é—´å¤æ‚åº¦ï¼šO(NlogN)
æ‹¿ç¬¬ä¸€ä¸ªå…ƒç´ ä½œä¸ºåŸºå‡†å€¼
é€†åºæ•°åˆ—é€‰ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºåŸºå‡†å€¼æ—¶ï¼Œé€€åŒ–ä¸ºé€‰æ‹©æ’åºï¼ŒOï¼ˆn^2ï¼‰
*/
void quick_sort1(int *nums, int l, int r) {
    if (l &amp;gt;= r) return ;
    int x = l, y = r, z = nums[x];
    while (x &amp;lt; y) {
        while (x &amp;lt; y &amp;amp;&amp;amp; nums[y] &amp;gt; z) y--;
        if (x &amp;lt; y) nums[x++] = nums[y];
        while (x &amp;lt; y &amp;amp;&amp;amp; nums[x] &amp;lt; z) x++;
        if (x &amp;lt; y) nums[y--] = nums[x];
    }
    nums[x] = z;
    quick_sort1(nums, l, x - 1);
    quick_sort1(nums, x + 1, r);
    return ;
}
// ä¼˜åŒ–åçš„å¿«æ’
void quick_sort2(int *nums, int l, int r) {
    // ä¼˜åŒ–1ï¼Œå‡å°‘ä¸€åŠé€’å½’ï¼Œå¢åŠ å¾ªç¯
    // å·¦åŠè¾¹ç”¨å¾ªç¯ï¼Œ å³åŠè¾¹ç”¨é€’å½’
    while (l &amp;lt; r) { 
        // ä¼˜åŒ–2 åŸºå‡†å€¼é€‰ä¸­é—´å€¼
        int x = l, y = r, z = nums[(l + (r - l) / 2)];
        do {
            // ä¼˜åŒ–3ï¼šä¸¤ä¸ªæŒ‡é’ˆéƒ½å»æ‰¾å€¼ï¼Œå¹¶äº¤æ¢
            // å…³é”®ï¼šx &amp;lt;= y,è¦ç”¨ &amp;lt;= åé¢å°† x,yé”™å¼€
            // num[] &amp;lt; z,è¦ç”¨&amp;lt; , ç»è¿‡åŸºå‡†å€¼è¦åœä¸‹
            while (x &amp;lt;= y &amp;amp;&amp;amp; nums[x] &amp;lt; z) x++;
            while (x &amp;lt;= y &amp;amp;&amp;amp; z &amp;lt; nums[y]) y--;
            if (x &amp;lt;= y) {
                // äº¤æ¢åï¼Œä¸¤ä¸ªæŒ‡é’ˆéƒ½è¦ç§»åŠ¨ä¸€ä¸‹ï¼Œäº¤é”™ï¼Œyåˆ°å‰é¢ï¼Œxåˆ°åé¢
                SWAP(nums[x], nums[y]);
                x++, y--; 
            }
        } while (x &amp;lt;= y); // æ­¤å¤„ ç”¨å°äºæˆ–å°äºç­‰äºéƒ½å¯ä»¥
        quick_sort2(nums, x, r); // å³åŠéƒ¨åˆ†é€’å½’
        r = y; // l ~ y å·¦åŠéƒ¨åˆ†å¾ªç¯
    }
    return ;
}

void randArr(int *nums, int n) {
    while (n--) nums[n] = rand() % 100;
    return ;
}

void output(int *nums, int n) {
    printf(&amp;quot;arr: [&amp;quot;);
    for (int i = 0; i &amp;lt; n; ++i) {
        i &amp;amp;&amp;amp; printf(&amp;quot;, &amp;quot;);
        printf(&amp;quot;%d&amp;quot;, nums[i]);
    }
    printf(&amp;quot;]\n&amp;quot;);
    return ;
}

int main() {
    srand(time(0));
    #define maxn 100
    clock_t start, end, end2;
    int arr[maxn];
    start = clock();
    TEST(arr, maxn, select_sort, num, maxn);
    randArr(arr, maxn);
    TEST(arr, maxn, quick_sort1, num, 0, maxn - 1);
    end = clock();
    printf(GREEN(&amp;quot;time : %lf\n&amp;quot;), (double)(end - start) / ((clock_t)(1000)));
    TEST(arr, maxn, quick_sort2, num, 0, maxn - 1);
    end2 = clock();
    printf(GREEN(&amp;quot;time : %lf\n&amp;quot;), (double)(end2 - end) / ((clock_t)(1000)));
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
">BDS-7.ä¸ç¨³å®šæ’åº</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/BDS-6.å¹¿ä¹‰è¡¨äºŒå‰æœç´¢æ ‘/"" data-c="
          &lt;h2 id=&#34;å¹¿ä¹‰è¡¨è½¬äºŒå‰æ ‘binary_tree&#34;&gt;å¹¿ä¹‰è¡¨è½¬äºŒå‰æ ‘ï¼ˆbinary_treeï¼‰&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

typedef struct Node{
    char data;
    struct Node *lchild, *rchild;
} Node;

typedef struct Tree{
    Node *root;
    int n;
} Tree; 

typedef struct Stack{
    Node **data;
    int top, size;
} Stack;

Node *getnewNode(char val) {
    Node *node = (Node *)malloc(sizeof(Node));
    node-&amp;gt;data = val;
    node-&amp;gt;lchild = node-&amp;gt;rchild = NULL;
    return node;
}

Tree *getTree() {
    Tree *tree = (Tree *)malloc(sizeof(Tree));
    tree-&amp;gt;root = NULL;
    tree-&amp;gt;n = 0;
    return tree;
}

Stack *init(int n) {
    Stack *s = (Stack *)malloc(sizeof(Stack));
    s-&amp;gt;data = (Node **)malloc(sizeof(Node *) * n);
    s-&amp;gt;size = n;
    s-&amp;gt;top = -1;
    return s;
}

void clear_stack(Stack *s) {
    if (s == NULL) return ;
    free(s-&amp;gt;data);
    free(s);
    return ;
}

void clear_node(Node *node) {
    if (node == NULL) return ;
    clear_node(node-&amp;gt;lchild);
    clear_node(node-&amp;gt;rchild);
    free(node);
    return ;
}

void clear_tree(Tree *t) {
    if (t == NULL) return ;
    clear_node(t-&amp;gt;root);
    free(t);
    return ;
}

int empty(Stack *s) {
    return s-&amp;gt;top == -1;
}

Node *top(Stack *s) {
    return s-&amp;gt;data[s-&amp;gt;top];
}

int push(Stack *s, Node *val) {
    if (s == NULL) return 0;
    if (s-&amp;gt;top &amp;gt;= s-&amp;gt;size - 1) return 0;
    s-&amp;gt;data[++(s-&amp;gt;top)] = val;
    return 1;

}

int pop(Stack *s) {
    if (s == NULL) return 0;
    if (empty(s)) return 0;
    s-&amp;gt;top--;
    return 1;
}

Node *build(const char *str, int *node_count) {
    Stack *s = init(strlen(str));
    Node *temp = NULL, *p = NULL;
    int flag = 0;
    while(str[0]) {
        switch(str[0]) {
            case &#39;(&#39;: {
                push(s, temp);
                flag = 0;
            } break;
            case &#39;)&#39;: {
                p = top(s);
                pop(s);
            } break;
            case &#39;,&#39;: {
                flag = 1;
            } break;
            case &#39; &#39;: break;
            default:
                temp = getnewNode(str[0]);
            if (!empty(s) &amp;amp;&amp;amp; flag == 0) {
                top(s)-&amp;gt;lchild = temp;
            } else if (!empty(s) &amp;amp;&amp;amp; flag == 1) {
                top(s)-&amp;gt;rchild = temp;
            }
            *node_count++;
            break;
        }
        str++;
    }
    if (temp &amp;amp;&amp;amp; !p) p = temp;
    return p;
}

void pre_order_node(Node *node) {
    if (node == NULL) return ;
    printf(&amp;quot;%c&amp;quot;, node-&amp;gt;data);
    pre_order_node(node-&amp;gt;lchild);
    pre_order_node(node-&amp;gt;rchild);
    return ;
}

void pre_order(Tree *t) {
    if (t == NULL) return ;
    printf(&amp;quot;pre_order : &amp;quot;);
    pre_order_node(t-&amp;gt;root);
    printf(&amp;quot;\n&amp;quot;);
    return ; 
}

void in_order_node(Node *node) {
    if (node == NULL) return ;
    in_order_node(node-&amp;gt;lchild);
    printf(&amp;quot;%c&amp;quot;, node-&amp;gt;data);
    in_order_node(node-&amp;gt;rchild);
    return ;
}

void in_order(Tree *t) {
    if (t == NULL) return ;
    printf(&amp;quot;in_order : &amp;quot;);
    in_order_node(t-&amp;gt;root);
    printf(&amp;quot;\n&amp;quot;);
    return ;
    
}
void post_order_node(Node *node) {
    if (node == NULL) return ;
    post_order_node(node-&amp;gt;lchild);
    post_order_node(node-&amp;gt;rchild);
    printf(&amp;quot;%c&amp;quot;, node-&amp;gt;data);
    return ;
}

void post_order(Tree *t) {
    if (t == NULL) return ;
    printf(&amp;quot;post_order : &amp;quot;);
    post_order_node(t-&amp;gt;root);
    printf(&amp;quot;\n&amp;quot;);
    return ;
    
}
int main() {
    char str[1000] = {0};
    int node_count = 0;
    scanf(&amp;quot;%[^\n]s&amp;quot;, str);
    Tree *tree = getTree();
    tree-&amp;gt;root = build(str, &amp;amp;node_count);
    tree-&amp;gt;n = node_count;
    pre_order(tree);
    in_order(tree);
    post_order(tree);
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
">BDS-6.å¹¿ä¹‰è¡¨äºŒå‰æœç´¢æ ‘</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/BDS-5.äºŒå‰æœç´¢æ ‘/"" data-c="
          &lt;h2 id=&#34;äºŒå‰æ ‘binary_tree&#34;&gt;äºŒå‰æ ‘ï¼ˆbinary_treeï¼‰&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;time.h&amp;gt;

//ç»“æ„å®šä¹‰
/*
ç»“ç‚¹+è¾¹
é“¾è¡¨ç»“æ„æ˜¯ä¸€å‰æ ‘ï¼Œåªæœ‰ä¸€ä¸ªåˆ†æ”¯çš„æ ‘å½¢ç»“æ„
å¯¹äºä¸‰å‰æ ‘ï¼Œå°†é“¾è¡¨çš„nextæŒ‡é’ˆå˜æˆnext[3]æŒ‡é’ˆæ•°ç»„å³å¯ï¼Œå…¶ä»–ç±»æ¯”
äºŒå‰æ ‘ç»“ç‚¹å­˜å‚¨å…ƒç´ ï¼šdata
äºŒå‰æ ‘ä¸¤æ¡è¾¹ï¼šlchild, rchild
*/
typedef struct Node{
    int data;
    struct Node *lchild, *rchild;
} Node;
// å°è£…æˆæ ‘ï¼Œè™šæ‹Ÿå¤´èŠ‚ç‚¹rootï¼Œç»“ç‚¹ä¸ªæ•°n
typedef struct Tree{
    Node *root;
    int n;
} Tree;

Node *init_node(int); // åŠ¨æ€ç”³è¯·å†…å­˜ç©ºé—´ï¼Œæ„é€ æ–°ç»“ç‚¹
Tree *init_tree();  // æ„é€ æ ¹èŠ‚ç‚¹ï¼Œå°è£…æˆæ ‘
void clear_node(Node *); // ç»“ç‚¹å†…å­˜å›æ”¶
void clear_tree(Tree *); // æ ‘å†…å­˜å›æ”¶
Node *insert_node(Node *, int , int*); // æ’å…¥ç»“ç‚¹
void insert(Tree *, int); // å°è£…æ’å…¥æ“ä½œ
void pre_order_node(Node *); // å‰åºéå†
void pre_order(Tree *);
void in_order_node(Node *);// ä¸­åºéå†
void in_order(Tree *);
void post_order_node(Node *);// ååºéå†
void post_order(Tree *);
void output_node(Node *); // æ‰“å°è¾“å‡º
void output(Tree *);

int main() {
    srand(time(0));
    #define max_op 10
    Tree *tree = init_tree();
    for (int i = 0; i &amp;lt; max_op; ++i) {
        int val = rand() % 100;
        insert(tree, val);
        output(tree);
    }
    pre_order(tree);
    in_order(tree);
    post_order(tree);
    return 0;
}

Node *init_node(int val) {
    Node *node = (Node *)malloc(sizeof(Node));
    node-&amp;gt;data = val;
    node-&amp;gt;lchild = node-&amp;gt;rchild = NULL;
    return node;
}

Tree *init_tree() {
    Tree *tree = (Tree *)malloc(sizeof(Tree));
    tree-&amp;gt;root = NULL;
    tree-&amp;gt;n = 0;
    return tree;
}

void clear_node(Node *node) {
    if (node == NULL) return ;
    clear_node(node-&amp;gt;lchild);
    clear_node(node-&amp;gt;rchild);
    free(node);
    return ;
}

void clear_tree(Tree * tree) {
    if (tree == NULL) return ;
    clear_node(tree-&amp;gt;root);
    free(tree);
    return ;
}

Node *insert_node(Node *root, int val, int *flag) {
    if (root == NULL) {
        *flag = 1;
        return init_node(val);
    }
    if (root-&amp;gt;data == val) return root;
    if (root-&amp;gt;data &amp;gt; val) root-&amp;gt;lchild = insert_node(root-&amp;gt;lchild, val, flag);
    else root-&amp;gt;rchild = insert_node(root-&amp;gt;rchild, val, flag);
}

void insert(Tree *tree, int val) {
    if (tree == NULL) return ;
    int flag = 0;
    tree-&amp;gt;root = insert_node(tree-&amp;gt;root, val, &amp;amp;flag);
    tree-&amp;gt;n += flag;
    return ;
}

void pre_order_node(Node *node) {
    if (node == NULL) return ;
    printf(&amp;quot;%d &amp;quot;, node-&amp;gt;data);
    pre_order_node(node-&amp;gt;lchild);
    pre_order_node(node-&amp;gt;rchild);
    return ;
}

void pre_order(Tree *tree) {
    if (tree == NULL) return ;
    printf(&amp;quot;pre_order : &amp;quot;);
    pre_order_node(tree-&amp;gt;root);
    printf(&amp;quot;\n&amp;quot;);
    return ;
}

void in_order_node(Node *node) {
    if (node == NULL) return ;
    in_order_node(node-&amp;gt;lchild);
    printf(&amp;quot;%d &amp;quot;, node-&amp;gt;data);
    in_order_node(node-&amp;gt;rchild);
    return ;
}

void in_order(Tree *tree) {
    if (tree == NULL) return ;
    printf(&amp;quot;in_order : &amp;quot;);
    in_order_node(tree-&amp;gt;root);
    printf(&amp;quot;\n&amp;quot;);
    return ;
}
void post_order_node(Node *node) {
    if (node == NULL) return ;
    post_order_node(node-&amp;gt;lchild);
    post_order_node(node-&amp;gt;rchild);
    printf(&amp;quot;%d &amp;quot;, node-&amp;gt;data);
    return ;
}

void post_order(Tree *tree) {
    if (tree == NULL) return ;
    printf(&amp;quot;post_order : &amp;quot;);
    post_order_node(tree-&amp;gt;root);
    printf(&amp;quot;\n&amp;quot;);
    return ;
}

void output_node(Node *node) {
    if (node == NULL) return ;
    printf(&amp;quot;%d&amp;quot;, node-&amp;gt;data);
    if (node-&amp;gt;lchild == NULL &amp;amp;&amp;amp; node-&amp;gt;rchild == NULL) return ;
    printf(&amp;quot;(&amp;quot;);
    output_node(node-&amp;gt;lchild);
    printf(&amp;quot;,&amp;quot;);
    output_node(node-&amp;gt;rchild);
    printf(&amp;quot;)&amp;quot;);
    return ;
}

void output(Tree *tree) {
    if (tree == NULL) return ;
    printf(&amp;quot;Tree(%d) : &amp;quot;, tree-&amp;gt;n);
    output_node(tree-&amp;gt;root);
    printf(&amp;quot;\n&amp;quot;);
    return ;
}

&lt;/code&gt;&lt;/pre&gt;
">BDS-5.äºŒå‰æœç´¢æ ‘</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/BDS-4.æ ˆ/"" data-c="
          &lt;h2 id=&#34;æ ˆstack&#34;&gt;æ ˆï¼ˆStackï¼‰&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;time.h&amp;gt;


// ç»“æ„å®šä¹‰
/*
åŠ¨æ€ç”³è¯·å†…å­˜ç©ºé—´å­˜å‚¨å…ƒç´ çš„å®¹å™¨ï¼šdata
æ ˆå®¹å™¨çš„å¤§å°ï¼šsize
æ ˆé¡¶ï¼štop
*/
typedef struct stack {
    int *data;
    int size, top;
} stack;

stack *init(int); // ç”³è¯·å†…å­˜ç©ºé—´å¹¶åˆå§‹åŒ–
void clear(stack *); // å›æ”¶å†…å­˜ç©ºé—´
int top(stack *); // æŸ¥çœ‹æ ˆé¡¶å…ƒç´ 
int empty(stack *); // æ ˆå®¹å™¨åˆ¤ç©º
int expand(stack *); // æ ˆå®¹å™¨æ‰©å®¹
int push(stack *, int); // æ ˆé¡¶å‹å…¥å…ƒç´ 
int pop(stack *); // æ ˆé¡¶å¼¹å‡ºå…ƒç´ 
void output(stack *); // æ‰“å°è¾“å‡ºæ ˆå®¹å™¨çš„å…ƒç´ 

int main() {
    srand(time(0));
    #define max_op 20
    stack *s = init(max_op);
    for (int i = 0; i &amp;lt; max_op; ++i) {
        int op = rand() % 4;
        int val = rand() % 100;
        switch(op) {
            case 0:
            case 1:
            case 2: {
                printf(&amp;quot;push %d to the Stack = %d\n&amp;quot;, val, push(s, val));
            } break;
            case 3: {
                printf(&amp;quot;pop %d from the Stack =&amp;quot;, top(s));
                printf(&amp;quot;%d\n&amp;quot;, pop(s));
            } break;
        }
        output(s);
        printf(&amp;quot;\n&amp;quot;);
    }
    clear(s);
    #undef max_op
    return 0;
}

stack *init(int n) {
    stack *s = (stack *)malloc(sizeof(stack));
    s-&amp;gt;data = (int *)malloc(sizeof(int) * n);
    s-&amp;gt;size = n;
    s-&amp;gt;top = -1;
    return s;
}

void clear(stack *s) {
    if (s == NULL) return ;
    free(s-&amp;gt;data);
    free(s);
    return ;
}

int empty(stack *s) {
    return s-&amp;gt;top == -1;
}

int top(stack *s) {
    return s-&amp;gt;data[s-&amp;gt;top];
}

int expand(stack *s) {
    int ex_size = s-&amp;gt;size;
    int *p;
    while (ex_size) {
        p = (int *)realloc(s-&amp;gt;data, sizeof(int) * (ex_size + s-&amp;gt;size));
        if (p) break;
        ex_size &amp;gt;&amp;gt;= 1;
    }
    if (ex_size == 0) return 0;
    s-&amp;gt;data = p;
    s-&amp;gt;size += ex_size;
    return 1;
}

int push(stack *s, int val) {
    if (s == NULL) return 0;
    if (s-&amp;gt;top &amp;gt;= s-&amp;gt;size - 1) {
        if (!expand(s)) return 0;
    }
    if (s-&amp;gt;top &amp;gt;= s-&amp;gt;size - 1) return 0;
    s-&amp;gt;data[++(s-&amp;gt;top)] = val;
    return 1;
}

int pop(stack *s) {
    if (s == NULL) return 0;
    if (empty(s)) return 0;
    s-&amp;gt;top--;
    return 1;
}

void output(stack *s) {
    printf(&amp;quot;Stack(%d) = [&amp;quot;, s-&amp;gt;top + 1);
    for (int i = 0; i &amp;lt;= s-&amp;gt;top; ++i) {
        i &amp;amp;&amp;amp; printf(&amp;quot; &amp;quot;);
        printf(&amp;quot;%d&amp;quot;, s-&amp;gt;data[i]);
    }
    printf(&amp;quot;]\n&amp;quot;);
    return ;
}


&lt;/code&gt;&lt;/pre&gt;
">BDS-4.æ ˆ</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/BDS-2.é“¾è¡¨/"" data-c="
          &lt;h2 id=&#34;é“¾è¡¨linklist&#34;&gt;é“¾è¡¨ï¼ˆLinkListï¼‰&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;time.h&amp;gt;

#define COLOR(a, b) &amp;quot;\e[&amp;quot; #b &amp;quot;m&amp;quot; a &amp;quot;\e[0m&amp;quot;
#define GREEN(a) COLOR(a, 32)


// é“¾è¡¨ç»“æ„èŠ‚ç‚¹å®šä¹‰
/*
data:  æ•°æ®åŸŸï¼ˆå­˜å‚¨æ•°æ®ï¼‰
*next: æŒ‡é’ˆåŸŸï¼ˆæœ€åä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆåŸŸä¸ºNULLï¼‰
*/
typedef struct LinkNode {
    int data;
    struct LinkNode *next;
} Node;

// é“¾è¡¨ç»“æ„å®šä¹‰
/*
head: ç»™é“¾è¡¨åŠ ä¸€ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹(é™æ€åˆ†é…)ï¼Œæ¯”è¾ƒç¨³å®šä¸éœ€è¦free
æ²¡æœ‰è™šæ‹Ÿå¤´èŠ‚ç‚¹çš„è¯ï¼Œéœ€è¦ä½œç‰¹åˆ¤ï¼ˆå½“æ’å…¥çš„ind == 0æ—¶ï¼‰
1.æœ‰è™šæ‹Ÿå¤´èŠ‚ç‚¹å¯ä»¥ä¸€ç›´å¾€åæ’
2.é˜²æ­¢å•é“¾è¡¨æ˜¯ç©ºçš„è€Œè®¾çš„ï¼Œå½“é“¾è¡¨ä¸ºç©ºæ—¶ï¼Œå¤´èŠ‚ç‚¹çš„å¤´æŒ‡é’ˆæŒ‡å‘å¤´èŠ‚ç‚¹
length: è®°å½•é“¾è¡¨çš„é•¿åº¦
*/

typedef struct LinkList {
    Node head;
    int length;
} List;

/*
é“¾è¡¨ç»“æ„æ“ä½œ
èŠ‚ç‚¹åˆå§‹åŒ–ï¼šNode *getNewNode(int);
é“¾è¡¨åˆå§‹åŒ–ï¼šList *getLinkList();
èŠ‚ç‚¹å†…å­˜å›æ”¶ï¼šclear_node(Node *);
é“¾è¡¨å†…å­˜å›æ”¶ï¼šclear(List *);
å¢ï¼šèŠ‚ç‚¹æ’å…¥ï¼Œinsert(List *, int, int);(ç»™å®šä½ç½®æ’å…¥å€¼)
åˆ ï¼šèŠ‚ç‚¹åˆ é™¤ï¼Œeraseï¼ˆList *ï¼Œ intï¼‰;(ç»™å®šä½ç½®åˆ é™¤å€¼)
æ‰“å°è¾“å‡ºé“¾è¡¨ï¼šoutput(List *);
ç¿»è½¬é“¾è¡¨ï¼šreverse(List *);
*/

Node *getNewNode(int);
List *getLinkList();
void clear_node(Node*);
void clear(List*);
int insert(List*, int, int);
int erase(List*, int);
void output(List*);
void reverse(List*);

int main() {
    srand(time(0));
    #define MAX_OP 20
    List *l = getLinkList();
    for (int i = 0; i &amp;lt; MAX_OP; ++i) {
        int op = rand() % 4;
        int val = rand() % 100;
        int ind = rand() % (l-&amp;gt;length + 3) - 1;
        switch (op) {
            case 0:
            case 1: {
                printf(&amp;quot;insert %d at %d to LinkList = %d\n&amp;quot;, val, ind, insert(l, val, ind));
            } break;
            case 2: {
                printf(&amp;quot;erase iterm at %d from LinkList = %d\n&amp;quot;, ind, erase(l, ind));
            } break;
            case 3: {
                printf(GREEN(&amp;quot;reverse the LinkList!\n&amp;quot;));
                reverse(l);
            } break;
        }
        output(l);
        printf(&amp;quot;\n&amp;quot;);
    }
    #undef MAX_OP
    clear(l);
    return 0;
}

Node *getNewNode(int val) {
    Node *p = (Node *)malloc(sizeof(Node));
    p-&amp;gt;data = val;
    p-&amp;gt;next = NULL;
    return p;
}

List *getLinkList() {
    List *l = (List *)malloc(sizeof(List));
    l-&amp;gt;head.next = NULL;
    int length = 0;
    return l;
}

void clear_node(Node *p) {
    if (p == NULL) return ;
    free(p);
    return ;
}

void clear(List *l) {
    if (l == NULL) return ;
    Node *p = l-&amp;gt;head.next, *q;
    while (p) {
        q = p-&amp;gt;next;
        clear_node(p);
        p = q;
    }
    free(l);
    return ;
}

int insert(List *l,int val, int ind) {
    if (l == NULL) return 0;
    if (ind &amp;lt; 0 || ind &amp;gt; l-&amp;gt;length) return 0;
    Node *p = &amp;amp;(l-&amp;gt;head), *node = getNewNode(val);
    while (ind--) p = p-&amp;gt;next; // èµ°åˆ°å¾…æ’å…¥çš„ä½ç½®çš„å‰ä¸€ä¸ªä½ç½®
    node-&amp;gt;next = p-&amp;gt;next;
    p-&amp;gt;next = node;
    l-&amp;gt;length++;
    return 1;
}

int erase(List *l, int ind) {
    if (l == NULL) return 0;
    if (ind &amp;lt; 0 || ind &amp;gt;= l-&amp;gt;length) return 0;
    Node *p = &amp;amp;(l-&amp;gt;head), *q;
    while (ind--) p = p-&amp;gt;next; // èµ°åˆ°å¾…åˆ é™¤çš„ä½ç½®çš„å‰ä¸€ä¸ªä½ç½®
    q = p-&amp;gt;next;
    p-&amp;gt;next = q-&amp;gt;next;
    free(q);
    l-&amp;gt;length--;
    return 1;
}

void reverse(List *l) {
    Node *p = l-&amp;gt;head.next, *q;
    l-&amp;gt;head.next = NULL;
    while (p) {
        q = p-&amp;gt;next;
        p-&amp;gt;next = l-&amp;gt;head.next;
        l-&amp;gt;head.next = p;
        p = q;
    }
    return ;
}

void output(List *l) {
    if (l == NULL) return ;
    printf(&amp;quot;LinkList(%d) = [&amp;quot;, l-&amp;gt;length);
    for (Node *p = l-&amp;gt;head.next; p; p = p-&amp;gt;next) {
        printf(&amp;quot;%d-&amp;gt;&amp;quot;, p-&amp;gt;data);
    }
    printf(&amp;quot;NULL]\n&amp;quot;);
    return ;
}

&lt;/code&gt;&lt;/pre&gt;
">BDS-2.é“¾è¡¨</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/BDS-1.é¡ºåºè¡¨/"" data-c="
          &lt;h2 id=&#34;é¡ºåºè¡¨vector&#34;&gt;é¡ºåºè¡¨ï¼ˆVectorï¼‰&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
ä¸‰ä¸ªç­‰å¼ï¼š
ç¨‹åº = ç®—æ³• + æ•°æ®ç»“æ„
ç¨‹åºè®¾è®¡ = ç®—æ³• + æ•°æ®ç»“æ„ + ç¼–ç¨‹èŒƒå¼
æ•°æ®ç»“æ„ = ç»“æ„å®šä¹‰ + ç»“æ„æ“ä½œ
1.é€šè¿‡ç®—æ³•ä¸æ•°æ®ç»“æ„ï¼Œä½¿è®¡ç®—æœºåˆç†åˆ©ç”¨èµ„æºï¼Œè®©è®¡ç®—èµ„æºæ›´æœ‰ä»·å€¼

*/

// ç©ºé—´è¿ç»­ï¼Œå¯ä»¥å­˜å‚¨ä»»æ„ç±»å‹çš„ç›¸åŒå…ƒç´ ï¼ˆé¡ºåºè¡¨é‡Œä¹Ÿå¯ä»¥å­˜é¡ºåºè¡¨ï¼‰

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;time.h&amp;gt;

#define COLOR_HL(a, b) &amp;quot;\e[1;&amp;quot; #b &amp;quot;m&amp;quot; a &amp;quot;\e[0m&amp;quot;
#define GREEN_HL(a) COLOR_HL(a, 32)
/* ç»“æ„å®šä¹‰
é¡ºåºè¡¨çš„ç©ºé—´å¤§å°ï¼šsize
å·²å­˜å‚¨çš„å…ƒç´ ä¸ªæ•°ï¼šlength
å­˜å‚¨çš„å…ƒç´ ç±»å‹ï¼š*data 
*/
typedef struct Vector {
    int *data;
    int size, length;
} Vec;
/*
ç»“æ„æ“ä½œ
å¢åˆ æ”¹æŸ¥
åˆå§‹åŒ–é¡ºåºè¡¨Vecï¼šç»™é¡ºåºè¡¨ç”³è¯·å¯ä»¥å­˜å‚¨nä¸ªå…ƒç´ çš„å†…å­˜ç©ºé—´å¹¶åˆå§‹åŒ–ï¼ŒVec *init(int n);
å†…å­˜å›æ”¶ï¼švoid clear(Vec *v);
å†…å­˜æ‰©å®¹ï¼š int expand(Vec *v);
å¢ï¼šæ’å…¥å…ƒç´ ï¼Œç»™å®šä½ç½®æ’å…¥å€¼int insert(Vec *v, int val, int ind);
åˆ ï¼›åˆ é™¤å…ƒç´ ï¼Œåˆ é™¤æŒ‡å®šä½ç½®çš„å…ƒç´ int erase(Vec *v, int ind);
æ‰“å°è¾“å‡ºé¡ºåºè¡¨çš„å…ƒç´ ï¼švoid output(Vec *v);

*/

typedef struct Vector {
    int *data;
    int size, length;
}Vec;

Vec *init(int);
void clear(Vec*);
int insert(Vec*, int, int);
int expand(Vec*);
int erase(Vec*, int);
void output(Vec*);

int main() {
    srand(time(0));
    #define MAX_OP 20
    Vec *v = init(5);
    for (int i = 0; i &amp;lt; MAX_OP; ++i) {
        int op = rand() % 4;
        int val = rand() % 100;
        int ind = rand() % (v-&amp;gt;length + 3) - 1;
        switch (op) {
            case 0:
            case 1:
            case 2: {
                printf(&amp;quot;insert %d at %d to Vector = %d\n&amp;quot;, val, ind, insert(v, val, ind));
            } break;
            case 3: {
                printf(&amp;quot;erase a iterm at %d from Vector = %d\n&amp;quot;, ind, erase(v, ind));
            } break;
        }
        output(v);
        printf(&amp;quot;\n&amp;quot;);
    }
    clear(v);
    #undef MAX_OP
    return 0;
}

Vec *init(int n) {
    Vec *v = (Vec*)malloc(sizeof(Vec));
    v-&amp;gt;data = (int*)malloc(sizeof(int) * n);
    v-&amp;gt;size = n;
    v-&amp;gt;length = 0;
    return v;
}

void clear(Vec *v) {
    if (v == NULL) return ;
    free(v-&amp;gt;data);
    free(v);
    return ;
}

int insert(Vec *v, int val, int ind) {
    if (v == NULL) return 0;
    if (ind &amp;lt; 0 || ind &amp;gt; v-&amp;gt;length) return 0;
    if (v-&amp;gt;length &amp;gt;= v-&amp;gt;size) {
        if (!(expand(v))) return 0;
        printf(GREEN_HL(&amp;quot;success to expand, the Vector size is %d\n&amp;quot;), v-&amp;gt;size);
    }
    for (int i = v-&amp;gt;length; i &amp;gt; ind; --i) {
        v-&amp;gt;data[i] = v-&amp;gt;data[i-1];
    }
    v-&amp;gt;data[ind] = val;
    v-&amp;gt;length++;
    return 1;
}

int erase(Vec *v, int ind) {
    if (v == NULL) return 0;
    if (ind &amp;lt; 0 || ind &amp;gt;= v-&amp;gt;length) return 0;
    for (int i = ind + 1; i &amp;lt; v-&amp;gt;length; ++i) {
        v-&amp;gt;data[i-1] = v-&amp;gt;data[i];
    }
    v-&amp;gt;length--;
    return 1;
}

//  åŠ¨æ€å†…å­˜åˆ†é…å‡½æ•°
/*
1.malloc:åªæ˜¯å¼€è¾Ÿç©ºé—´ï¼Œå€¼ä¸ç¡®å®šï¼ˆå¼€æˆ¿æ²¡æœ‰ä¿æ´é˜¿å§¨ï¼‰
2.calloc:å¼€è¾Ÿç©ºé—´ï¼Œå¹¶ä¸”åˆå§‹åŒ–ï¼ˆå¼€æˆ¿åæœ‰ä¿æ´é˜¿å§¨æ‰“æ‰«æ¸…ç†ï¼‰
3.realloc:é‡æ–°å¼€è¾Ÿç©ºé—´ï¼ˆå‡çº§æˆ¿å‹ï¼‰
reallocçš„ä¸‰ç§æƒ…å†µï¼š
æƒ…å†µ1.å…ˆè¯•æ¢èƒ½ä¸èƒ½åœ¨åŸåœ°å€åé¢ç›´æ¥åŠ ç©ºé—´ï¼Œç©ºé—´é¦–åœ°å€ä¸å˜ï¼›å¦‚æœä¸è¡Œï¼ˆæƒ…å†µ2ï¼‰
æƒ…å†µ2.æ¢ä¸ªåœ°å€æ‰¾æ‰¾ï¼Œç”³è¯·ç©ºé—´ï¼Œç„¶åæŠŠåŸç©ºé—´æ•°æ®æ‹·è´åˆ°æ–°ç©ºé—´ï¼Œå¹¶freeæ‰åŸç©ºé—´ï¼›å¦‚æœä¸è¡Œï¼ˆæƒ…å†µ3ï¼‰
æƒ…å†µ3.å°±è¿”å›ç©ºåœ°å€ï¼Œä¸æ¸…ç©ºå½“å‰åœ°å€
*/

int expand(Vec *v) {
    int ex_size = v-&amp;gt;size;
    int *p;
    while (ex_size) {
        p = (int *)realloc(v-&amp;gt;data, sizeof(int) * (ex_size + v-&amp;gt;size));
        if (p) break;
        ex_size /= 2;
    }
    if (ex_size == 0) return 0;
    v-&amp;gt;data = p;
    v-&amp;gt;size += ex_size;
    return 1;
}

void output(Vec *v) {
    if (v == NULL) return ;
    printf(&amp;quot;Vector [&amp;quot;);
    for (int i = 0; i &amp;lt; v-&amp;gt;length; ++i) {
        i &amp;amp;&amp;amp; printf(&amp;quot;, &amp;quot;);
        printf(&amp;quot;%d&amp;quot;, v-&amp;gt;data[i]);
    }
    printf(&amp;quot;]\n&amp;quot;);
    return ;
}

&lt;/code&gt;&lt;/pre&gt;
">BDS-1.é¡ºåºè¡¨</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/Cè¯­è¨€-7.å·¥ç¨‹é¡¹ç›®å¼€å‘/"" data-c="
          &lt;h2 id=&#34;å¤´æ–‡ä»¶çš„å¼•å…¥ä¸é™æ€é“¾æ¥åº“&#34;&gt;å¤´æ–‡ä»¶çš„å¼•å…¥ä¸é™æ€é“¾æ¥åº“&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
1.åœ¨æµ‹è¯•ç›®å½•ä¸‹ï¼ˆæœ‰main.cæˆ–test.cï¼‰ï¼Œåˆ›å»ºä¸€ä¸ªmoduleç›®å½•
2.åœ¨moduleç›®å½•ä¸‹åˆ›å»º includeç›®å½•ï¼Œsrcç›®å½•ï¼Œlibç›®å½•
3.åœ¨includeç›®å½•ä¸‹æ”¾ é¡¹ç›®å¤´æ–‡ä»¶ï¼ˆ.håç¼€ç»“å°¾çš„æ–‡ä»¶ï¼‰
4.åœ¨srcç›®å½•ä¸‹æ”¾ é¡¹ç›®åŸä»£ç ï¼ˆcè¯­è¨€ï¼Œ.cåç¼€ç»“å°¾çš„æ–‡ä»¶ï¼Œc++ï¼Œ.ccåç¼€ç»“å°¾çš„æ–‡ä»¶ï¼‰
5.åœ¨libç›®å½•ä¸‹æ”¾ é™æ€é“¾æ¥åº“ï¼ˆæ‰“åŒ…ç”Ÿæˆ.aåç¼€é“¾æ¥åº“ï¼‰æˆ–åŠ¨æ€é“¾æ¥åº“
*/
// ./include/ç›®å½•ä¸‹
// header1.h
#ifndef _HEADER1_H
#define _HEADER1_H
void funcA(int);
void funcB(int);
#endif

// header2.h
#ifndef _HEADER2_H
#define _HEADER2_H
void funcC(int, int);
#endif

// header3.h
#ifndef _HEADER3_H
#define _HEADER3_H

void funcD(int, int);

#endif


// ./src/ç›®å½•ä¸‹

// header1.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;header1.h&amp;gt;

void funcA(int n) {
    if (n == 0) return ;
    printf(&amp;quot;funcA: %d\n&amp;quot;, n);
    funcB(n - 1);
    return ;
}

void funcB(int n) {
    if (n == 0) return ;
    printf(&amp;quot;funcB: %d\n&amp;quot;, n);
    funcA(n - 1);
    return ;
}

// header2.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;header1.h&amp;gt;

void funcC(int a, int b) {
    printf(&amp;quot;funcC: %d + %d = %d\n&amp;quot;, a, b, a + b);
    funcA(a);
    return ;
}

// header3.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;header1.h&amp;gt;

void funcD(int a, int b) {
    printf(&amp;quot;%d + %d = %d\n&amp;quot;, a, b, a + b);
    funcA(a);
    return ;
}

// ./lib/ ç›®å½•ä¸‹

1. æŠŠæºæ–‡ä»¶ç¼–è¯‘æˆå¯¹è±¡æ–‡ä»¶ ï¼ˆgcc -I./include/ -c ***.cï¼‰
2. æŠŠå¯¹è±¡æ–‡ä»¶æ‰“åŒ…æˆé™æ€é“¾æ¥åº“ ï¼ˆar -a lib***.a ***.o ***.oï¼‰
    
/*
ç”Ÿæˆæ‰§è¡Œæ–‡ä»¶  ï¼ˆgcc main.o -L./** ***(é™æ€é“¾æ¥åº“)ï¼‰
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;makefile&#34;&gt;Makefile&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;.PHONY: clean run 

all: test.o ./src/header1.o ./src/header2.o ./src/header3.o 
	gcc test.o ./src/header1.o ./src/header2.o ./src/header3.o -o ./bin/lai
test.o: test.c
	gcc -I./include -c test.c
./src/header1.o: ./src/header1.c 
	gcc -I./include -c ./src/header1.c -o ./src/header1.o
./src/header2.o: ./src/header2.c 
	gcc -I./include -c ./src/header2.c -o ./src/header2.o
./src/header3.o: ./src/header3.c 
	gcc -I./include -c ./src/header3.c -o ./src/header3.o
clean:
	rm -rf ./src/*.o ./bin/lai *.o
run:
	./bin/lai

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;æµ‹è¯•æ¡†æ¶&#34;&gt;æµ‹è¯•æ¡†æ¶&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201109201450322.png&#34; alt=&#34;image-20201109201450322&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
1.åœ¨æµ‹è¯•ç›®å½•ä¸‹ï¼ˆæœ‰main.cæˆ–test.cï¼‰ï¼Œåˆ›å»ºä¸€ä¸ªmoduleç›®å½•å’Œmain.cæºæ–‡ä»¶å’ŒMakefile
2.åœ¨moduleç›®å½•ä¸‹åˆ›å»º includeç›®å½•ï¼Œsrcç›®å½•ï¼Œlibç›®å½•
3.åœ¨includeç›®å½•ä¸‹æ”¾ é¡¹ç›®å¤´æ–‡ä»¶ï¼ˆ.håç¼€ç»“å°¾çš„æ–‡ä»¶ï¼‰
4.åœ¨strç›®å½•ä¸‹æ”¾ é¡¹ç›®åŸä»£ç ï¼ˆcè¯­è¨€ï¼Œ.cåç¼€ç»“å°¾çš„æ–‡ä»¶ï¼Œc++ï¼Œ.ccåç¼€ç»“å°¾çš„æ–‡ä»¶ï¼‰
*/

// main.c

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;lai.h&amp;gt;
int add(int a, int b) {
    return a + b;
}

TEST(func, add1) {
    EXPECT_EQ(add(2, 3), 5);
    EXPECT_LT(add(3, 4), 9);
    EXPECT_LE(add(3, 6), 9);
    EXPECT_GT(add(-2, 3), 5);
    EXPECT_EQ(add(0, 3), 3);
}

TEST(func, add2) {
    EXPECT_EQ(add(1, 2), 3);
    EXPECT_EQ(add(3, 3), 6);
}

TEST(func, add3) {
    EXPECT_NE(add(0, -1), 2);
    EXPECT_EQ(add(-2, -3), -5);
}

int main(int argc, char *argv[]) {
    return RUN_ALL_TESTS();
}

// Makefile

.PHONY: clean run

all: main.o ./str/lai.o ./include/lai.h 
	gcc  main.o ./str/lai.o -o ./bin/zhu
main.o: main.c ./include/lai.h 
	gcc -I./include -c main.c 
./str/lai.o: ./str/lai.c ./include/lai.h 
	gcc -I./include -c ./str/lai.c -o ./str/lai.o 
clean:
	rm -rf ./bin/lai *.o ./str/lai.o 
run:
	./bin/zhu

// ./include/lai.h

#ifndef _LAI_H
#define _LAI_H
#include &amp;lt;listnode.h&amp;gt;

#define COLOR(a, b) &amp;quot;\e[&amp;quot; #b &amp;quot;m&amp;quot; a &amp;quot;\e[0m&amp;quot;    // &amp;quot;\e[31m&amp;quot; ä¸Šè‰²éƒ¨åˆ† &amp;quot;\e[0m&amp;quot;
#define COLOR_HL(a, b) &amp;quot;\e[1;&amp;quot; #b &amp;quot;m&amp;quot; a &amp;quot;\e[0m&amp;quot;  // &amp;quot;\e[1;31m&amp;quot; ä¸Šè‰²éƒ¨åˆ† &amp;quot;\e[0m&amp;quot;
#define RED(a) COLOR(a, 31)
#define GREEN(a) COLOR(a, 32)
#define YELLOW(a) COLOR(a, 33)
#define BLUE(a) COLOR(a, 34)

#define RED_HL(a) COLOR_HL(a, 31)
#define GREEN_HL(a) COLOR_HL(a, 32)
#define YELLOW_HL(a) COLOR_HL(a, 33)
#define BLUE_HL(a) COLOR_HL(a, 34)

#define TEST(a, b)\
void a##_lai_##b();\
__attribute__((constructor))\   // åœ¨mainå‡½æ•°ä¹‹å‰æ‰§è¡Œ
void add_##a##b##test() {\
    add_func(a##_lai_##b, #a&amp;quot;.&amp;quot;#b);\ 
}\
void a##_lai_##b()

#define TYPE(a) _Generic((a),\    //æ³›å‹å®
    int : &amp;quot;%d&amp;quot;,\
    float : &amp;quot;%f&amp;quot;,\
    double : &amp;quot;%lf&amp;quot;,\
    long long : &amp;quot;%lld&amp;quot;,\
    char* : &amp;quot;%s&amp;quot;\
)

#define P(a, color) {\
    char str[1000];\
    sprintf(str, color(&amp;quot;%s&amp;quot;), TYPE(a));\
    printf(str, a);\
}

#define EXPECT(a, b, comp) {\ 
    __typeof(a) _a = a;\ 
    __typeof(b) _b = b;\
    info.total++;\
    if (_a comp _b) info.success++;\
    else {\
        printf(&amp;quot;\n\t&amp;quot; YELLOW_HL(&amp;quot;%s:%d: Failure\n&amp;quot;), __func__, __LINE__);\
        printf(&amp;quot;\t\t&amp;quot; YELLOW_HL(&amp;quot;expect : &amp;quot; #a &amp;quot; &amp;quot; #comp &amp;quot; &amp;quot; #b &amp;quot;\n&amp;quot;));\
        printf(&amp;quot;\t\t&amp;quot; YELLOW_HL(&amp;quot;actual : &amp;quot;));\
        P(_a, YELLOW_HL);\
        P(&amp;quot; vs &amp;quot;, YELLOW_HL);\
        P(_b, YELLOW_HL);\
        printf(&amp;quot;\n\n&amp;quot;);\
    }\
    printf(GREEN(&amp;quot;[-----------]&amp;quot;));\
    printf(&amp;quot; &amp;quot; #a &amp;quot; &amp;quot; #comp &amp;quot; &amp;quot; #b);\
    printf(&amp;quot; %s\n&amp;quot;, _a comp _b ? GREEN_HL(&amp;quot;True&amp;quot;) : RED_HL(&amp;quot;False&amp;quot;));\
}

#define EXPECT_EQ(a, b) EXPECT(a, b, ==)
#define EXPECT_NE(a, b) EXPECT(a, b, !=)
#define EXPECT_LT(a, b) EXPECT(a, b, &amp;lt;)
#define EXPECT_LE(a, b) EXPECT(a, b, &amp;lt;=)
#define EXPECT_GT(a, b) EXPECT(a, b, &amp;gt;)
#define EXPECT_GE(a, b) EXPECT(a, b, &amp;gt;=)

typedef void (*pfunc)();  //å‡½æ•°æŒ‡é’ˆç±»å‹

typedef struct functest {
    pfunc func;
    const char *str;
    Node p;   //â€œå¤–éª¨éª¼â€
}functest;

typedef struct func_info {
    int total, success;
} funcinfo;

extern funcinfo info; 

int RUN_ALL_TESTS();
void add_func(pfunc, const char*);

#endif

// ./include/listnode.h

#ifndef _LISTNODE_H
#define _LISTNODE_H

#define offset(T, name) (long long)(&amp;amp;(((T *)(NULL))-&amp;gt;name))
#define Head(p, T, name) (T *)((char *)(p) - offset(T, name))

typedef struct ListNode {
    struct ListNode *next; //å¤–éª¨éª¼å®ç°
}Node;

#endif

// ./src/lai.c

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;lai.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

functest func_head, *func_tail = &amp;amp;func_head;
funcinfo info;

int RUN_ALL_TESTS() {
    for (Node *p = func_head.p.next; p; p = p-&amp;gt;next) {
        functest *func_res = Head(p, functest, p);
        printf(GREEN(&amp;quot;[====RUN====]&amp;quot;));
        printf(RED(&amp;quot; %s\n&amp;quot;), func_res-&amp;gt;str);
        info.total = 0; info.success = 0;
        func_res-&amp;gt;func();
        printf(GREEN(&amp;quot;[  &amp;quot;));
        double res = 100.0 * info.success / info.total;
        if (info.total == info.total &amp;amp;&amp;amp; info.total != 0) {
            printf(BLUE_HL(&amp;quot;%6.2lf%%&amp;quot;), res);   
        } else {
            printf(RED_HL(&amp;quot;%6.2lf%%&amp;quot;), res);
        }
        printf(GREEN(&amp;quot;  ]&amp;quot;));
        printf(&amp;quot; total : %d success : %d\n&amp;quot;, info.total, info.success);
    }
    return 0;
}

void add_func(pfunc func, const char *str) {
    functest *temp = (functest *)calloc(1, sizeof(functest)); //å®ä¾‹åŒ–
    temp-&amp;gt;func = func;
    temp-&amp;gt;str = strdup(str);
    func_tail-&amp;gt;p.next = &amp;amp;(temp-&amp;gt;p);
    func_tail = temp;
    return ;
}

&lt;/code&gt;&lt;/pre&gt;
">Cè¯­è¨€-7.å·¥ç¨‹é¡¹ç›®å¼€å‘</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/Cè¯­è¨€-6.å¤æ‚ç»“æ„ä¸æŒ‡é’ˆ/"" data-c="
          &lt;h2 id=&#34;ç»“æ„ä½“&#34;&gt;ç»“æ„ä½“&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct person {
    char name[20];
  	int age;
    char gender;
    float height;
};

/*
1. ç»“æ„ä½“ç±»å‹ï¼šstruct person(å˜é‡å)ï¼Œ æ²¡æœ‰å˜é‡åï¼ŒåŒ¿åç»“æ„ä½“
2. å†…å­˜å¯¹é½
3. å¼•ç”¨æ–¹å¼ï¼šç›´æ¥å¼•ç”¨ï¼šperson.age(å€¼.å˜é‡) ï¼Œé—´æ¥å¼•ç”¨ï¼š&amp;amp;person-&amp;gt;age(åœ°å€-&amp;gt;å˜é‡)
*/

//è¯·å†™å‡ºnode1 å’Œ node2 æ‰€åœ¨çš„å­—èŠ‚æ•°ã€‚
struct node1 { // 8å­—èŠ‚
    char a;
    char b;
    int c;
};

struct node2 { // 12å­—èŠ‚ 
    char a;
    int c;
    char b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;å…±ç”¨ä½“&#34;&gt;å…±ç”¨ä½“&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
union register { // å…±ç”¨ä½“
	struct { // åŒ¿åç»“æ„ä½“
		unsigned char byte1;
		unsigned char byte2;
		unsigned char byte3;
		unsigned char byte4;
	} bytes; //ç»“æ„ä½“ç±»å‹
	unsigned int number;
};
*/

//è¯·ä½¿ç”¨å…±ç”¨ä½“ï¼Œå®ç°ipè½¬æ•´æ•°çš„åŠŸèƒ½ã€‚
/*
#include &amp;lt;stdio.h&amp;gt;

union IP {
    struct {
        unsigned char a1;
        unsigned char a2;
        unsigned char a3;
        unsigned char a4;
    } ip;
    unsigned int num;
};

int is_little() {
    static int num = 1; // 0001 
    return ((char *)(&amp;amp;num))[0]; //1000

}

int main() {
    printf(&amp;quot;%d\n&amp;quot;, is_little());
    char str[100];
    int arr[4];
    union IP p;
    while (~scanf(&amp;quot;%s&amp;quot;, str)) {
        sscanf(str, &amp;quot;%d.%d.%d.%d&amp;quot;, arr, arr + 1, arr + 2, arr + 3);
        p.ip.a1 = arr[3];
        p.ip.a2 = arr[2];
        p.ip.a3 = arr[1];
        p.ip.a4 = arr[0];
        printf(&amp;quot;%d\n&amp;quot;, p.num);
    }
    return 0;
}
*/

#include &amp;lt;stdio.h&amp;gt;

typedef union IP {
    unsigned int n;
    char part[4];
} ip;

int main() {
    ip p; // å…±ç”¨ä½“ç±»å‹ å˜é‡
    int num[4];
    scanf(&amp;quot;%d.%d.%d.%d&amp;quot;, num + 3, num + 2, num + 1, num);
    //è¾“å…¥ 192.168.0.1ï¼Œ numæ•°ç»„ä¸º [1, 0, 168, 192]
    for (int i = 0; i &amp;lt; 4; ++i) {
        p.part[i] = num[i] &amp;amp; ((1 &amp;lt;&amp;lt; 8) - 1); // num[i] &amp;amp; 01111111
        printf(&amp;quot;%02x\n&amp;quot;, num[i]);
    }
    printf(&amp;quot;%08x\n&amp;quot;, p.n);
    return 0;
}
/*
å°ç«¯ç³»ç»Ÿï¼ˆä¸€èˆ¬éƒ½æ˜¯ï¼‰ï¼š æ•°å­—çš„ä½ä½ æ”¾ä½åœ°å€ä½ï¼Œå¦‚ æ•°å­— 1234ï¼Œæ”¾å…¥åœ°å€ å˜ 4321
å¤§ç«¯ç³»ç»Ÿï¼šæ•°å­—çš„é«˜ä½ æ”¾ é«˜åœ°å€ä½ï¼Œ å¦‚ æ•°å­— 1234 ï¼Œæ”¾å…¥åœ°å€ å˜ 1234
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;æŒ‡é’ˆä¸åœ°å€&#34;&gt;æŒ‡é’ˆä¸åœ°å€&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
int a;
int *p = &amp;amp;a;

1. 64ä½ç³»ç»Ÿï¼Œä¸ç®¡æŒ‡é’ˆæ˜¯ä»€ä¹ˆæ•°æ®ç±»å‹ï¼ˆint* double* char*ï¼‰,æŒ‡é’ˆå¤§å°éƒ½æ˜¯8ä¸ªå­—èŠ‚
2. 32ä½ç³»ç»Ÿï¼Œä¸ç®¡æŒ‡é’ˆæ˜¯ä»€ä¹ˆæ•°æ®ç±»å‹ï¼ˆint* double* char*ï¼‰,æŒ‡é’ˆå¤§å°éƒ½æ˜¯4ä¸ªå­—èŠ‚
3. *p == a; p + 1 == &amp;amp;P[1]
p-&amp;gt;filed == (*p).feiled == a.filed
*/

/*
å‡è®¾æœ‰å¦‚ä¸‹ä»£ç ï¼š

struct Data {
	int x, y;
};
struct Data a[2], *p = a;
è¯·ç”¨å°½å¯èƒ½å¤šçš„å½¢å¼è¡¨ç¤º a[1].x
*/
#include &amp;lt;stdio.h&amp;gt;

#define P(a) {\
    printf(&amp;quot;%s = %d\n&amp;quot;, #a, a);\
}

typedef struct Data {
    int x, y;
} Data;

int main() {
    Data a[2];
    Data *p = a;
    a[0].x = 1, a[0].y = 1;
    a[1].x = 2, a[1].y = 2;
    P(a[1].x);
    P(p[1].x);
    P((*(a + 1)).x);
    P(1[a].x);
    P((a + 1)-&amp;gt;x);
    P((p + 1)-&amp;gt;x);
    P((&amp;amp;a[1])-&amp;gt;x);
    P((&amp;amp;p[1])-&amp;gt;x);
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;å‡½æ•°æŒ‡é’ˆä¸mianå‡½æ•°&#34;&gt;å‡½æ•°æŒ‡é’ˆä¸mianå‡½æ•°&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
å‡½æ•°å˜é‡ï¼šint (*add)(int, int);
å‡½æ•°ç±»å‹ï¼štypedef int (*add)(int, int);
*/
/*
1.å†…å»ºç±»å‹çš„é‡åï¼š
typedef long long lint;
typedef char *pchar;

2.ç»“æ„ä½“ç±»å‹çš„é‡å‘½åï¼š
typedef struct __node{
	int x, y;
} Node, *pNode;
3.å‡½æ•°æŒ‡é’ˆå‘½åï¼š
typedef int (*func)(int);
*/
/*
mainå‡½æ•°å‚æ•°
int main();
int main(int argc, char *argc[]);
int main(int argc, char *argv[], char **env);
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;æŒ‡é’ˆä¸åœ°å€çš„ä»£ç æ¼”ç¤º&#34;&gt;æŒ‡é’ˆä¸åœ°å€çš„ä»£ç æ¼”ç¤º&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

#define P(a) {\
    printf(&amp;quot;%s = %s\n&amp;quot;, #a, a);\
}

int main() {
    int num1 = 0x616263;  // åå…­è¿›åˆ¶ï¼Œå°ç«¯ç³»ç»Ÿï¼šï¼ˆ63 62 61 0xï¼‰ï¼ˆ&#39;c&#39; &#39;b&#39; &#39;a&#39; &#39;\0&#39;ï¼‰
    int num2 = 0x61626364; 
    P((char *)(&amp;amp;num2));  //
    return 0;
}



#include &amp;lt;stdio.h&amp;gt;

#define P(a) {\
    __typeof(a) _a = a;\  // __typeof(a): æ ¹æ®aåˆ¤æ–­æ•°æ®ç±»å‹
    printf(&amp;quot;%s = %ld\n&amp;quot;, #a, _a);\
}

#define OFFSET(T, a) (long)(&amp;amp;(((T *)(NULL))-&amp;gt;a)) // ç»“æ„ä½“å­—æ®µåç§»é‡
//1. å£°æ˜æŒ‡å‘ç»“æ„ä½“ç±»å‹çš„ç©ºæŒ‡é’ˆ(T *)(NULL)
//2.ç©ºæŒ‡é’ˆé—´æ¥å¼•ç”¨ç»“æ„ä½“çš„å­—æ®µ ((T *)(NULL))-&amp;gt;a
//3.å–å­—æ®µåœ°å€ &amp;amp;(((T*)(NULL))-&amp;gt;a)
//4.åœ°å€è½¬é•¿æ•´å½¢æ•°æ®ç±»å‹ (long)(&amp;amp;(((T *)(NULL))-&amp;gt;a))
typedef struct Data {
    int a;   //åç§» 0
    double b; //åç§» 8
    char c;  // åç§» 16
} Data;

int main() {
    P(OFFSET(Data, a));
    P(OFFSET(Data, b));
    P(OFFSET(Data, c));
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;mainå‡½æ•°çš„æ¼”ç¤ºä»£ç &#34;&gt;mainå‡½æ•°çš„æ¼”ç¤ºä»£ç &lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// typedef å’Œ #define çš„åŒºåˆ«
//  #define åªæ˜¯ä»£ç æ›¿æ¢ï¼Œ typedef æ˜¯æ•°æ®ç±»å‹é‡åã€‚
#include &amp;lt;stdio.h&amp;gt;

#define ppchar char*

typedef char* pchar;

int main() {
    pchar p1, p2; // char* p1, char* p2;
    ppchar p3, p4; // char* p3, p4;
    printf(&amp;quot;p1 = %lu, p2 = %lu\n&amp;quot;, sizeof(p1), sizeof(p2)); // p1 == 8, p2 == 8
    printf(&amp;quot;p3 = %lu, p4 = %lu\n&amp;quot;, sizeof(p3), sizeof(p4)); // p3 == 8, p4 == 1

    return 0;
}


#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

void output(int, char *argc[], char **env);

int main(int argc, char *argv[], char **env) {
    output(argc, argv, env);
    return 0;
}

void output(int argc, char *agrv[], char **env) {
    //argc : å‘½ä»¤è¡Œå‚æ•°ä¸ªæ•°ï¼Œç©ºæ ¼åˆ†å¼€ ï¼ˆhaha == 1ä¸ªï¼Œ ha ha == 2ä¸ªï¼Œ &amp;quot;haha&amp;quot; == 1ä¸ªï¼‰
    printf(&amp;quot;argc = %d\n&amp;quot;, argc); 
    for (int i = 0; i &amp;lt; argc; ++i) {
        //è¾“å‡ºå‘½ä»¤è¡Œ å­—ç¬¦
        printf(&amp;quot;%s\n&amp;quot;, agrv[i]);
    }
    for (int i = 0; env[i]; ++i) {
        // ç¯å¢ƒå˜é‡
        if (!(strncmp(env[i], &amp;quot;USER=&amp;quot;, 5))) {
            if(!(strcmp((&amp;amp;(env[i][5])), &amp;quot;cpp&amp;quot;))) {
                printf(&amp;quot;Welcome Captain lai!\n&amp;quot;);
            } else {
                printf(&amp;quot;you are not the user! please gun!\n&amp;quot;);
                exit(0); // exit()çš„å¤´æ–‡ä»¶ä¸º&amp;lt;stdlib.h&amp;gt;
            }
        }
    }
}


&lt;/code&gt;&lt;/pre&gt;
">Cè¯­è¨€-6.å¤æ‚ç»“æ„ä¸æŒ‡é’ˆ</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/Cè¯­è¨€-5.æ•°ç»„ä¸é¢„å¤„ç†å‘½ä»¤/"" data-c="
          &lt;h2 id=&#34;1ç´ æ•°ç­›ç®—æ³•&#34;&gt;1.ç´ æ•°ç­›ç®—æ³•&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#define MAX_NUM 100

int prime[MAX_NUM + 5] = {0}; //åˆå§‹åŒ–æ•°ç»„
void init(int *);  //ç´ æ•°ç­›é€‰å‡½æ•°

int main() {
    init(prime);
    for (int i = 1; i &amp;lt;= prime[0]; ++i) {
        printf(&amp;quot;%d\n&amp;quot;, prime[i]);
    }
    return 0;
}

void init(int *prime) {
    for (int i = 2; i &amp;lt;= MAX_NUM; ++i) {
        if (prime[i]) continue;  // æ ‡è®°ä¸º1ï¼Œä¸‹ä¸€ä¸ª
        prime[++prime[0]] = i;  // æŠŠæ•°ç»„ç¬¬ä¸€ä¸ªç”¨æ¥è®¡æ•°ï¼Œ
        for (int j = i * i; j &amp;lt;= MAX_NUM; j += i) { 
            // æŠŠ j = 2 * i æ”¹ä¸º j = i * i , å¯ä»¥å‡å°‘æ¬¡æ•°ã€‚
            prime[j] = 1;  // æŠŠç´ æ•°çš„å€æ•°æ ‡è®°ä¸º1
        }
    }
}
/*
prime[++prime[0]] == count = ++prime[0]; prime[count];
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-çº¿æ€§ç­›&#34;&gt;2. çº¿æ€§ç­›&lt;/h3&gt;
&lt;h4 id=&#34;1-è¯·å†™ä¸€ä¸ªç¨‹åºå¿«é€Ÿæ±‚å‡ºä¸€ä¸ªèŒƒå›´å†…å‡è®¾ä¸º10000æ‰€æœ‰æ•°å­—çš„æœ€å°ç´ å› å­&#34;&gt;1.  è¯·å†™ä¸€ä¸ªç¨‹åºï¼Œå¿«é€Ÿæ±‚å‡ºä¸€ä¸ªèŒƒå›´å†…ï¼ˆå‡è®¾ä¸º10000ï¼‰æ‰€æœ‰æ•°å­—çš„æœ€å°ç´ å› å­&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#define MAX_NUM 100

int prime[MAX_NUM+5] = {0};
void init(int *);

int main() {
    init(prime);
    for (int i = 2; i &amp;lt;= MAX_NUM; ++i) {
        printf(&amp;quot;facmin(%d) = %d\n&amp;quot;, i, prime[i]);
    }
    return 0;
}

void init(int *prime) {
    for (int i = 2; i &amp;lt;= MAX_NUM; ++i) {
        if (prime[i]) continue;
        //prime[++prime[0]] = i;
        for (int j = i; j &amp;lt;= MAX_NUM; j += i) {
            if (prime[j]) continue;
            prime[j] = i;
        }
    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-è¯·å†™ä¸€ä¸ªç¨‹åºå¿«é€Ÿæ±‚å‡ºä¸€ä¸ªèŒƒå›´å†…å‡è®¾ä¸º10000æ‰€æœ‰æ•°å­—çš„æœ€å¤§ç´ å› å­&#34;&gt;2.  è¯·å†™ä¸€ä¸ªç¨‹åºï¼Œå¿«é€Ÿæ±‚å‡ºä¸€ä¸ªèŒƒå›´å†…ï¼ˆå‡è®¾ä¸º10000ï¼‰æ‰€æœ‰æ•°å­—çš„æœ€å¤§ç´ å› å­&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#define MAX_NUM 100

int prime[MAX_NUM+5] = {0};

void init(int *);

int main() {
    init(prime);
    for (int i = 2; i &amp;lt;= MAX_NUM; ++i) {
        printf(&amp;quot;facmax(%d) = %d\n&amp;quot;, i, prime[i]);
    }
    return 0;
}

void init(int *prime) {
    for (int i = 2; i &amp;lt;= MAX_NUM; ++i) {
        if (prime[i]) continue;
        for (int j = i; j &amp;lt;= MAX_NUM; j += i) {
            prime[j] = i;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;å®ç°ç´ æ•°çº¿æ€§ç­›&#34;&gt;å®ç°ç´ æ•°çº¿æ€§ç­›&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#define MAX_NUM 100

int prime[MAX_NUM+5] = {0};

void init(int *);

int main() {
    init(prime);
    for (int i = 1; i &amp;lt;= prime[0]; ++i) {
        printf(&amp;quot;%d\n&amp;quot;, prime[i]);
    }
    return 0;
}

void init(int *prime) {
    for (int i = 2; i &amp;lt;= MAX_NUM; ++i) {   // ç”¨ä¸€ä¸ªæ•´æ•°iå»æ ‡è®°N
        if (!prime[i]) prime[++prime[0]] = i;  // æ²¡æœ‰æ ‡è®°çš„æ˜¯ç´ æ•°
        for (int j = 1; j &amp;lt;= prime[0]; ++j) { 
            if (i * prime[j] &amp;gt; MAX_NUM) break; // è¶…è¿‡æ•°ç»„æœ€å¤§çš„ä¸‹æ ‡ï¼Œç›´æ¥ç»“æŸ 
            prime[prime[j] * i] = 1; 
            if (i % prime[j] == 0) break; //å…³é”®
        }
    }
}

/*
ç”¨ä¸€ä¸ªæ•´æ•° i å»æ ‡è®° N, i * p == N
pä¸ºNçš„æœ€å°ç´ å› å­ï¼Œ
i çš„ ç´ å› å­å°äºç­‰äº p
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;äºŒåˆ†æŸ¥æ‰¾&#34;&gt;äºŒåˆ†æŸ¥æ‰¾&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

double func(double x);
double binary_search(double (*func)(double), double x);

int main() {
    double n;
    while (~scanf(&amp;quot;%lf&amp;quot;, &amp;amp;n)) {
        double x = binary_search(func, n);
        printf(&amp;quot;%g * %g = %g\n&amp;quot;, x, x, n);
    }
    return 0;
}

double func(double x) { 
    return x * x;
}

double binary_search(double (*func)(double), double x) {
    double head = 0, tail = x, mid;
    if (x &amp;lt; 1.0) tail = 1.0;
    #define ESPL 1e-7
    while (tail - head &amp;gt; ESPL) {
        mid = (head + tail) / 2.0;
        if (func(mid) &amp;lt; x) head = mid;
        else tail = mid;
    }
    #undef ESPL
    return head;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;æ•°ç»„çš„æ¼”ç¤ºä»£ç &#34;&gt;æ•°ç»„çš„æ¼”ç¤ºä»£ç &lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
æ•°ç»„çš„è¡¨ç¤ºæ–¹æ³•
1. arr[i] == *(arr + i)  
2. arr + i == &amp;amp;(arr[i])

æŒ‡é’ˆå¼ºè½¬
char *p = (char *)arr

æ•°ç»„ä¼ å‚
arr[i]æˆ–arr[i][j] çš„é¦–åœ°å€ä¸ºarr (&amp;amp;arr[0]);
1. ä¸€ç»´æ•°ç»„çš„å®å‚ func(arr) // ä¼ å…¥æ•°ç»„é¦–åœ°å€
å½¢å‚ï¼šfunc(int *arr) æˆ– func(int arr[]) // *arr == *(arr + 0) == arr[]

2.äºŒç»´æ•°ç»„çš„å®å‚ func(arr) // ä¼ å…¥æ•°ç»„é¦–åœ°å€
å½¢å‚ï¼šfunc(int (*arr)[j]) æˆ– func(int arr[][j]) 

3.æ•°ç»„sanf()å‡½æ•°ä¼ å€¼
for (int i = 0; i &amp;lt; n; ++i) {
	scanf(&amp;quot;%d&amp;quot;, &amp;amp;arr[i]); // scanf(&amp;quot;%d&amp;quot;, arr + i);
}

*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;é¢„å¤„ç†å‘½ä»¤&#34;&gt;é¢„å¤„ç†å‘½ä»¤&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
é¢„å¤„ç†å‘½ä»¤â€”â€”æ¡ä»¶å¼ç¼–è¯‘
1. #ifdef DEBUG : æ˜¯å¦å®šä¹‰äº†DEBUGå®
2. #ifndef DEBUG : æ˜¯å¦æ²¡å®šä¹‰DEBUGå®
3. #if MAX_N == 5 : å®MAX_Næ˜¯å¦ç­‰äº5
4. #elif MAX_N == 4 : å¦åˆ™å®MAX_Næ˜¯å¦ç­‰äº4
5. #else
6. #endif
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ç»ƒä¹ -é¢˜&#34;&gt;ç»ƒä¹  é¢˜&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
è¯·å®ç°ä¸€ä¸ªæ²¡æœ‰BUGçš„MAXå®ï¼Œéœ€è¦é€šè¿‡å¦‚ä¸‹æµ‹è¯•ï¼š
1. MAX(2, 3)
2. 5 + MAX(2, 3)
3. MAX(2, MAX(3, 4))
4. MAX(2, 3 &amp;gt; 4 ? 3 : 4)
5. MAX(a++, 6) açš„åˆå€¼ä¸º7ï¼Œå‡½æ•°è¿”å›å€¼ä¸º 7ï¼Œaçš„å€¼å˜ä¸º8
*/

#include &amp;lt;stdio.h&amp;gt;

#define MAX(a, b) ({\
    __typeof(a) _a = a;\  
    __typeof(b) _b = b;\
    _a &amp;gt; _b ? _a : _b;\
})

#define P(a) {\
    printf(&amp;quot;%s = %d\n&amp;quot;, #a, a);\
}

int main() {
    int a = 7;
    P(MAX(2, 3));
    P(5 + MAX(2, 3));
    P(MAX(2, MAX(3, 4)));
    P(MAX(2, 3 &amp;gt; 4 ? 3 : 4));
    P(MAX(a++, 6));
    P(a);
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
å®ç°ä¸€ä¸ªæ‰“å°LOGçš„å‡½æ•°ï¼Œéœ€è¦è¾“å‡ºæ‰€åœ¨å‡½æ•°åŠè¡Œå·ç­‰ä¿¡æ¯ã€‚
æ³¨ï¼š
1. å®__FILE__ ä»¥å­—ç¬¦ä¸²å½¢å¼è¿”å›æ‰€åœ¨æ–‡ä»¶åç§°
2. å®__func__ ä»¥å­—ç¬¦ä¸²å½¢å¼è¿”å›æ‰€åœ¨å‡½æ•°åç§°
3. å®__LINE__ ä»¥æ•´æ•°å½¢å¼è¿”å›ä»£ç è¡Œå·
*/

#include &amp;lt;stdio.h&amp;gt;

#ifdef DEBUG  // ç¼–è¯‘çš„æ—¶å€™åŠ  -DDEBUG (g++ -DDEBUG ...) 
// -DåŠ å…¥å®
#define LOG(frm, agrc...) {\
    printf(&amp;quot;[%s : %d]&amp;quot;, __func__, __LINE__);\
    printf(frm, ##agrc);\  // ##æ˜¯è¿æ¥ç¬¦å·ï¼Œå¯ä»¥ä¸ºç©ºã€‚
    printf(&amp;quot;\n&amp;quot;);\
}
#else

#define LOG(frm, argc...)

#endif  //ç»“æŸå®çš„æ¡ä»¶å¼ç¼–è¯‘

void func(int a) {
    a++;
    LOG(&amp;quot;%d&amp;quot;, a);
    return ;
}

int main() {
    int a = 123;
    func(a);
    LOG(&amp;quot;%d&amp;quot;, a);
    LOG(&amp;quot;hello world!&amp;quot;);
    return 0;
}


&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;å­—ç¬¦ä¸²&#34;&gt;å­—ç¬¦ä¸²&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
å®šä¹‰å­—ç¬¦æ•°ç»„ï¼šchar str[size];

åˆå§‹åŒ–å­—ç¬¦æ•°ç»„ï¼š
1. char str[] = &amp;quot;hello world&amp;quot;; // ä»¥å­—ç¬¦&#39;\0&#39;ç»“å°¾ï¼Œ12å­—èŠ‚ã€‚sizeof(str) == 12
2. char str[size] = {&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;}; 

å¤´æ–‡ä»¶ï¼šstring.h
strlen(str) : è®¡ç®—å­—ç¬¦ä¸²é•¿åº¦ï¼Œä»¥\0ä½œä¸ºç»“æŸç¬¦
strcmp(str1, str2) : å­—ç¬¦ä¸²æ¯”è¾ƒ ï¼ˆä½¿ç”¨å­—å…¸åºï¼‰
strcpy(dest, src) : å­—ç¬¦ä¸²æ‹·è´ ï¼ˆæŠŠsrc æ‹·è´åˆ° destï¼‰
strncmp(str1, str2, n) : å®‰å…¨çš„å­—ç¬¦ä¸²æ¯”è¾ƒ ï¼ˆæ¯”è¾ƒnä¸ªå­—ç¬¦ï¼‰
strncpy(str1, str2, n) : å®‰å…¨çš„å­—ç¬¦ä¸²æ‹·è´
memcpy(str1, str2, n) : å†…å­˜æ‹·è´
memcmp(str1, str2, n) : å†…å­˜æ¯”è¾ƒ
memset(str, c, n) : å†…å­˜è®¾ç½® ï¼ˆc å¯ä»¥ ä¸º 0 æˆ– -1ï¼Œ nä¸ºå­—èŠ‚å¤§å°ï¼‰
ç”¨æ³•ï¼šmemeset(str, 0, sizeof(str));
*/

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;å­—ç¬¦ä¸²ç›¸å…³æ“ä½œ&#34;&gt;å­—ç¬¦ä¸²ç›¸å…³æ“ä½œ&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
å¤´æ–‡ä»¶ï¼šstdio.h
1. sscanf(str1, format, ...); ä»å­—ç¬¦ä¸²str1è¯»å…¥å†…å®¹
2. sprintf(str1, format, ...); å°†å†…å®¹è¾“å‡ºåˆ°str1ä¸­
*/

//è¯·ä½¿ç”¨å­—ç¬¦ä¸²ç›¸å…³æ“ä½œæ–¹æ³•ï¼Œè®¡ç®—ä¸€ä¸ªæ•´å‹16è¿›åˆ¶è¡¨ç¤ºçš„ä½æ•°ã€‚

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main() {
    int n;
    char str[12];
    while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) {
        sprintf(str, &amp;quot;%x&amp;quot;, n);
        printf(&amp;quot;%d(%s) has %lu digit!\n&amp;quot;, n, str, strlen(str));
    }

    return 0;
}


&lt;/code&gt;&lt;/pre&gt;
">Cè¯­è¨€-5.æ•°ç»„ä¸é¢„å¤„ç†å‘½ä»¤</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/Cè¯­è¨€-4.å‡½æ•°/"" data-c="
          &lt;h2 id=&#34;1å‡½æ•°çš„åŸºç¡€çŸ¥è¯†&#34;&gt;1.å‡½æ•°çš„åŸºç¡€çŸ¥è¯†&lt;/h2&gt;
&lt;h3 id=&#34;å‡½æ•°è¯´æ˜&#34;&gt;å‡½æ•°è¯´æ˜&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int is_prime(int x) {
    for (int i = 2; i &amp;lt;= x/2; ++i) {
        if (x % i == 0) {
            return 0;
        }
    }
    return 1;
}
//int is_prime(int x)
//int : è¿”å›å€¼
//is_prime : å‡½æ•°å
//int x : å‚æ•°å£°æ˜åˆ—è¡¨
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ç»ƒä¹ é¢˜&#34;&gt;ç»ƒä¹ é¢˜&lt;/h3&gt;
&lt;h4 id=&#34;1è¯·å®ç°ä¸€ä¸ªç¨‹åºå…ˆè¯»å…¥-ä¸¤ä¸ªæ•´æ•°k-bè¾“å‡º-y-kx-bç›´çº¿æ–¹ç¨‹ä¸­-x1-åˆ°-x100æ—¶çš„yçš„å€¼&#34;&gt;1.è¯·å®ç°ä¸€ä¸ªç¨‹åºï¼Œå…ˆè¯»å…¥ ä¸¤ä¸ªæ•´æ•°ï¼Œk, b,è¾“å‡º y = k*x + bç›´çº¿æ–¹ç¨‹ä¸­ x=1 åˆ° x=100æ—¶çš„yçš„å€¼ã€‚&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int func(int, int, int);

int main() {
    int  k, b;
    scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;k, &amp;amp;b);
    for (int x = 1; x &amp;lt;= 100; ++x) {
        printf(&amp;quot;f(%d) = %d\n&amp;quot;,x, func(k, b, x));
    }
    return 0;
}

int func(int k, int b, int x) {
    int y;
    return y = k * x + b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;é€’å½’å‡½æ•°è®¾è®¡&#34;&gt;é€’å½’å‡½æ•°è®¾è®¡&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
é€’å½’ç¨‹åºçš„ç»„æˆéƒ¨åˆ†
1.è¾¹ç•Œæ¡ä»¶å¤„ç†
2.é’ˆå¯¹äºé—®é¢˜çš„â€œå¤„ç†è¿‡ç¨‹â€å’Œâ€œé€’å½’è¿‡ç¨‹â€
3.ç»“æœè¿”å›
*/

//ç»ƒä¹ é¢˜
/*
è¯·å®ç°ä¸€ä¸ªç¨‹åºï¼Œè¯»å…¥n,è®¡ç®—nçš„é˜¶ä¹˜ã€‚
*/
#include &amp;lt;stdio.h&amp;gt;

int fac(int n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    return fac(n-1) * n;
}

int main() {
    int n;
    while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) {
        printf(&amp;quot;fac(%d) = %d\n&amp;quot;, n, fac(n));
    }
    return 0;
}
//æ ˆåŒºå†…å­˜ä¸º8MB,è¶…è¿‡ä¼šçˆ†æ ˆï¼Œæ ˆæº¢å‡ºã€‚

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;å‡½æ•°æŒ‡é’ˆ&#34;&gt;å‡½æ•°æŒ‡é’ˆ&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int g(int (*f1)(int), int (*f2)(int), int (*f3)(int), int x) {
    if (x &amp;lt; 0) {
        return f1(x);
    }
    if (x &amp;lt; 100) {
        return f2(x);
    }
    return f3(x);
}
// int (*f1)(int) : å‡½æ•°æŒ‡é’ˆå˜é‡ å‡½æ•°åœ°å€ä¼ å‚ã€‚
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;å‡½æ•°æŒ‡é’ˆä¸åº”ç”¨&#34;&gt;å‡½æ•°æŒ‡é’ˆä¸åº”ç”¨&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* æ¬§æ‹‰è®¡åˆ’ 45é¢˜*/
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;inttypes.h&amp;gt;

int64_t binary_search(int64_t (*func)(int64_t), int64_t x);
int64_t Tn(int64_t n);
int64_t Pn(int64_t n);
int64_t Hn(int64_t n);


int main() {
    int64_t n = 143;
    while (1) {
        n++;
        int64_t val = Hn(n);
      //if (binary_search(Tn, val) == -1) continue;
        if (binary_search(Pn, val) == -1) continue;
        break;
    }
    printf(&amp;quot;%&amp;quot; PRId64 &amp;quot;\n&amp;quot;, Hn(n));
    return 0;
}
//ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•ï¼Œä¼ å…¥ä¸€ä¸ªå‡½æ•°ï¼Œå’Œä¸€ä¸ªç›®æ ‡å€¼ï¼Œ
//æŸ¥æ‰¾è¿™ä¸ªç›®æ ‡å€¼æ˜¯è¿™ä¸ªå‡½æ•°çš„ç¬¬å‡ é¡¹ï¼Œæ‰¾ä¸åˆ°åˆ™è¿”å›-1ã€‚
int64_t binary_search(int64_t (*func)(int64_t), int64_t x) {
    int64_t head = 1, tail = x, mid;
    while(head &amp;lt;= tail) {
        mid = (head + tail) &amp;gt;&amp;gt; 1;
        if (func(mid) == x) return mid;
        else if (func(mid) &amp;gt; x) tail = mid - 1;
        else head = mid + 1;
    }
    return -1;
}

int64_t Tn(int64_t n) {
    return n * (n + 1) /2;
}

int64_t Pn(int64_t n) {
    return n * (3 * n - 1) / 2;
}

int64_t Hn(int64_t n) {
    return n * (2 * n - 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;æ¬§å‡ é‡Œå¾—ç®—æ³•è®²è§£&#34;&gt;æ¬§å‡ é‡Œå¾—ç®—æ³•è®²è§£&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int gcd(int, int); 

int main() {
    int a, b;
    while (~scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;a, &amp;amp;b)) {
        printf(&amp;quot;gcd(%d, %d) = %d\n&amp;quot;, a, b, gcd(a, b)); 
    }
    return 0;
}
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
/*
æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼š gcd(a, b) == gcd(b, a % b);
å½“ b ä¸º 0 æ—¶ï¼Œæœ€å¤§å…¬å› æ•°ä¸º a;
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;æ‰©å±•æ¬§å‡ é‡Œå¾—æ¼”ç¤ºä»£ç &#34;&gt;æ‰©å±•æ¬§å‡ é‡Œå¾—æ¼”ç¤ºä»£ç &lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int ex_gcd(int a, int b, int *x, int *y); //int *x,éœ€è¦ä¼ å…¥åœ°å€&amp;amp;x

int main() {
    int a, b, x, y;
    while(~scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;a, &amp;amp;b)) {
        printf(&amp;quot;ex_gcd(%d, %d) = %d\n&amp;quot;, a, b, ex_gcd(a, b, &amp;amp;x, &amp;amp;y));
        printf(&amp;quot;%d * %d + %d * %d = %d\n&amp;quot;, a, x, b, y, ex(a, b, &amp;amp;x, &amp;amp;y));
        
    }
    return 0;
}

int ex_gcd(int a, int b, int *x, int *y) {
    if (!b) { //å‡½æ•°å‡ºå£
        *x = 1;
        *y = 0;
        return a;
    }
    int x1, y1;
    ret = ex_gcd(a, a % b, &amp;amp;x1, &amp;amp;y1); //é€’å½’
    *x = y1;
    *y = x1 - (a / b) * y1;
    return ret;
}
/* 
*p = &amp;amp;a; //è¿™ä¸ª*å·æ˜¯å–åœ°å€ç¬¦å·ï¼Œå‚¨å­˜åœ°å€
p // pä¸ºå³å€¼æ—¶ï¼Œpä¸ºåœ°å€ï¼Œ p == &amp;amp;a
*p // è¿™ä¸ª*å·æ˜¯å–å€¼ç¬¦å·ï¼Œpä¸ºå³å€¼æ—¶ï¼Œpä¸ºå€¼ï¼Œp==a,
*/

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;å˜å‚å‡½æ•°&#34;&gt;å˜å‚å‡½æ•°&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
vaå®¶æ—
å¤´æ–‡ä»¶ï¼š#include &amp;lt;stdarg.h&amp;gt;

å®ç°å¯å˜å‚æ•°max_int,ä»è‹¥å¹²ä¸ªä¼ å…¥çš„å‚æ•°ä¸­è¿”å›æœ€å¤§å€¼ã€‚
int max_intï¼ˆint a, ...ï¼‰;

1.å¦‚ä½•è·å¾—aå¾€åçš„å‚æ•°åˆ—è¡¨ï¼Ÿ
  va_list ç±»å‹çš„å˜é‡ va_list arg;
  è·å¾— arg å‚æ•°åˆ—è¡¨
2.å¦‚ä½•å®šä½aåé¢ç¬¬ä¸€ä¸ªå‚æ•°çš„ä½ç½®ï¼Ÿ
  va_startå‡½æ•° ï¼Œå¼€å§‹å®šä½åˆ°ç¬¬ä¸€ä¸ªå‚æ•°çš„ä½ç½®ã€‚
  va_start(arg, n); ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºå‚æ•°åˆ—è¡¨ï¼Œ ç¬¬äºŒä¸ªå‚æ•°ä¸ºåˆ—è¡¨ä¸­ç¬¬ä¸€ä¸ªå‚æ•°ã€‚
3.å¦‚ä½•è·å–ä¸‹ä¸€ä¸ªå¯å˜å‚æ•°åˆ—è¡¨ä¸­çš„å‚æ•°ï¼Ÿ
  va_arg å‡½æ•°  è·å–;
  va_argï¼ˆarg, intï¼‰;ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºå‚æ•°åˆ—è¡¨ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸ºæ•°æ®ç±»å‹ã€‚
4.å¦‚ä½•ç»“æŸæ•´ä¸ªè·å–å¯å˜å‚æ•°åˆ—è¡¨çš„åŠ¨ä½œï¼Ÿ
  va_end å‡½æ•°  ç»“æŸ va_end(arg); å‚æ•°ä¸ºå‚æ•°åˆ—è¡¨ã€‚
  
*/


#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdarg.h&amp;gt;

int max_int(int n, ...);

int main() {
    printf(&amp;quot;%d\n&amp;quot;, max_int(3, 1, 2, 5));
    printf(&amp;quot;%d\n&amp;quot;, max_int(2, 1, 7, 17));
    printf(&amp;quot;%d\n&amp;quot;,max_int(3, 3, 6, 18));
    return 0;
}

int max_int(int n, ...) {
    if (n &amp;lt; 0) return 0;
    int ans = 0;
    va_list arg;
    va_start(arg, n);
    while (n--) {
        int temp = va_arg(arg, int);
        if (temp &amp;gt; ans) ans = temp;
    }
    va_end(arg);
    return ans;  
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;å‡½æ•°çš„å£°æ˜ä¸å®šä¹‰&#34;&gt;å‡½æ•°çš„å£°æ˜ä¸å®šä¹‰&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
æºæ–‡ä»¶--é¢„ç¼–è¯‘--&amp;gt;ç¼–è¯‘--&amp;gt;å¯¹è±¡æ–‡ä»¶--&amp;gt;é“¾æ¥--&amp;gt;å¯æ‰§è¡Œæ–‡ä»¶
1.å‡½æ•°çš„å£°æ˜åœ¨ç¼–è¯‘é˜¶æ®µï¼Œæœªå£°æ˜å‡½æ•°ï¼ˆundeclaredï¼‰
2.å‡½æ•°çš„å®šä¹‰åœ¨é“¾æ¥é˜¶æ®µï¼Œæœªå®šä¹‰å‡½æ•°ï¼ˆundefinedï¼‰
3.å‡½æ•°é‡å¤å®šä¹‰ï¼Œï¼ˆduplicateï¼‰
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;printfç®€ç‰ˆå®ç°&#34;&gt;printfç®€ç‰ˆå®ç°&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdarg.h&amp;gt;
#include &amp;lt;inttypes.h&amp;gt;

int my_printf(const char *frm, ...);
int reverse_num(int, int);
int output_num(int, int);

int main() {
    int a = 123;
    printf(&amp;quot;hello world!\n&amp;quot;);
    my_printf(&amp;quot;hello world!\n&amp;quot;);
    printf(&amp;quot;a = %d\n&amp;quot;, a);
    my_printf(&amp;quot;a = %d\n&amp;quot;, a);
    printf(&amp;quot;a = %d\n&amp;quot;, 1000);
    my_printf(&amp;quot;a = %d\n&amp;quot;, 1000);
    printf(&amp;quot;a = %d\n&amp;quot;, 0);
    my_printf(&amp;quot;a = %d\n&amp;quot;, 0);
    printf(&amp;quot;a = %d\n&amp;quot;, -123);
    my_printf(&amp;quot;a = %d\n&amp;quot;, -123);
    printf(&amp;quot;INT32_MAX = %d\n&amp;quot;, INT32_MAX);
    my_printf(&amp;quot;INT32_MAX = %d\n&amp;quot;, INT32_MAX);
    printf(&amp;quot;INT32_MIN = %d\n&amp;quot;, INT32_MIN);
    my_printf(&amp;quot;INT32_MIN = %d\n&amp;quot;, INT32_MIN);
    char frm[] = &amp;quot;I am ZL&amp;quot;;
    printf(&amp;quot;%s\n&amp;quot;, frm);
    my_printf(&amp;quot;%s\n&amp;quot;, frm);
    int n;
    while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) {
        printf(&amp;quot;has %d digit!\n&amp;quot;, printf(&amp;quot;%d&amp;quot;, n));
        my_printf(&amp;quot;has %d digit!\n&amp;quot;, my_printf(&amp;quot;%d&amp;quot;, n));
    }
}

int reverse_num(int num, int *temp) {
    int digit = 0;
    do {
        *temp = *temp * 10 + num % 10;
        num /= 10;
        digit++;
    } while(num);
    return digit;
}

int output_num(int temp, int digit) {
    int count = 0;
    while(digit--) {
        putchar(temp % 10 + &#39;0&#39;);
        count++;
        temp /= 10;
    }
    return count;
}

int my_printf(const char *frm, ...) {
    va_list arg;
    va_start(arg, frm);
    int count = 0;
    #define PUTC(a) putchar(a); ++count
    for (int i = 0; frm[i]; ++i) {
        switch (frm[i]) {
            case &#39;%&#39;: {
                switch (frm[++i]) {
                    case &#39;%&#39;: {
                        PUTC(frm[i]);
                    } break;
                    case &#39;d&#39;: {
                        int xx = va_arg(arg, int);
                        uint32_t x;
                        if (xx &amp;lt; 0) {
                            PUTC(&#39;-&#39;);
                            x = -xx;
                        } else {
                            x = xx;
                        }
                        int num1 = x / 100000, num2 = x % 100000; 
                        int temp1 = 0, temp2 = 0;
                        int digit1 = reverse_num(num1, &amp;amp;temp1);
                        int digit2 = reverse_num(num2, &amp;amp;temp2);
                        if (num1) digit2 = 5;
                        else digit1 = 0;
                        count += output_num(temp1, digit1);
                        count += output_num(temp2, digit2);
                    } break;
                    case &#39;s&#39;: {
                        const char *str = va_arg(arg, const char*);
                        for (int i = 0; str[i]; ++i) {
                            PUTC(str[i]);
                        }
                    } break;
                }
            }; break;
            default: PUTC(frm[i]); break;
        }
    }
    va_end(arg);
    #undef PUTC;
    return count; 
}

/*
1. é™¤å·ï¼ˆ/ï¼‰å¯ä»¥å–æ•°å­—é«˜ä½
2. å–æ¨¡ï¼ˆ%ï¼‰å¯ä»¥å–æ•°ç»„ä½ä½
*/
&lt;/code&gt;&lt;/pre&gt;
">Cè¯­è¨€-4.å‡½æ•°</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/Cè¯­è¨€-3.ç¨‹åºæµç¨‹æ§åˆ¶æ–¹æ³•/"" data-c="
          &lt;h2 id=&#34;1-åˆ†æ”¯ç»“æ„&#34;&gt;1. åˆ†æ”¯ç»“æ„&lt;/h2&gt;
&lt;h3 id=&#34;11ç»ƒä¹ é¢˜&#34;&gt;1.1ç»ƒä¹ é¢˜&lt;/h3&gt;
&lt;h4 id=&#34;1ç¨‹åºè¯»å…¥ä¸€ä¸ªæ­£æ•´æ•°nä»£è¡¨å­¦ç”Ÿçš„æˆç»©æ ¹æ®åˆ†æ•°è¾“å‡ºåˆ†æ•°æ¡£ä½&#34;&gt;1.ç¨‹åºè¯»å…¥ä¸€ä¸ªæ­£æ•´æ•°n,ä»£è¡¨å­¦ç”Ÿçš„æˆç»©ï¼Œæ ¹æ®åˆ†æ•°è¾“å‡ºåˆ†æ•°æ¡£ä½ã€‚&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
    
 int main() {
     int n;
     scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
     if (n == 0) {
         printf(&amp;quot;FOOLISH\n&amp;quot;);
     } else if (n &amp;lt; 60) {
         printf(&amp;quot;FAIL\n&amp;quot;);
     } else if (n &amp;lt; 75) {
         printf(&amp;quot;MEDIUM\n&amp;quot;);
     }else if (n &amp;lt;= 100) {
         printf(&amp;quot;GOOD\n&amp;quot;);
     }
     return 0;
 }   
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2è¯·ä½¿ç”¨switchç»“æ„å®Œæˆå¦‚ä¸‹ä»»åŠ¡ç¨‹åºè¯»å…¥ä¸€ä¸ªæ•´æ•°nå¦‚æœ-n1è¾“å‡º-one-å¦‚æœn2è¾“å‡ºtwo-å¦‚æœn3è¾“å‡ºthree-å¦åˆ™è¾“å‡ºerror&#34;&gt;2.è¯·ä½¿ç”¨switchç»“æ„å®Œæˆå¦‚ä¸‹ä»»åŠ¡ï¼Œç¨‹åºè¯»å…¥ä¸€ä¸ªæ•´æ•°nï¼šå¦‚æœ n=1,è¾“å‡º oneã€‚å¦‚æœn=2ï¼Œè¾“å‡ºtwoã€‚å¦‚æœn=3ï¼Œè¾“å‡ºthreeã€‚å¦åˆ™è¾“å‡ºerrorã€‚&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
    int n;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
    switch(n) {
    //caseä¸ºæ¡ä»¶å…¥å£ï¼Œç¨‹åºè¿›å…¥caseæ‰€å¯¹åº”çš„ä»£ç æ®µï¼Œä¾æ¬¡æ‰§è¡Œåç»­ä»£ç ï¼Œ
    //ç›´åˆ°é‡åˆ°break,æˆ–è€…switchç»“æ„æœ«å°¾ã€‚
        case 1: {
            printf(&amp;quot;one\n&amp;quot;);
        } break;
        case 2: {
            printf(&amp;quot;two\n&amp;quot;);
        } break;
        case 3: {
            printf(&amp;quot;three\n&amp;quot;);
        } break;
        default: {
            printf(&amp;quot;error\n&amp;quot;);
        } break;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3å›æ–‡æ•´æ•°&#34;&gt;3.å›æ–‡æ•´æ•°&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool isPalindrome(int x) {
    if (__builtin_expect(!!(x &amp;lt; 0), 0)) return false;
    int y = 0, z = x;
    while (x) {
        y = y * 10 + x % 10;
        x /= 10;
    }
    return z == y;
}

/*
!!(x) : å½’ä¸€åŒ–ã€‚
#define likely(x)    __builtin_expect(!!(x), 1)
#define unlikely(x)  __builtin_expect(!!(x), 0)
//linkely ä»£è¡¨xç»å¸¸æˆç«‹ï¼ŒåŠ è½½æ¡ä»¶åˆ†æ”¯å†…éƒ¨çš„ä»£ç 
//unlikely ä»£è¡¨xä¸ç»å¸¸æˆç«‹ï¼ŒåŠ è½½æ¡ä»¶åˆ†æ”¯å¤–éƒ¨çš„ä»£ç 
*/

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2å¾ªç¯ç»“æ„&#34;&gt;2.å¾ªç¯ç»“æ„&lt;/h2&gt;
&lt;h3 id=&#34;21ç»ƒä¹ é¢˜&#34;&gt;2.1ç»ƒä¹ é¢˜&lt;/h3&gt;
&lt;h4 id=&#34;1-è¯·ä½¿ç”¨whileå¾ªç¯å®ç°ç¨‹åºè¾“å‡º1-100&#34;&gt;1. è¯·ä½¿ç”¨whileå¾ªç¯å®ç°ç¨‹åºï¼Œè¾“å‡º1--100ã€‚&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
    int n = 1;
    /*
    while (n &amp;lt;= 100) {
        printf(&amp;quot;%d\n&amp;quot;, n);
        n++;
    }
    */
    do {
        printf(&amp;quot;%d\n&amp;quot;, n);
        n++;
    } while (n &amp;lt;= 100);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22-forå¾ªç¯è¯­å¥&#34;&gt;2.2 forå¾ªç¯è¯­å¥&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for(åˆå§‹åŒ–ï¼›å¾ªç¯æ¡ä»¶ï¼›æ‰§è¡Œåæ“ä½œ) ï½›
    ä»£ç å—ï¼›
ï½
    
//è¯·ä½¿ç”¨forå¾ªç¯å®ç°ç¨‹åºï¼Œè¾“å‡º1--100
#include &amp;lt;stdio.h&amp;gt;
int main() {
    for (int i = 1; i &amp;lt;= 100; ++i) {
        printf(&amp;quot;%d\n&amp;quot;, i);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3åˆ†æ”¯ç»“æ„æ¼”ç¤ºä»£ç &#34;&gt;3.åˆ†æ”¯ç»“æ„æ¼”ç¤ºä»£ç &lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;  // éšæœºæ•°rand()å‡½æ•°çš„å¤´æ–‡ä»¶
#include &amp;lt;time.h&amp;gt;  //æ—¶é—´time()å‡½æ•°çš„å¤´æ–‡ä»¶

int main() {
    int a, b;
    //srand(x)å‡½æ•°ä¸ºï¼šåˆå§‹åŒ–éšæœºæ•°å‘ç”Ÿå™¨ï¼Œxæ˜¯å¯å˜çš„è¯ï¼Œæ¯æ¬¡çš„éšæœºæ•°å°±å‘ç”Ÿå˜åŒ–ã€‚
    //time(0):ä»¥ç§’ä¸ºå•ä½çš„æ—¶é—´ã€‚
    srand(time(0)); 
    scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;a, &amp;amp;b); //è¾“å…¥ a = 3, b = 4;
    if (a - b) { // å¦‚æœa - b == 0, åˆ™ a == bã€‚
        printf(&amp;quot;not equal!\n&amp;quot;);
    } else {
    //è¾“å‡º   printf(&amp;quot;eauql!\n&amp;quot;);
    }
    a = 0, b = 0;
    if ((a++) &amp;amp;&amp;amp; (b++)) {
        printf(&amp;quot;true\n&amp;quot;); // a == 1, b == 0
    } else {
    //è¾“å‡º   printf(&amp;quot;false\n&amp;quot;); 
    }
    printf(&amp;quot;a = %d, b = %d\n&amp;quot;, a, b); //a == 1, b == 0
    if ((a++) || (b++)) {
    //è¾“å‡º   printf(&amp;quot;true\n&amp;quot;); // a == 2, b == 0
    } else {
        printf(&amp;quot;false\n&amp;quot;);
    }
    printf(&amp;quot;a = %d, b = %d\n&amp;quot;, a, b); // a == 2, b == 0
    for (int i = 0; i &amp;lt; 10; i++) {
        i == 0 || printf(&amp;quot; &amp;quot;); //å¦‚æœ i != 0,åˆ™è¾“å‡ºç©ºæ ¼ã€‚
        i != 0 &amp;amp;&amp;amp; printf(&amp;quot; &amp;quot;); //å¦‚æœ i != 0,åˆ™è¾“å‡ºç©ºæ ¼ã€‚
        printf(&amp;quot;%d&amp;quot;, i);
    }
    printf(&amp;quot;\n&amp;quot;);
    int cnt = 0;
    for (int i = 0; i &amp;lt; 5; ++i) {
        int val = rand() % 100;// éšæœºå‡º0--99çš„æ•´æ•°ã€‚
        i &amp;amp;&amp;amp; printf(&amp;quot; &amp;quot;);
        printf(&amp;quot;%d&amp;quot;, val);
        cnt += (val &amp;amp; 1); //valä¸ºå¥‡æ•°æ—¶ï¼Œ(val &amp;amp; 1) == 1ã€‚valä¸ºå¶æ•°æ—¶ï¼Œï¼ˆval&amp;amp;1ï¼‰==0
    }
    printf(&amp;quot;\n&amp;quot;);
    printf(&amp;quot;odd: %d\n&amp;quot;, cnt);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4å¾ªç¯ç»“æ„æ¼”ç¤ºä»£ç &#34;&gt;4.å¾ªç¯ç»“æ„æ¼”ç¤ºä»£ç &lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int is_reverse(int, int);
int is_prime(int);

int main() {
    int n, x, digit = 0;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
    x = n;
    do {
        digit += 1;
        x /= 10;
    } while (x);
    printf(&amp;quot;%d has %d digit!\n&amp;quot;, n, digit);
    printf(&amp;quot;%s\n&amp;quot;, is_reverse(n, 10) ? &amp;quot;YES&amp;quot; : &amp;quot;NO&amp;quot;);
    printf(&amp;quot;%s is prime\n&amp;quot;, is_prime(n) ? &amp;quot;YES&amp;quot; : &amp;quot;NO&amp;quot;);
    return 0;
}

int is_reverse(int n, int base) {
    if (n &amp;lt; 0) return 0;
    int sum = 0, x = n;
    while(x) {
        sum = sum * base + x % base;
        x /= base;
    }
    return sum == n;
}

int is_prime(int n) {
    for (int i = 2; i * i &amp;lt;= n; i++) {
        if (n % i == 0) return 0;
    }
    return 1;
}
&lt;/code&gt;&lt;/pre&gt;
">Cè¯­è¨€-3.ç¨‹åºæµç¨‹æ§åˆ¶æ–¹æ³•</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/Cè¯­è¨€-2.æ•°å­¦è¿ç®—/"" data-c="
          &lt;h2 id=&#34;1cè¯­è¨€åŸºæœ¬è¿ç®—ç¬¦&#34;&gt;1.Cè¯­è¨€åŸºæœ¬è¿ç®—ç¬¦&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;a = b; // = ï¼š èµ‹å€¼è¿ç®—ç¬¦
a = (b + c) * d; // +ã€-ã€*ã€/ã€ï¼ˆï¼‰ï¼šåŸºæœ¬å››åˆ™è¿ç®—ç¬¦
a = b % 2; // % ï¼šæ±‚ä½™è¿ç®—ç¬¦ï¼ˆå–æ¨¡è¿ç®—ç¬¦ï¼‰
a = -b | c;  // &amp;amp;ã€|ã€^ã€~ ï¼šä½è¿ç®—ï¼ˆäºŒè¿›åˆ¶ï¼‰
a = b &amp;gt;&amp;gt; 2; // &amp;lt;&amp;lt;ã€&amp;gt;&amp;gt; ï¼šå·¦ç§»å’Œå³ç§»ï¼ˆäºŒè¿›åˆ¶ï¼‰
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2cè¯­è¨€ä¸­çš„æ•°å­¦å‡½æ•°åº“&#34;&gt;2.Cè¯­è¨€ä¸­çš„æ•°å­¦å‡½æ•°åº“&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;math.h&amp;gt;  // å¤´æ–‡ä»¶
int  main() {
    int a, n;
    scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;a, &amp;amp;n);
    int ans = pow(a, n); // æŒ‡æ•°å‡½æ•°ã€‚
    //pow()å‡½æ•°åŸå‹ï¼šdouble pow(double a, double b);
    int ans = sqrt(n); // å¼€å¹³æ–¹å‡½æ•°ã€‚
    //sqrt()å‡½æ•°åŸå‹ï¼šdouble sqrt(double x);
    int ans = fabs(n); // å®æ•°ç»å¯¹å€¼å‡½æ•°ã€‚
    //fabs()å‡½æ•°åŸå‹ï¼šdouble fabs(double x);
    int ans = abs(n); // å¤´æ–‡ä»¶ï¼ˆstdlib.hï¼‰ï¼Œæ•´æ•°ç»å¯¹å€¼å‡½æ•°ã€‚
    //abs()å‡½æ•°åŸå‹ï¼šint abs(int x);
    int ans = ceil(n); // ä¸Šå–æ•´å‡½æ•°ï¼›
    //ceil()å‡½æ•°åŸå‹:double ceil(double x);
    int ans = floor(n); //ä¸‹å–æ•´å‡½æ•°ï¼›
    //floor()å‡½æ•°åŸå‹ï¼šdouble floor(double x);
    int ans = log(n); // ä»¥eä¸ºåº•å¯¹æ•°å‡½æ•°ã€‚
    //log()å‡½æ•°åŸå‹ï¼šdouble log(double x);
    int ans = log10(n); // ä»¥10ä¸ºåº•å¯¹æ•°å‡½æ•°ã€‚
    //log10()å‡½æ•°åŸå‹ï¼šdouble log10(double x);
    int ans = acos(n); // åä½™å¼¦å‡½æ•°(arccos())ï¼›
    //acos()å‡½æ•°åŸå‹ï¼šdouble acos(double x);
    //pi = acos(-1) = 3.1415923...
    return 0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3ç»ƒä¹ é¢˜&#34;&gt;3.ç»ƒä¹ é¢˜&lt;/h2&gt;
&lt;h3 id=&#34;1è¯·å†™ä¸€ä¸ªç¨‹åºè¾“å…¥ä¸€ä¸ªæ•°å­—x-è¾“å‡ºæ•°å­—xçš„ç«‹æ–¹æ ¹&#34;&gt;1.è¯·å†™ä¸€ä¸ªç¨‹åºï¼Œè¾“å…¥ä¸€ä¸ªæ•°å­—x, è¾“å‡ºæ•°å­—xçš„ç«‹æ–¹æ ¹ã€‚&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;math.h&amp;gt;

int main() {
    double x;
    scanf(&amp;quot;%lf&amp;quot;, &amp;amp;x);
    printf(&amp;quot;%.2lf&amp;quot;, pow(x, (1.0 / 3)));
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2è¯·å†™ä¸€ä¸ªç¨‹åºè¯»å…¥ä¸€ä¸ªè§’åº¦å€¼å°†è§’åº¦å€¼è½¬ä¸ºå¼§åº¦å€¼&#34;&gt;2.è¯·å†™ä¸€ä¸ªç¨‹åºï¼Œè¯»å…¥ä¸€ä¸ªè§’åº¦å€¼ï¼Œå°†è§’åº¦å€¼è½¬ä¸ºå¼§åº¦å€¼ã€‚&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;math.h&amp;gt;
#define PI acos(-1)

int main() {
    double x;
    scanf(&amp;quot;%lf&amp;quot;, &amp;amp;x);
    printf(&amp;quot;%.2lf&amp;quot;, PI / 180.0 * x);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4æ•°å­¦è¿ç®—æ¼”ç¤ºä»£ç &#34;&gt;4.æ•°å­¦è¿ç®—æ¼”ç¤ºä»£ç &lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
    int a = 7, b = 3, c;
    int *p = &amp;amp;a; // pæ˜¯açš„åœ°å€ï¼Œ*pæ˜¯açš„å€¼ã€‚
    (*p)--; // (*p)-- = 7-1ï¼Œa == 6ã€‚ *p--,å³ç»“åˆï¼Œå€¼ä¸å˜ï¼Œ a == 7ã€‚
    printf(&amp;quot;a = %d\n&amp;quot;, a);
    printf(&amp;quot;a = %d, b = %d\n&amp;quot;, a, b);
    //ä½¿ç”¨æŒ‰ä½å¼‚æˆ–è¿ç®—ï¼ˆ^ï¼‰è¿›è¡Œå€¼äº¤æ¢ï¼Œ swap
    a ^= b; // a = a ^ b
    b ^= a; // b = b ^ a ^ b = a
    a ^= b; // a = a ^ b ^ a = b
    printf(&amp;quot;swap: a = %d, b = %d\n&amp;quot;, a, b);
    return 0;
}
/*å…³äºè´Ÿæ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºæ–¹æ³•
0 ï¼š0000 0000 0000 0000ï¼ˆ16 ä½ï¼‰
-1 == 0 - 1 ï¼›1111 1111 1111 1111
1 ï¼š0000 0000 0000 0001
1 çš„åç  ï¼š 1111 1111 1111 1110
-1 == 1çš„åç åŠ 1
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5inttypeså¤´æ–‡ä»¶æ¼”ç¤ºä»£ç &#34;&gt;5.inttypeså¤´æ–‡ä»¶æ¼”ç¤ºä»£ç &lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;inttypes.h&amp;gt; //æ•´æ•°æ•°æ®ç±»å‹å¤´æ–‡ä»¶ï¼Œä»£ç å¯ç§»æ¤æ€§å¼ºã€‚
//å› ä¸ºä¸åŒçš„ç³»ç»Ÿï¼Œintæ‰€å çš„å­—èŠ‚æ•°æ˜¯ä¸åŒçš„ï¼Œ16ä½ç³»ç»Ÿå 2ä¸ªå­—èŠ‚ï¼Œ32å’Œ64ä½ç³»ç»Ÿå 4ä¸ªå­—èŠ‚
int main() {
    int32_t a = 70000;
    printf(&amp;quot;%s\n&amp;quot;, PRId32); // PRIdxæ˜¯ä¸€ä¸ªå®ï¼Œxå¯ä»¥æ˜¯ï¼ˆ8ï¼Œ16ï¼Œ32ï¼Œ64ï¼‰
    //åœ¨64ä½ç³»ç»Ÿä¸‹ï¼ŒPRId32ä¸º &amp;quot;d&amp;quot;ã€‚
    //printf(&amp;quot;helloworld&amp;quot;) == printf(&amp;quot;hello&amp;quot; &amp;quot;wolrd&amp;quot;);
    printf(&amp;quot;%&amp;quot; PRId32 &amp;quot;\n&amp;quot;, a); // printf(&amp;quot;%d\n&amp;quot;, a)
    printf(&amp;quot;INT32_MIN = &amp;quot; &amp;quot;%&amp;quot; PRId32 &amp;quot;INT32_MAX = &amp;quot; &amp;quot;%&amp;quot; PRId32 &amp;quot;\n&amp;quot;, INT32_MIN, INT32_MAX);
    //INTx_MINï¼šxå¯ä»¥æ˜¯ï¼ˆ8ï¼Œ16ï¼Œ32ï¼Œ64ï¼‰ï¼Œæœ€å°å€¼ã€‚
    //INT16_MINï¼š-32768ï¼ŒINT32_MINï¼š-2147483648
    //INTx_MAXï¼šxå¯ä»¥æ˜¯ï¼ˆ8ï¼Œ16ï¼Œ32ï¼Œ63ï¼‰ï¼Œæœ€å¤§å€¼ã€‚
    //INT16_MAXï¼š32767ï¼ŒINT32_MAXï¼š2147483647
    return 0;
}
/*
æœ‰ç¬¦å·16ä½æœ€å¤§å€¼äºŒè¿›åˆ¶è¡¨ç¤ºï¼ˆç¬¬ä¸€ä½ç¬¦å·ä½ï¼‰ï¼š0111 1111 1111 1111
æœ€å°å€¼è¡¨ç¤ºï¼š1000 0000 0000 0000
*/
&lt;/code&gt;&lt;/pre&gt;
">Cè¯­è¨€-2.æ•°å­¦è¿ç®—</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/C++ æ‰‹å†™æ™ºèƒ½æŒ‡é’ˆ(shared_ptr)/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#ifndef _SHARED_PTR_H
#define _SHARED_PTR_H

#define BEGINS(x) namespace x {
#define END(x) }

BEGINS(ZL)

template&amp;lt;typename T&amp;gt;
class shared_ptr {
public:
    shared_ptr();                      // é»˜è®¤æ„é€ å‡½æ•°
    shared_ptr(T *);                   // æœ‰å‚æ„é€ å‡½æ•°
    shared_ptr(const shared_ptr&amp;lt;T&amp;gt; &amp;amp;); // æ‹·è´æ„é€ å‡½æ•°
    T *operator-&amp;gt;() { return _ptr; }   // -&amp;gt; ç¬¦å·é‡è½½
    T &amp;amp;operator*() { return *_ptr; }   // *  ç¬¦å·é‡è½½
    int use_count() { return cnt ? *cnt : 0; } // è·å– å¼•ç”¨è®¡æ•°
    shared_ptr&amp;lt;T&amp;gt; &amp;amp;operator=(const shared_ptr&amp;lt;T&amp;gt; &amp;amp;); // èµ‹å€¼ç¬¦å·é‡è½½
    ~shared_ptr();                     // ææ„å‡½æ•°
private:
    void add_count();    // å¢åŠ  è®¡æ•° 
    void reduce_count(); // å‡å°‘ è®¡æ•°
    int *cnt;            // è®¡æ•°æŒ‡é’ˆ   
    T *_ptr;             // ç±»å‹æŒ‡é’ˆ
};

template&amp;lt;typename T&amp;gt;
shared_ptr&amp;lt;T&amp;gt;::shared_ptr() : _ptr(nullptr), cnt(nullptr) {}
template&amp;lt;typename T&amp;gt;
shared_ptr&amp;lt;T&amp;gt;::shared_ptr(T *ptr) : _ptr(ptr), cnt(new int(1)) {}
template&amp;lt;typename T&amp;gt;
shared_ptr&amp;lt;T&amp;gt;::shared_ptr(const shared_ptr&amp;lt;T&amp;gt; &amp;amp;p) : _ptr(p._ptr), cnt(p.cnt) {
    add_count();
}

template&amp;lt;typename T&amp;gt;
void shared_ptr&amp;lt;T&amp;gt;::reduce_count() {
    if (cnt != nullptr) {
        *cnt -= 1;
        if (*cnt == 0) {
            delete _ptr;
            delete cnt;
        }
    }
    return ;
}

template&amp;lt;typename T&amp;gt;
void shared_ptr&amp;lt;T&amp;gt;::add_count() {
    if (cnt != nullptr) {
        *cnt += 1;
    }
    return ;
}

template&amp;lt;typename T&amp;gt;
shared_ptr&amp;lt;T&amp;gt; &amp;amp;shared_ptr&amp;lt;T&amp;gt;::operator=(const shared_ptr&amp;lt;T&amp;gt; &amp;amp;p) {
    if (this-&amp;gt;_ptr != p._ptr) {   // å½“èµ‹å€¼çš„å¯¹è±¡ä¸ä¸€è‡´æ—¶ï¼Œæ‰æ“ä½œ
        reduce_count();
        this-&amp;gt;_ptr = p._ptr;
        this-&amp;gt;cnt = p.cnt;
        add_count();
    }
    return *this;
}

template&amp;lt;typename T&amp;gt;
shared_ptr&amp;lt;T&amp;gt;::~shared_ptr() {
    reduce_count();
    this-&amp;gt;_ptr = nullptr;
    this-&amp;gt;cnt = nullptr;
}

END(ZL)

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;quot;./shared_ptr.h&amp;quot;
#include &amp;lt;iostream&amp;gt;

class A {
public:
    A() {
        std::cout &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;quot;defalut constructor&amp;quot; &amp;lt;&amp;lt; std::endl;
    }
    ~A() {
        std::cout &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;quot;deconstructor&amp;quot; &amp;lt;&amp;lt; std::endl;
    }
};

int main() {
    
    ZL::shared_ptr&amp;lt;A&amp;gt; p(new A());
    ZL::shared_ptr&amp;lt;A&amp;gt; p1(new A());

    std::cout &amp;lt;&amp;lt; &amp;quot;p_cnt: &amp;quot; &amp;lt;&amp;lt; p.use_count() &amp;lt;&amp;lt; &amp;quot; p1_cnt: &amp;quot; &amp;lt;&amp;lt; p1.use_count() &amp;lt;&amp;lt; std::endl;
    
    ZL::shared_ptr&amp;lt;A&amp;gt; p2(p);
    std::cout &amp;lt;&amp;lt; &amp;quot;p_cnt: &amp;quot; &amp;lt;&amp;lt; p.use_count() &amp;lt;&amp;lt; &amp;quot; p1_cnt: &amp;quot; &amp;lt;&amp;lt; p1.use_count() &amp;lt;&amp;lt; &amp;quot; p2_cnt: &amp;quot; &amp;lt;&amp;lt; p2.use_count() &amp;lt;&amp;lt; std::endl;

    ZL::shared_ptr&amp;lt;int&amp;gt; pi(new int);
    ZL::shared_ptr&amp;lt;char&amp;gt; pc(new char());
    std::cout &amp;lt;&amp;lt; &amp;quot;pi_cnt: &amp;quot; &amp;lt;&amp;lt; pi.use_count() &amp;lt;&amp;lt; &amp;quot; pc_cnt: &amp;quot; &amp;lt;&amp;lt; pc.use_count() &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">C++ æ‰‹å†™æ™ºèƒ½æŒ‡é’ˆ(shared_ptr)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/C++ æ‰‹å†™çº¿ç¨‹æ± /"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#ifndef _THREADPOOL_H
#define _THREADPOOL_H

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;mutex&amp;gt;
#include &amp;lt;condition_variable&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;unordered_map&amp;gt;
#include &amp;lt;functional&amp;gt;

#define MAXTHREAD 4
#define BEGINS(x) namespace x {
#define END(x) }

BEGINS(ZL)

// ä»»åŠ¡ç±»(æ³›å‹)ï¼š
//      1.é€šè¿‡bind æŠŠå‚æ•°ç»‘å®šäºå¯è°ƒç”¨å¯¹è±¡func,äº§ç”Ÿä¸€ä¸ªæ–°çš„å¯è°ƒç”¨å¯¹è±¡
//      2. run(),è®©ä»»åŠ¡è·‘èµ·æ¥
class Task {
public:
    template&amp;lt;typename FUNC_T, typename ...ARGS&amp;gt;
    Task(FUNC_T &amp;amp;&amp;amp;, ARGS...);
    void run();
private:
    std::function&amp;lt;void()&amp;gt; func;
};

template&amp;lt;typename FUNC_T, typename ...ARGS&amp;gt;
Task::Task(FUNC_T &amp;amp;&amp;amp;func, ARGS... args) {
    this-&amp;gt;func = std::bind(func, std::forward&amp;lt;ARGS&amp;gt;(args)...);
}

void Task::run() {
    func();
    return ;
}

// çº¿ç¨‹æ± ï¼š
// 1.åˆ›å»ºnä¸ªçº¿ç¨‹,å¹¶åˆå§‹åŒ–ï¼ˆæ¯ä¸ªçº¿ç¨‹åŠ å…¥å·¥ä½œçº¿ç¨‹ï¼‰;
// 2.å·¥ä½œçº¿ç¨‹ï¼šå…ˆæ‹¿åˆ°çº¿ç¨‹id, å¹¶æŠŠè¯¥çº¿ç¨‹çŠ¶æ€å€¼ä¸º trueã€‚ç„¶åä»ä»»åŠ¡é˜Ÿåˆ—æ‹¿åˆ°ä»»åŠ¡ï¼Œå¹¶è·‘èµ·æ¥ï¼Œä»»åŠ¡è·‘å®Œè¦delete;
// 3.ä»»åŠ¡é˜Ÿåˆ—ï¼ˆpushæ“ä½œï¼‰ï¼šä¸ºäº†ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œéœ€è¦ä¸Šé”ï¼Œå¹¶æœ‰ä»»åŠ¡åè§¦å‘æ¡ä»¶å˜é‡ï¼›
// 4.ä»»åŠ¡é˜Ÿåˆ—ï¼ˆpopæ“ä½œï¼‰ï¼šä¸ºäº†ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œéœ€è¦ä¸Šé”ï¼Œæ²¡æœ‰æœ‰ä»»åŠ¡ï¼Œä¼šé˜»å¡ç­‰å¾…ï¼›
// 5.ç»“æŸçº¿ç¨‹ï¼šå…ˆæ‹¿åˆ°çº¿ç¨‹id,å¹¶æŠŠè¯¥çº¿ç¨‹çŠ¶æ€å€¼ä¸º falseã€‚ å¹¶åŠ åˆ°ä»»åŠ¡é˜Ÿåˆ—ï¼Œ æ¯ä¸ªçº¿ç¨‹join();

class ThreadPool {
public:
    ThreadPool(int n = MAXTHREAD);
    template&amp;lt;typename FUNC_T, typename ...ARGS&amp;gt;
    void TaskQuePush(FUNC_T &amp;amp;&amp;amp;, ARGS...);
    void stop();

private:
    std::vector&amp;lt;std::thread *&amp;gt; threads;
    std::queue&amp;lt;Task *&amp;gt; taskQue;
    std::unordered_map&amp;lt;std::thread::id, bool&amp;gt; status;
    std::mutex m_mutex;
    std::condition_variable m_cond;

    Task *TaskQuePop();
    void work_thread();
    void stop_thread();
};

ThreadPool::ThreadPool(int n) {
    for (int i = 0; i &amp;lt; n; i++) {
        threads.push_back(new std::thread(&amp;amp;ThreadPool::work_thread, this));
    }
}

template&amp;lt;typename FUNC_T, typename ...ARGS&amp;gt;
void ThreadPool::TaskQuePush(FUNC_T &amp;amp;&amp;amp;func, ARGS... args) {
    std::unique_lock&amp;lt;std::mutex&amp;gt; lock(m_mutex);
    taskQue.push(new Task(func, std::forward&amp;lt;ARGS&amp;gt;(args)...));
    m_cond.notify_one();
    return ;
}

void ThreadPool::work_thread() {
    std::thread::id id = std::this_thread::get_id();
    status[id] = true;
    while (status[id]) {
        Task *t = this-&amp;gt;TaskQuePop();
        t-&amp;gt;run();
        delete t;
    }
    return ;
}

Task *ThreadPool::TaskQuePop() {
    std::unique_lock&amp;lt;std::mutex&amp;gt; lock(m_mutex);
    while (taskQue.empty()) {
        m_cond.wait(lock);
    }
    Task *t = taskQue.front();
    taskQue.pop();
    return t;
}

void ThreadPool::stop_thread() {
    std::thread::id id = std::this_thread::get_id();
    status[id] = false;
    return ;
}

void ThreadPool::stop() {
    for (int i = 0; i &amp;lt; threads.size(); i++) {
        this-&amp;gt;TaskQuePush(&amp;amp;ThreadPool::stop_thread, this);
    }
    for (auto it : threads) {
        it-&amp;gt;join();
    }
    return ;
}

END(ZL)

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;quot;./ThreadPool.h&amp;quot;

void func(int a, int b, int c) {
    std::cout &amp;lt;&amp;lt; &amp;quot;func id : &amp;quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt; a + b + c &amp;lt;&amp;lt; std::endl;
    return ;
}

int main() {
    ZL::ThreadPool tp;
    for (int i = 0; i &amp;lt; 100; i++) {
        tp.TaskQuePush(func, i, 2 * i, 3 * i);
    }
    tp.stop();
    std::cout &amp;lt;&amp;lt; &amp;quot;hello world&amp;quot; &amp;lt;&amp;lt; std::endl;
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
">C++ æ‰‹å†™çº¿ç¨‹æ± </a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/Cè¯­è¨€-1.è¾“å…¥è¾“å‡ºå­¦ä¹ /"" data-c="
          &lt;h1 id=&#34;ä¸€-cè¯­è¨€å…¥é—¨åŸºç¡€&#34;&gt;ä¸€ã€Cè¯­è¨€å…¥é—¨åŸºç¡€&lt;/h1&gt;
&lt;h2 id=&#34;1scanfè¾“å…¥å‡½æ•°è¯´æ˜&#34;&gt;1.scanf()è¾“å…¥å‡½æ•°è¯´æ˜&lt;/h2&gt;
&lt;p&gt;å¤´æ–‡ä»¶ï¼š #include &amp;lt;stdio.h&amp;gt;&lt;/p&gt;
&lt;p&gt;å‡½æ•°åŸå‹ï¼š int scanf(const char *format, ...);&lt;/p&gt;
&lt;p&gt;format: æ ¼å¼æ§åˆ¶å­—ç¬¦ä¸²&lt;/p&gt;
&lt;p&gt;...ï¼šå¯å˜å‚æ•°åˆ—è¡¨&lt;/p&gt;
&lt;p&gt;è¿”å›å€¼ï¼šæˆåŠŸè¯»å…¥çš„å‚æ•°ä¸ªæ•°&lt;/p&gt;
&lt;h2 id=&#34;2printfè¾“å‡ºå‡½æ•°è¯´æ˜&#34;&gt;2.printf()è¾“å‡ºå‡½æ•°è¯´æ˜&lt;/h2&gt;
&lt;p&gt;å¤´æ–‡ä»¶ï¼š &lt;mark&gt;&lt;strong&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;å‡½æ•°åŸå‹ï¼š &lt;mark&gt;&lt;strong&gt;int printf(const char *format, ...);&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;format: æ ¼å¼æ§åˆ¶å­—ç¬¦ä¸²&lt;/p&gt;
&lt;p&gt;...: å¯å˜å‚æ•°åˆ—è¡¨&lt;/p&gt;
&lt;p&gt;å‡½æ•°è¿”å›å€¼ï¼šè¾“å‡ºå­—ç¬¦çš„æ•°é‡&lt;/p&gt;
&lt;h2 id=&#34;3ç»ƒä¹ é¢˜&#34;&gt;3.ç»ƒä¹ é¢˜&lt;/h2&gt;
&lt;h3 id=&#34;1-è¯·ä½¿ç”¨printfå‡½æ•°æ±‚è§£ä¸€ä¸ªæ•°å­—nçš„åè¿›åˆ¶è¡¨ç¤ºçš„æ•°å­—&#34;&gt;1. è¯·ä½¿ç”¨printf()å‡½æ•°ï¼Œæ±‚è§£ä¸€ä¸ªæ•°å­—nçš„åè¿›åˆ¶è¡¨ç¤ºçš„æ•°å­—ã€‚&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
    int n;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
    int ans = printf(&amp;quot;%d&amp;quot;, n);
    printf(&amp;quot;%d has %d digits\n&amp;quot;,n, ans);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-è¯·å†™ä¸€ä¸ªç¨‹åºè¯»å…¥ä¸€ä¸ªè¡Œå­—ç¬¦ä¸²å¯èƒ½åŒ…å«ç©ºæ ¼è¾“å‡ºè¿™ä¸ªå­—ç¬¦ä¸²ä¸­å­—ç¬¦çš„æ•°é‡&#34;&gt;2. è¯·å†™ä¸€ä¸ªç¨‹åºï¼Œè¯»å…¥ä¸€ä¸ªè¡Œå­—ç¬¦ä¸²ï¼ˆå¯èƒ½åŒ…å«ç©ºæ ¼ï¼‰ï¼Œè¾“å‡ºè¿™ä¸ªå­—ç¬¦ä¸²ä¸­å­—ç¬¦çš„æ•°é‡ã€‚&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
    char str[100];
    scanf(&amp;quot;%[^\n]s&amp;quot;, str);
    int ans = printf(&amp;quot;%s&amp;quot;, str);
    printf(&amp;quot;%s has %d digits\n&amp;quot;, str, ans);
    return 0;
}
/*
    while (~(scanf(&amp;quot;%[^\n]s&amp;quot;, str))) { //å¾ªç¯è¯»å…¥å­—ç¬¦ï¼Œé™¤äº†æ¢è¡Œï¼ˆ\nï¼‰
		getchar();   // éœ€è¦ç”¨getchar(),åæ‰ä¸€ä¸ªå­—ç¬¦ ï¼ˆ\nï¼‰
}
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-printfå‡½æ•°å®¶æ—ä»£ç æ¼”ç¤º&#34;&gt;3. printf()å‡½æ•°å®¶æ—ä»£ç æ¼”ç¤ºã€‚&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#define swap(a, b) {\
	__typeof(a) __temp = a;\
	a = b; b = __temp;\
}
int main() {
    int n;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); //stdin æ ‡å‡†è¾“å…¥æµ
    printf(&amp;quot;%d\n&amp;quot;, n); //stdout æ ‡å‡†è¾“å‡ºæµï¼Œstderr æ ‡å‡†é”™è¯¯è¾“å‡º
    //sprintf()å‡½æ•°åŸå‹ï¼š
    //int sprintf(char *str, const char *format, ...);
    char str[1000] = {0}, buffer[1000] = {0}, *p = str, *q = buffer;
    sprintf(str, &amp;quot;%d.%d.%d.%d&amp;quot;, 192, 168, 0, 1); // 192.168.0.1
    printf(&amp;quot;str = %s\n&amp;quot;, str);
    if (n &amp;amp; 1) {
        sprintf(q, &amp;quot;(%s)&amp;quot;, str);
        swap(p, q);
    }
    if (n &amp;amp; 2) {
        sprintf(q, &amp;quot;[%s]&amp;quot;, str);
        swap(p, q);
    }
    if (n &amp;amp; 4) {
        sprintf(q, &amp;quot;{%s}&amp;quot;, str);
        swap(p, q);
    }
    printf(&amp;quot;%s\n&amp;quot;, p);
    FILE *fout = fopen(&amp;quot;output&amp;quot;, &amp;quot;w&amp;quot;);
    fprint(fout, &amp;quot;str = %s&amp;quot;, p);
    fprintf(stdout, &amp;quot;stdout = %s\n&amp;quot;, p);
    fprintf(stderr, &amp;quot;stderr = %s\n&amp;quot;, p);
    fclose(fout);
    return 0;
}
/*
FILE 1.æ‰“å¼€æ–‡ä»¶ å‡½æ•°åŸå‹ï¼š_CRTIMP FILE *__cdecel fopen(const char *, const char *); ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºæ–‡ä»¶åï¼Œ ç¬¬äºŒä¸ªå‚æ•°ä¸ºæ‰“å¼€æ¨¡å¼ï¼ˆa, w, r, a+, w+, r+ï¼‰;
ç”¨æ³•ï¼šFILE *fp = fopen(&amp;quot;æ–‡ä»¶å&amp;quot;ï¼Œ &amp;quot;æ‰“å¼€æ¨¡å¼&amp;quot;)ï¼›
2.å…³é—­æ–‡ä»¶ å‡½æ•°åŸå‹ï¼š â€”â€”CRTIMP int __cddecl fclose(FILE *);å…³é—­æˆåŠŸè¿”å›å€¼ä¸º 0ï¼Œå¦åˆ™è¿”å›éé›¶å€¼ã€‚
ç”¨æ³•ï¼šfclose(fp);

fprintf()å‡½æ•°åŸå‹ï¼šint fprintf(FILE *fp, const char *format, ...);
1.FILE *fp ä¸º stdout, è¾“å‡ºæ ‡å‡†è¾“å‡ºæµï¼›
2.FILE *fp ä¸º stderr, è¾“å‡ºé”™è¯¯æ ‡å‡†è¾“å‡ºæµï¼›
å¯ä»¥ç”¨é‡å®šå‘æ–‡ä»¶ï¼ˆ&amp;gt;ï¼‰,æŠŠæ ‡å‡†è¾“å‡ºå’Œé”™è¯¯æ ‡å‡†è¾“å‡ºåˆ†å¼€ã€‚
*/
&lt;/code&gt;&lt;/pre&gt;
">Cè¯­è¨€-1.è¾“å…¥è¾“å‡ºå­¦ä¹ </a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;æ¬¢è¿æ¥åˆ°æˆ‘çš„å°ç«™å‘€ï¼Œå¾ˆé«˜å…´é‡è§ä½ ï¼ğŸ¤&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;å…³äºæœ¬ç«™&#34;&gt;ğŸ  å…³äºæœ¬ç«™&lt;/h2&gt;
&lt;h2 id=&#34;åšä¸»æ˜¯è°&#34;&gt;ğŸ‘¨â€ğŸ’» åšä¸»æ˜¯è°&lt;/h2&gt;
&lt;h2 id=&#34;å…´è¶£çˆ±å¥½&#34;&gt;â›¹ å…´è¶£çˆ±å¥½&lt;/h2&gt;
&lt;h2 id=&#34;è”ç³»æˆ‘å‘€&#34;&gt;ğŸ“¬ è”ç³»æˆ‘å‘€&lt;/h2&gt;
">å…³äº</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/hello-gridea/"" data-c="
          &lt;p&gt;ğŸ‘  æ¬¢è¿ä½¿ç”¨ &lt;strong&gt;Gridea&lt;/strong&gt; ï¼&lt;br&gt;
âœï¸  &lt;strong&gt;Gridea&lt;/strong&gt; ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea ä¸»é¡µ&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;ç¤ºä¾‹ç½‘ç«™&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;ç‰¹æ€§&#34;&gt;ç‰¹æ€§ğŸ‘‡&lt;/h2&gt;
&lt;p&gt;ğŸ“  ä½ å¯ä»¥ä½¿ç”¨æœ€é…·çš„ &lt;strong&gt;Markdown&lt;/strong&gt; è¯­æ³•ï¼Œè¿›è¡Œå¿«é€Ÿåˆ›ä½œ&lt;/p&gt;
&lt;p&gt;ğŸŒ‰  ä½ å¯ä»¥ç»™æ–‡ç« é…ä¸Šç²¾ç¾çš„å°é¢å›¾å’Œåœ¨æ–‡ç« ä»»æ„ä½ç½®æ’å…¥å›¾ç‰‡&lt;/p&gt;
&lt;p&gt;ğŸ·ï¸  ä½ å¯ä»¥å¯¹æ–‡ç« è¿›è¡Œæ ‡ç­¾åˆ†ç»„&lt;/p&gt;
&lt;p&gt;ğŸ“‹  ä½ å¯ä»¥è‡ªå®šä¹‰èœå•ï¼Œç”šè‡³å¯ä»¥åˆ›å»ºå¤–éƒ¨é“¾æ¥èœå•&lt;/p&gt;
&lt;p&gt;ğŸ’»  ä½ å¯ä»¥åœ¨ &lt;strong&gt;Windows&lt;/strong&gt;ï¼Œ&lt;strong&gt;MacOS&lt;/strong&gt; æˆ– &lt;strong&gt;Linux&lt;/strong&gt; è®¾å¤‡ä¸Šä½¿ç”¨æ­¤å®¢æˆ·ç«¯&lt;/p&gt;
&lt;p&gt;ğŸŒ  ä½ å¯ä»¥ä½¿ç”¨ &lt;strong&gt;ğ–¦ğ—‚ğ—ğ—ğ—ğ–» ğ–¯ğ–ºğ—€ğ–¾ğ—Œ&lt;/strong&gt; æˆ– &lt;strong&gt;Coding Pages&lt;/strong&gt; å‘ä¸–ç•Œå±•ç¤ºï¼Œæœªæ¥å°†æ”¯æŒæ›´å¤šå¹³å°&lt;/p&gt;
&lt;p&gt;ğŸ’¬  ä½ å¯ä»¥è¿›è¡Œç®€å•çš„é…ç½®ï¼Œæ¥å…¥ &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; æˆ– &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; è¯„è®ºç³»ç»Ÿ&lt;/p&gt;
&lt;p&gt;ğŸ‡¬ğŸ‡§  ä½ å¯ä»¥ä½¿ç”¨&lt;strong&gt;ä¸­æ–‡ç®€ä½“&lt;/strong&gt;æˆ–&lt;strong&gt;è‹±è¯­&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ğŸŒ  ä½ å¯ä»¥ä»»æ„ä½¿ç”¨åº”ç”¨å†…é»˜è®¤ä¸»é¢˜æˆ–ä»»æ„ç¬¬ä¸‰æ–¹ä¸»é¢˜ï¼Œå¼ºå¤§çš„ä¸»é¢˜è‡ªå®šä¹‰èƒ½åŠ›&lt;/p&gt;
&lt;p&gt;ğŸ–¥  ä½ å¯ä»¥è‡ªå®šä¹‰æºæ–‡ä»¶å¤¹ï¼Œåˆ©ç”¨ OneDriveã€ç™¾åº¦ç½‘ç›˜ã€iCloudã€Dropbox ç­‰è¿›è¡Œå¤šè®¾å¤‡åŒæ­¥&lt;/p&gt;
&lt;p&gt;ğŸŒ± å½“ç„¶ &lt;strong&gt;Gridea&lt;/strong&gt; è¿˜å¾ˆå¹´è½»ï¼Œæœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡ï¼Œå®ƒä¼šä¸åœå‘å‰ ğŸƒ&lt;/p&gt;
&lt;p&gt;æœªæ¥ï¼Œå®ƒä¸€å®šä¼šæˆä¸ºä½ ç¦»ä¸å¼€çš„ä¼™ä¼´&lt;/p&gt;
&lt;p&gt;å°½æƒ…å‘æŒ¥ä½ çš„æ‰åå§ï¼&lt;/p&gt;
&lt;p&gt;ğŸ˜˜ Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/äºŒå‰æ ‘-åˆ·é¢˜é›† /"" data-c="
          &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&#34;1-leetcode-100ç›¸åŒçš„æ ‘&#34;&gt;1. LeetCode-100(ç›¸åŒçš„æ ‘)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/bS964P7nwOAMcfF.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
// æ·±æœ
bool isSameTree(struct TreeNode* p, struct TreeNode* q){
    // å¦‚æœä¸¤ä¸ªæ ‘æˆ–å­æ ‘éƒ½ä¸ºç©ºï¼Œé‚£ä¹ˆç›¸åŒ
    if (p == NULL &amp;amp;&amp;amp; q == NULL) return true;
    // å…¶ä¸­ä¸€é¢—æ ‘æˆ–å­æ ‘ä¸ºç©ºï¼Œåˆ™åŒ¹é…å¤±è´¥
    else if (p == NULL || q == NULL) return false;
    // ä¸¤ä¸ªæ ‘å’Œå­æ ‘ä¸ä¸ºç©ºï¼Œä½†ç»“ç‚¹å€¼ä¸ç›¸ç­‰ï¼ŒåŒ¹é…å¤±è´¥
    else if (p-&amp;gt;val != q-&amp;gt;val) return false;
    // på·¦å­æ ‘å’Œqå·¦å­æ ‘ï¼Œæ·±æœåŒ¹é… &amp;amp;&amp;amp; på³å­æ ‘å’Œqå³å­æ ‘ï¼Œæ·±æœåŒ¹é…
    return isSameTree(p-&amp;gt;left, q-&amp;gt;left) &amp;amp;&amp;amp; isSameTree(p-&amp;gt;right, q-&amp;gt;right);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == NULL &amp;amp;&amp;amp; q == NULL) return true;
        else if (p == NULL || q == NULL) return false;
        else if (p-&amp;gt;val != q-&amp;gt;val) return false;
        return (isSameTree(p-&amp;gt;left, q-&amp;gt;left) &amp;amp;&amp;amp; isSameTree(p-&amp;gt;right, q-&amp;gt;right));
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2leetcode-101å¯¹ç§°äºŒå‰æ ‘&#34;&gt;2.LeetCode-101(å¯¹ç§°äºŒå‰æ ‘)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/mQqOY8FENJR15yX.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
// æ·±æœ
bool check(struct TreeNode *p, struct TreeNode *q) {
    // å¦‚æœä¸¤ä¸ªæ ‘æˆ–å­æ ‘éƒ½ä¸ºç©ºï¼Œé‚£ä¹ˆç›¸åŒ
    if (!p &amp;amp;&amp;amp; !q) return true;
    // å…¶ä¸­ä¸€é¢—æ ‘æˆ–å­æ ‘ä¸ºç©ºï¼Œåˆ™åŒ¹é…å¤±è´¥
    else if (!p || !q) return false;
    // ä¸¤ä¸ªæ ‘å’Œå­æ ‘ä¸ä¸ºç©ºï¼Œä½†ç»“ç‚¹å€¼ä¸ç›¸ç­‰ï¼ŒåŒ¹é…å¤±è´¥
    else if (p-&amp;gt;val != q-&amp;gt;val) return false;
    // på·¦å­æ ‘å’Œqå³å­æ ‘ï¼Œæ·±æœåŒ¹é… &amp;amp;&amp;amp; på³å­æ ‘å’Œqå·¦å­æ ‘ï¼Œæ·±æœåŒ¹é…
    return check(p-&amp;gt;left, q-&amp;gt;right) &amp;amp;&amp;amp; check(p-&amp;gt;right, q-&amp;gt;left);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool check(TreeNode *p, TreeNode *q) {
        if (p == NULL &amp;amp;&amp;amp; q == NULL) return true;
        else if (p == NULL || q == NULL) return false;
        else if (p-&amp;gt;val != q-&amp;gt;val) return false;
        return check(p-&amp;gt;left, q-&amp;gt;right) &amp;amp;&amp;amp; check(p-&amp;gt;right, q-&amp;gt;left);
    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        return check(root-&amp;gt;left, root-&amp;gt;right);
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3leetcode-102äºŒå‰æ ‘çš„å±‚åºéå†&#34;&gt;3.LeetCode-102(äºŒå‰æ ‘çš„å±‚åºéå†)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/8k9SJQ31qybIwOd.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
// ç”¨é˜Ÿåˆ—ï¼ŒBFS
int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    int **ans = (int **)malloc(sizeof(int *) * 10000);
    *returnColumnSizes = (int *)malloc(sizeof(int) * 1000);
    returnSize[0] = 0; 
    if (root == NULL) return ans;
    struct TreeNode *que[10000];
    int head = 0, tail = 0;
    que[tail++] = root;
    while (head != tail) {
        int cnt = tail - head; 
        ans[returnSize[0]] = (int *)malloc(sizeof(int) * cnt);
        for (int i = 0; i &amp;lt; cnt; ++i) {
            struct TreeNode *p = que[head++];
            ans[returnSize[0]][i] = p-&amp;gt;val;
            if (p-&amp;gt;left) que[tail++] = p-&amp;gt;left;
            if (p-&amp;gt;right) que[tail++] = p-&amp;gt;right; 
        }
        (*returnColumnSizes)[returnSize[0]] = cnt;
        returnSize[0]++;
    }
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) {
        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; ans;
        if (root == nullptr) return ans;
        queue&amp;lt;TreeNode *&amp;gt; que;
        que.push(root);
        while (!que.empty()) {
            vector&amp;lt;int&amp;gt; temp;
            int n = que.size();
            for (int i = 0; i &amp;lt; n; ++i) {
                TreeNode *p = que.front(); que.pop();
                temp.push_back(p-&amp;gt;val);
                if (p-&amp;gt;left) que.push(p-&amp;gt;left);
                if (p-&amp;gt;right) que.push(p-&amp;gt;right);
            }
            ans.push_back(temp);
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4leetcode-104äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦&#34;&gt;4.LeetCode-104(äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/TBgsaN419VhvMxH.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

int maxDepth(struct TreeNode* root){
    if (root == NULL) return 0;
    return fmax(maxDepth(root-&amp;gt;left), maxDepth(root-&amp;gt;right)) + 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        int ans = 0;
        queue&amp;lt;TreeNode *&amp;gt; que;
        que.push(root);
        while (!que.empty()) {
            int n = que.size();
            for (int i = 0; i &amp;lt; n; ++i) {
                auto p = que.front(); que.pop();
                if (p-&amp;gt;left) que.push(p-&amp;gt;left);
                if (p-&amp;gt;right) que.push(p-&amp;gt;right);
            }
            ans++;
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5leetcode-107äºŒå‰æ ‘çš„å±‚åºéå†ii&#34;&gt;5.LeetCode-107(äºŒå‰æ ‘çš„å±‚åºéå†â…¡)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/5jyvDhNEdeHpcux.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrderBottom(TreeNode* root) {
        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; ans;
        if (root == nullptr) return ans;
        queue&amp;lt;TreeNode *&amp;gt; que;
        que.push(root);
        while (!que.empty()) {
            int n = que.size();
            vector&amp;lt;int&amp;gt; temp;
            for (int i = 0; i &amp;lt; n; ++i) {
                auto node = que.front(); que.pop();
                temp.push_back(node-&amp;gt;val);
                if (node-&amp;gt;left) que.push(node-&amp;gt;left);
                if (node-&amp;gt;right) que.push(node-&amp;gt;right);
            }
            ans.push_back(temp);
        }
        std::reverse(ans.begin(), ans.end()); // æ•°ç»„ç¿»è½¬
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6leetcode-110å¹³è¡¡äºŒå‰æ ‘&#34;&gt;6.LeetCode-110(å¹³è¡¡äºŒå‰æ ‘)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/b6rKZC1GhVlY5HD.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 /* 
class Solution {
public:
    int getHeight(TreeNode *root) {
        if (root == nullptr) return 0;
        return max(getHeight(root-&amp;gt;left), getHeight(root-&amp;gt;right)) + 1;
    }
    // è‡ªé¡¶å‘ä¸‹ï¼Œå‰åºéå†
    bool isBalanced(TreeNode* root) {
        if (root == nullptr) return true;
        int l = getHeight(root-&amp;gt;left);
        int r = getHeight(root-&amp;gt;right);
        if (abs(l - r) &amp;gt; 1) return false;
        return isBalanced(root-&amp;gt;left) &amp;amp;&amp;amp; isBalanced(root-&amp;gt;right);
    }
};
*/
class Solution {
public:
    // è‡ªåº•å‘ä¸Šï¼Œååºéå†
    int getHeight(TreeNode *root) {
        if (root == nullptr) return 0;
        int l = getHeight(root-&amp;gt;left);
        int r = getHeight(root-&amp;gt;right);
        // å½“abs(l - r) &amp;gt; 1,æ ‘å¤±è¡¡æ—¶ï¼Œç›´æ¥è¿”å› -1ï¼›
        if (l == - 1 || r == -1 || abs(l - r) &amp;gt; 1) return -1;
        return max(l, r) + 1;  
    }
    bool isBalanced(TreeNode* root) {
        return getHeight(root) &amp;gt;= 0;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7leetcode-111äºŒå‰æ ‘çš„æœ€å°æ·±åº¦&#34;&gt;7.LeetCode-111(äºŒå‰æ ‘çš„æœ€å°æ·±åº¦)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/4gk7GNZKXoVunms.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 /*
class Solution {
public:
    // BFS
    int minDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        queue&amp;lt;pair&amp;lt;TreeNode*, int&amp;gt; &amp;gt; que; // æŠŠç»“ç‚¹å’Œå±‚æ•°ç”¨pair&amp;lt;&amp;gt;å­˜èµ·æ¥
        int ans = 0;
        que.emplace(root, 1); // emplace å¯ä»¥ä»£æ›¿push
        while (!que.empty()) {
            int n = que.size();
            auto p = que.front(); que.pop();
            TreeNode *node = p.first;
            int ans = p.second;
            if (!node-&amp;gt;left &amp;amp;&amp;amp; !node-&amp;gt;right) return ans; // æ²¡æœ‰ä¸‹ä¸€å±‚
            if (node-&amp;gt;left) que.emplace(node-&amp;gt;left, ans + 1); //ä¸‹ä¸€å±‚
            if (node-&amp;gt;right) que.emplace(node-&amp;gt;right, ans + 1); //ä¸‹ä¸€å±‚
        }
        return 0;
    }
};
*/
class Solution {
public:
// DFS ï¼Œè‡ªåº•å‘ä¸Šï¼Œååºéå†
    int minDepth(TreeNode* root) {
        if (root == nullptr) return 0; //æ²¡æœ‰ç»“ç‚¹
        int ans = INT_MAX; // å…¨å±€å˜é‡
        if (!root-&amp;gt;left &amp;amp;&amp;amp; !root-&amp;gt;right) return 1; // æ²¡æœ‰å·¦å³å­©å­ï¼Œé«˜ä¸º1
        // éå†å·¦å­æ ‘ï¼Œè¿”å›å·¦å­æ ‘çš„æœ€å°æ·±åº¦
        if (root-&amp;gt;left) ans = min(ans, minDepth(root-&amp;gt;left)); 
        // éå†å³å­æ ‘ï¼Œè¿”å›å·¦å­æ ‘çš„æœ€å°æ·±åº¦
        if (root-&amp;gt;right) ans = min(ans, minDepth(root-&amp;gt;right));
        return ans + 1; //æœ€å°å­©å­æ·±åº¦ + 1
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;8leetcode-112è·¯å¾„æ€»å’Œ&#34;&gt;8.LeetCode-112(è·¯å¾„æ€»å’Œ)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/ZWzOjMpCHhm8fiq.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // æ ¹å·¦å³ï¼Œå‰åºéå†ï¼ŒDFS
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) return false; // æ ‘ä¸ºç©ºæ—¶ï¼Œæ²¡æœ‰å€¼ï¼Œåˆ¤å®šå‡
        targetSum -= root-&amp;gt;val;
        // èµ°åˆ°å¶å­ç»“ç‚¹ï¼Œåˆ¤æ–­targetSum æ˜¯å¦ä¸º 0
        if (!root-&amp;gt;left &amp;amp;&amp;amp; !root-&amp;gt;right) return targetSum == 0;
        return hasPathSum(root-&amp;gt;left, targetSum) || hasPathSum(root-&amp;gt;right, targetSum);
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;9leetcode-226ç¿»è½¬äºŒå‰æ ‘&#34;&gt;9.LeetCode-226(ç¿»è½¬äºŒå‰æ ‘)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/wA73Q8XshvEMN9d.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // DFS, å‰åºéå†ï¼Œå„å­æ ‘å¶å­èŠ‚ç‚¹å…ˆäº¤æ¢
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) return root;
        // å…ˆéå†åˆ°å·¦å­æ ‘çš„å·¦å³å¶å­èŠ‚ç‚¹
        TreeNode *left = invertTree(root-&amp;gt;left); 
        TreeNode *right = invertTree(root-&amp;gt;right);
        // äº¤æ¢å­æ ‘å¶å­èŠ‚ç‚¹çš„æ“ä½œ
        root-&amp;gt;left = right;
        root-&amp;gt;right = left;
        return root; 
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;10leetcode-235äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ&#34;&gt;10.LeetCode-235(äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/m3z9B1LsRljfSUY.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // å¦‚æœp,qèŠ‚ç‚¹éƒ½å°äºrootç»“ç‚¹ï¼Œé‚£ä¹ˆç¥–å…ˆç»“ç‚¹ä¸€å®šåœ¨root-&amp;gt;right
        // å¦‚æœp,qèŠ‚ç‚¹éƒ½å¤§äºrootç»“ç‚¹ï¼Œé‚£ä¹ˆç¥–å…ˆç»“ç‚¹ä¸€å®šåœ¨root-&amp;gt;left
        // å¦‚æœp,qåœ¨rootçš„ä¸¤è¾¹ï¼Œé‚£ä¹ˆç¥–å…ˆå°±æ˜¯root(é€’å½’è¾¹ç•Œ)
        if (p-&amp;gt;val &amp;gt; root-&amp;gt;val &amp;amp;&amp;amp; q-&amp;gt;val &amp;gt; root-&amp;gt;val) {
            return lowestCommonAncestor(root-&amp;gt;right, p, q);
        } else if (p-&amp;gt;val &amp;lt; root-&amp;gt;val &amp;amp;&amp;amp; q-&amp;gt;val &amp;lt; root-&amp;gt;val) {
            return lowestCommonAncestor(root-&amp;gt;left, p, q);
        }
        return root;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;11leetcode-257äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„&#34;&gt;11.LeetCode-257(äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/8NEWOfZIxSPH6BG.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    void dfs(TreeNode *root, vector&amp;lt;string&amp;gt; &amp;amp;arr, string t) { // æ³¨æ„arrè¦ä¼ å¼•ç”¨
        // å‰åºéå†
        if (root != nullptr) {
            t += to_string (root-&amp;gt;val);
            // å¦‚æœè¯¥ç»“ç‚¹æ²¡æœ‰å­©å­ï¼Œé‚£ä¹ˆå¯ä»¥å°†stringåŠ å…¥vector
            if (root-&amp;gt;left == nullptr &amp;amp;&amp;amp; root-&amp;gt;right == nullptr) {
                arr.emplace_back(t);
            } else {
                // å¦‚æœè¯¥èŠ‚ç‚¹è¿˜æœ‰å­©å­ï¼Œç»§ç»­æ·±æœ
                t += &amp;quot;-&amp;gt;&amp;quot;;
                dfs(root-&amp;gt;left, arr, t);
                dfs(root-&amp;gt;right, arr, t);
            }
        } 
    }

    vector&amp;lt;string&amp;gt; binaryTreePaths(TreeNode* root) {
        vector&amp;lt;string&amp;gt; ans;
        if (root == nullptr) return ans;
        dfs(root, ans, &amp;quot;&amp;quot;);
        return ans;
    }
};

/*
class Solution {
public:
    // bfs åŒé˜Ÿåˆ—ï¼Œä¸€ä¸ªé˜Ÿåˆ—node, ä¸€ä¸ªé˜Ÿåˆ—è£…string
    vector&amp;lt;string&amp;gt; binaryTreePaths(TreeNode* root) {
        vector&amp;lt;string&amp;gt; ans;
        if (root == nullptr) return ans;
        queue&amp;lt;TreeNode *&amp;gt; node_que;
        queue&amp;lt;string&amp;gt; val_que;
        node_que.push(root);
        val_que.emplace(to_string (root-&amp;gt;val));
        while (!node_que.empty()) {
            auto p = node_que.front(); node_que.pop();
            string t = val_que.front(); val_que.pop();
            if (!p-&amp;gt;left &amp;amp;&amp;amp; !p-&amp;gt;right) ans.emplace_back(t);
            else {
                if (p-&amp;gt;left) {
                    node_que.push(p-&amp;gt;left);
                    // t ä¸è¦èµ‹å€¼ï¼Œè¿˜æ˜¯åŸæ¥çš„ t
                    val_que.emplace(t + &amp;quot;-&amp;gt;&amp;quot; + to_string (p-&amp;gt;left-&amp;gt;val));
                }
                if (p-&amp;gt;right) {
                    node_que.push(p-&amp;gt;right);
                    val_que.emplace(t + &amp;quot;-&amp;gt;&amp;quot; + to_string (p-&amp;gt;right-&amp;gt;val));
                }
            }
        }
        return ans;
    }
};
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12leetcode-297äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–&#34;&gt;12.LeetCode-297(äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/sW8Udwv5bzuZatG.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:
    void rserialize(TreeNode *root, string &amp;amp;t) {
        if (root == NULL) t += &amp;quot;N&amp;quot;;
        else {
            t += to_string (root-&amp;gt;val) + &amp;quot;.(&amp;quot;; // å‰é¢åŠ ä¸ªç‚¹ï¼Œåˆ†éš”æ•°å­—
            rserialize(root-&amp;gt;left, t);
            t += &amp;quot;,&amp;quot;;
            rserialize(root-&amp;gt;right, t);
            t += &amp;quot;)&amp;quot;;
        }
    }
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string ret = &amp;quot;&amp;quot;;
        rserialize(root, ret);
        cout &amp;lt;&amp;lt; ret &amp;lt;&amp;lt; endl;
        return ret;
    }
    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        TreeNode *p = NULL, *temp = NULL;
        stack&amp;lt;TreeNode *&amp;gt; stk;
        int flag = 0, minus = 0, x = 0;
        for (int i = 0; i &amp;lt; data.size(); ++i) {
            // è®¡ç®—æ•°å€¼
            if (data[i] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; data[i] &amp;lt;= &#39;9&#39;) {
                x = x * 10 + (data[i] - &#39;0&#39;);
                continue;
            }
            // æ ¹æ®æ ˆè¿˜åŸæ ‘
            switch (data[i]) {
                case &#39;(&#39;: stk.push(temp); flag = 0; break;
                case &#39;,&#39;: flag = 1; break;
                case &#39;)&#39;: p = stk.top(); stk.pop(); break;
                case &#39;N&#39;: p = NULL; break;
                case &#39;-&#39;: minus = 1; break;
                default: {
                    if (minus) {
                        temp = new TreeNode(0 - x); minus = 0; x = 0;
                    } else {
                        temp = new TreeNode(x); x = 0;
                    }
                    if (!stk.empty() &amp;amp;&amp;amp; flag == 0) {
                        (stk.top())-&amp;gt;left = temp;
                    } else if (!stk.empty() &amp;amp;&amp;amp; flag == 1) {
                        (stk.top())-&amp;gt;right = temp;
                    }
                } break;
            }
        }
        return p;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">äºŒå‰æ ‘-åˆ·é¢˜é›†</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/é˜Ÿåˆ—-åˆ·é¢˜é›† /"" data-c="
          &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&#34;1-leetcode-239æ»‘åŠ¨çª—å£æœ€å¤§å€¼&#34;&gt;1. LeetCode-239(æ»‘åŠ¨çª—å£æœ€å¤§å€¼)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/4zlhAbi9PyGmfTd.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// å•è°ƒé˜Ÿåˆ—
int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){
    int que[numsSize], head = 0, tail = 0; // åˆå§‹åŒ–é˜Ÿåˆ—
    int *ans = (int *)malloc(sizeof(int) * numsSize); 
    returnSize[0] = 0;
    for (int i = 0; i &amp;lt; k; ++i) {
        while (head != tail &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[que[tail - 1]]) {
            tail--; // ä¿æŒé˜Ÿåˆ—å•è°ƒé€’å‡ï¼Œé˜Ÿå°¾è¿›å‡ºè°ƒæ•´
        }
        que[tail++] = i; // å…¥é˜Ÿï¼ˆæ”¾å…ƒç´ ç¼–å·ï¼‰
    }
    ans[returnSize[0]++] = nums[que[head]];
    for (int i = k; i &amp;lt; numsSize; ++i) {
        while (head != tail &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[que[tail - 1]]) {
            tail--; // é˜Ÿå°¾è¿›å‡ºè°ƒæ•´
        }
        que[tail++] = i; // å…¥é˜Ÿï¼ˆæ”¾å…ƒç´ ç¼–å·ï¼‰
        while (i - k &amp;gt;= que[head]) head++; // (å½“å‰å…ƒç´ çš„ç¼–å·å‡å»çª—å£å¤§å°ï¼Œå¦‚æœé˜Ÿé¦–å…ƒç´ å·²å‡ºçª—å£éœ€åˆ æ‰)
        ans[returnSize[0]++] = nums[que[head]];
    }
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; maxSlidingWindow(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) {
        deque&amp;lt;int&amp;gt; deq;
        vector&amp;lt;int&amp;gt; ans;
        for (int i = 0; i &amp;lt; k; ++i) {
            while (!deq.empty() &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[deq.back()]) {
                deq.pop_back();
            }
            deq.push_back(i);
        }
        ans.push_back(nums[deq.front()]);
        for (int i = k; i &amp;lt; nums.size(); ++i) {
            while (!deq.empty() &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[deq.back()]) {
                deq.pop_back();
            }
            deq.push_back(i);
            while (i - k &amp;gt;= deq.front()) deq.pop_front();
            ans.push_back(nums[deq.front()]);
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2leetcode-225ç”¨é˜Ÿåˆ—å®ç°æ ˆ&#34;&gt;2.LeetCode-225(ç”¨é˜Ÿåˆ—å®ç°æ ˆ)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/R9JCyNYPKM5mxhp.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct {
    int que[10000], head, tail;
} MyStack;

/** Initialize your data structure here. */

MyStack* myStackCreate() {
    MyStack *s = (MyStack *)malloc(sizeof(MyStack));
    s-&amp;gt;head = s-&amp;gt;tail = 0;
    return s;
}

/** Push element x onto stack. */
void myStackPush(MyStack* obj, int x) {
    obj-&amp;gt;que[(obj-&amp;gt;tail)++] = x;
    return ;
}

/** Removes the element on top of the stack and returns that element. */
int myStackPop(MyStack* obj) {
    int t = obj-&amp;gt;que[obj-&amp;gt;tail - 1];
    (obj-&amp;gt;tail)--;
    return t;
}

/** Get the top element. */
int myStackTop(MyStack* obj) {
    return obj-&amp;gt;que[obj-&amp;gt;tail - 1];
}

/** Returns whether the stack is empty. */
bool myStackEmpty(MyStack* obj) {
    return obj-&amp;gt;head == obj-&amp;gt;tail;
}

void myStackFree(MyStack* obj) {
    if (obj == NULL) return ;
    free(obj);
    return ;
}

/**
 * Your MyStack struct will be instantiated and called as such:
 * MyStack* obj = myStackCreate();
 * myStackPush(obj, x);
 
 * int param_2 = myStackPop(obj);
 
 * int param_3 = myStackTop(obj);
 
 * bool param_4 = myStackEmpty(obj);
 
 * myStackFree(obj);
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class MyStack {
public:
    queue&amp;lt;int&amp;gt; que;
    /** Initialize your data structure here. */
    MyStack() {

    }
    
    /** Push element x onto stack. */
    void push(int x) {
        que.push(x);
        for (int i = 1; i &amp;lt; que.size(); ++i) {
            que.push(que.front());
            que.pop();
        }
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int t = que.front();
        que.pop();
        return t;

    }
    
    /** Get the top element. */
    int top() {
        return que.front();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return que.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj-&amp;gt;push(x);
 * int param_2 = obj-&amp;gt;pop();
 * int param_3 = obj-&amp;gt;top();
 * bool param_4 = obj-&amp;gt;empty();
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;&#34;&gt;&lt;/h3&gt;
">é˜Ÿåˆ—-åˆ·é¢˜é›† </a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/æ ˆ-åˆ·é¢˜é›† /"" data-c="
          &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&#34;1-leetcode-20æœ‰æ•ˆçš„æ‹¬å·&#34;&gt;1. LeetCode-20(æœ‰æ•ˆçš„æ‹¬å·)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/nvUDGuSHlgrWB7f.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// æ‹¬å·å¯¹ï¼Œå½“è¾“å…¥å³æ‹¬å·æ—¶ï¼Œè¾“å‡ºå·¦æ‹¬å·ï¼ˆæ–¹ä¾¿åˆ¤æ–­ï¼‰
char pair(char ch) { 
    if (ch == &#39;)&#39;) return &#39;(&#39;;
    else if (ch == &#39;]&#39;) return &#39;[&#39;;
    else if (ch == &#39;}&#39;) return &#39;{&#39;;
    return 0;
}

bool isValid(char * s){
    int len_s = strlen(s); // è·å–æ‹¬å·ä¸²çš„é•¿åº¦
    if (len_s == 0) return true; // æ²¡æœ‰æ‹¬å·æ—¶ï¼Œä¸ºtrue
    if (len_s &amp;amp; 1) return false; // å½“æ‹¬å·æ•°æ˜¯å¥‡æ•°æ˜¯ï¼Œä¸ºfalse
    char stack[len_s + 5]; // é™æ€æ•°ç»„æ ˆ
    int top = -1; // æ ˆæŒ‡é’ˆ
    // éå†æ‹¬å·ä¸²ï¼Œä¸ºå·¦æ‹¬å·æ—¶å…¥æ ˆï¼Œå½“æ ˆä¸ä¸ºç©ºæ—¶ï¼Œå¦‚å³æ‹¬å·ä¸å·¦æ‹¬å·åŒ¹é…ï¼Œå‡ºæ ˆã€‚
    for (int i = 0; s[i]; i++) {
        char ch = pair(s[i]); // æ ¹æ®æ‹¬å·å¯¹ï¼Œè¾“å…¥å³æ‹¬å·ï¼Œè¾“å‡ºå¯¹åº”çš„å·¦æ‹¬å·ï¼Œè¾“å…¥å·¦æ‹¬å·ï¼Œè¾“å‡º0
        if (ch) {
            // å¦‚æœæ˜¯å³æ‹¬å·
            // æƒ…å†µ1ï¼šå¦‚æœæ˜¯ç©ºæ ˆæˆ–æ‹¬å·ä¸åŒ¹é…ï¼Œç›´æ¥false
			// æƒ…å†µ2ï¼šå‡ºæ ˆ           
            if (top == -1 || stack[top] != ch) {
                return false;
            }
            top--;
        } else {
            // å·¦æ‹¬å·å…¥æ ˆ
            stack[++top] = s[i];
        }
    }
    return top == -1; // ç©ºæ ˆä¸ºtrue
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    bool isValid(string s) {
        int len_s = s.size(); 
        if (len_s == 0) return true;
        if (len_s &amp;amp; 1) return false;
        // ç”¨å“ˆå¸Œè¡¨æŠŠå·¦å³æ‹¬å·åšæˆé”®å€¼å¯¹
        unordered_map&amp;lt;char, char&amp;gt; pairs{{&#39;)&#39;, &#39;(&#39;}, {&#39;]&#39;, &#39;[&#39;}, {&#39;}&#39;, &#39;{&#39;}};
        stack&amp;lt;char&amp;gt; stk; 
        for (auto it : s) {
            // pairs.count()ï¼Œæœ‰keyè¿”å›1ï¼Œ æ— key è¿”å› 0
            if (pairs.count(it)) {
                if (stk.empty() || pairs[it] != stk.top()) return false;
                stk.pop();
            } else {
                stk.push(it);
            }
        }
        return stk.empty();
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2leetcode-42æ¥é›¨æ°´&#34;&gt;2.LeetCode-42(æ¥é›¨æ°´)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/7yEPWeYZ2UTq3mR.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// å•è°ƒæ ˆ
/*æ ˆå­˜å‚¨å•è°ƒé€’å‡æŸ±å­çš„ç¼–å·*/
int trap(int* height, int heightSize){
    // å½“æ²¡æœ‰æŸ±å­å’Œåªæœ‰ä¸€æ ¹æŸ±å­æ—¶ï¼Œ æ¥ä¸äº†é›¨æ°´
    if (heightSize == 0 || heightSize == 1) return 0;
    // åˆå§‹åŒ–æ ˆå’Œæ ˆæŒ‡é’ˆ
    int stack[heightSize + 5], top = -1, ans = 0;
    // éå†æ•°ç»„
    for (int i = 0; i &amp;lt; heightSize; ++i) {
        // æ ˆä¸ä¸ºç©ºï¼ˆæ ˆç©ºçš„è¯ï¼Œå°±æ²¡æœ‰å·¦è¾¹çš„æŸ±å­äº†ï¼Œæ¥ä¸äº†é›¨æ°´ï¼‰
        // å› ä¸ºæ˜¯å•è°ƒé€’å‡æ ˆï¼Œé‚£ä¹ˆå½“æœ‰æŸ±å­å¤§äºæ ˆé¡¶å…ƒç´ æ—¶ï¼Œå°±æœ‰å¯ä»¥ç§¯æ°´
        while (top != -1 &amp;amp;&amp;amp; height[i] &amp;gt; height[stack[top]]) {
            // ç›¸é‚»çš„æŸ±å­æ˜¯ä¸ä¼šç§¯æ°´çš„ï¼ŒæŠŠæ ˆé¡¶å…ƒç´ å½“å‡¹å‘ï¼Œæ ˆé¡¶ä¸‹é¢çš„å…ƒç´ æ˜¯å·¦è¾¹ç•Œï¼Œå½“å‰æŸ±å­æ˜¯å³è¾¹ç•Œ
            // å¦‚æœæ ˆé‡Œé¢çš„å…ƒç´ æœ‰å°äºå½“å‰æŸ±å­çš„éƒ½å¾€å¤–å¼¹
            // æ ˆé¡¶ä¸‹é¢æ²¡æœ‰å…ƒç´ ï¼Œç§¯ä¸äº†æ°´ï¼Œbreak
            if (--top == -1) break; 
            // ç§¯æ°´çš„é•¿åº¦ï¼Œæ³¨æ„ï¼šè¿˜éœ€è¦å‡å»1ã€‚(ä¾‹å¦‚æ ˆé¡¶æ˜¯2ï¼Œå½“å‰æ˜¯3ï¼Œæ ˆé¡¶ä¸‹æ˜¯1ï¼Œé‚£ä¹ˆå°±æ˜¯ 3 - 1 - 1 = 1)
            int len = i - stack[top] - 1; 
            // ç§¯æ°´çš„é«˜åº¦ï¼Œæ¯”è¾ƒå·¦å³è¾¹ç•Œçš„æŸ±å­çš„é«˜åº¦ï¼ˆå–å°å€¼ï¼‰ï¼Œå‡å»å‘çš„é«˜åº¦
            int h = (height[i] &amp;gt; height[stack[top]] ? height[stack[top]] : height[i]);
            h -= height[stack[top + 1]];
            ans += h * len; // é¢ç§¯ç´¯åŠ 
        }
        stack[++top] = i; // å…¥å•è°ƒé€’å‡æ ˆ
    }
    return ans;
}

// åŒæŒ‡é’ˆ
/*
int trap(int* height, int heightSize){
    int left = 0, right = heightSize - 1; // åˆå§‹åŒ–å·¦å³æŒ‡é’ˆ
    int max_left = 0, max_right = 0, ans = 0; // åˆå§‹åŒ–å·¦å³è¾¹ç•Œ
    while (left != right) {
    	// é€‰æ‹©ä½çš„è¾¹ç•Œæ¥é›¨æ°´
        if (height[left] &amp;lt; height[right]) {
        // å¯¹æ¯”ä¸¤ä¸ªæŸ±å­ï¼Œé€‰æ‹©é«˜çš„åšè¾¹ç•Œ
            if (height[left] &amp;gt; max_left) {
                max_left = height[left];
            }
            ans += max_left - height[left];
            left++;
        } else {
            if (height[right] &amp;gt; max_right) {
                max_right = height[right];
            }
            ans += max_right - height[right];
            right--;
        }  
    }
    return ans;
}
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int trap(vector&amp;lt;int&amp;gt;&amp;amp; height) {
        int n = height.size(), ans = 0;
        if (n == 0 || n == 1) return ans;
        stack&amp;lt;int&amp;gt; stk;
        for (int i = 0; i &amp;lt; n; i++) {
            while (!stk.empty() &amp;amp;&amp;amp; height[i] &amp;gt; height[stk.top()]) {
                int t = stk.top();
                stk.pop();
                if (stk.empty()) break;
                int len = i - stk.top() - 1;
                int h = min(height[i], height[stk.top()]) - height[t];
                ans += len * h;
            }
            stk.push(i);
        }
        return ans;
    }
};
// åŒæŒ‡é’ˆ
/*
class Solution {
public:
    int trap(vector&amp;lt;int&amp;gt;&amp;amp; height) {
        int n = height.size(), ans = 0;
        if (n == 0 || n == 1) return ans;
        int left = 0, right = n -1;
        int max_left = 0, max_right = 0;
        while (left != right) {
            if (height[left] &amp;lt; height[right]) {
                max_left = max(max_left, height[left]);
                ans += max_left - height[left];
                left++;
            } else {
                max_right = max(max_right, height[right]);
                ans += max_right - height[right];
                right--;
            }
        }
        return ans;
    }
};
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3leetcode-84æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢&#34;&gt;3.LeetCode-84(æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/CTYoLgyEPXp2Vb7.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
// å•è°ƒæ ˆï¼ˆå•è°ƒé€’å¢çš„æ ˆï¼Œæ ˆå­˜å…ƒç´ ç¼–å·ï¼‰
int largestRectangleArea(int* heights, int heightsSize){
    if (heightsSize == 0) return 0;
    if (heightsSize == 1) return heights[0];
    int stack[heightsSize + 5], top = -1, ans = 0;
    for (int i = 0; i &amp;lt; heightsSize; ++i) {
    	// 1.å½“æ ˆä¸ä¸ºç©ºæ—¶ï¼Œæ‰å¯å¾ªç¯
    	// 2.å½“å‰æŸ±å­å°äºæ ˆå†…çš„æŸ±å­æ—¶ï¼Œè¿›å…¥å¾ªç¯
        while (top != -1 &amp;amp;&amp;amp; heights[i] &amp;lt; heights[stack[top]]) {
            int h = heights[stack[top--]]; // æ ˆé¡¶å…ƒç´ é«˜åº¦
            int len;
            if (top == -1) len = i; // ï¼ˆæ ˆåº•ï¼‰å½“å‰æœ€å°é«˜åº¦çš„æŸ±å­ï¼ˆé•¿åº¦ç­‰äºå½“å‰ä½ç½®iï¼‰
            else len = i - stack[top] - 1;
            ans = (ans &amp;gt; h * len ? ans : h * len);
        }
        stack[++top] = i; // å…¥å•è°ƒé€’å¢çš„æ ˆ
    }
    // ç‰¹æ®Šæƒ…å†µï¼š 1.æœ€å°é«˜åº¦çš„å…ƒç´ æ²¡æœ‰å‡ºæ ˆ
    // 2. æœ€åä¸€ä¸ªæŸ±å­æ¯”å€’æ•°ç¬¬äºŒä¸ªæŸ±å­é«˜ï¼Œæ²¡æœ‰å‡ºæ ˆ
    // ç›®å‰æ ˆé‡Œé¢æ˜¯å•è°ƒé€’å¢çš„æ ˆ
    while (top != -1) {
        int h = heights[stack[top--]]; // æ ˆé¡¶å…ƒç´ çš„é«˜åº¦
        int len;
        if (top == -1) len = heightsSize; // æœ€å°é«˜åº¦çš„æŸ±å­ï¼ˆé•¿åº¦ç­‰äºæ•°ç»„é•¿åº¦ï¼‰
        else  len = heightsSize - stack[top] - 1; // æ•°ç»„çš„é•¿åº¦ - æ ˆé¡¶ä¸‹é¢çš„é•¿åº¦ - 1
        ans = (ans &amp;gt; h * len ? ans : h * len);
    }
    return ans;
}
*/
// å•è°ƒæ ˆï¼Œå¤´å°¾åŠ å…¥æœ€å°è™šæ‹ŸæŸ±å­ï¼ˆ0ï¼‰ï¼Œæ’é™¤ç‰¹æ®Šæƒ…å†µ
int largestRectangleArea(int* heights, int heightsSize){
    if (heightsSize == 0) return 0;
    if (heightsSize == 1) return heights[0];
    int num[heightsSize + 5], stack[heightsSize + 5];
    for (int i = 0; i &amp;lt; heightsSize; ++i) {
        num[i + 1] = heights[i];
    }
    int top = -1, ans = 0;
    num[0] = 0, num[heightsSize + 1] = 0; stack[++top] = 0;
    for (int i = 1; i &amp;lt; heightsSize + 2; ++i) {
        while (top &amp;amp;&amp;amp; num[i] &amp;lt; num[stack[top]]) {
            int h = num[stack[top]];
            int len = i - stack[--top] - 1;
            ans = (ans &amp;gt; h * len ? ans : h * len);
        }
        stack[++top] = i;
    }
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int largestRectangleArea(vector&amp;lt;int&amp;gt;&amp;amp; heights) {
        int n = heights.size(), ans = 0;
        if (n == 0) return 0;
        if (n == 1) return heights[0];
        stack&amp;lt;int&amp;gt; stk;
        for (int i = 0; i &amp;lt; n; ++i) {
            while (!stk.empty() &amp;amp;&amp;amp; heights[i] &amp;lt;= heights[stk.top()]) {
                int h = heights[stk.top()];
                stk.pop();
                int len;
                if (stk.empty()) len = i;
                else len = i - stk.top() - 1;
                ans = max(ans, len * h);
            }
            stk.push(i);
        }
        while (!stk.empty()) {
            int h = heights[stk.top()];
            stk.pop();
            int len;
            if (stk.empty()) len = n;
            else len = n - stk.top() - 1;
            ans = max(ans, len * h);
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4leetcode-232ç”¨æ ˆå®ç°é˜Ÿåˆ—&#34;&gt;4.LeetCode-232(ç”¨æ ˆå®ç°é˜Ÿåˆ—)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/BP4L9zrhHl7CmYN.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct {
    int stack1[10000], top1;
    int stack2[10000], top2;
} MyQueue;

/** Initialize your data structure here. */

MyQueue* myQueueCreate() {
    MyQueue *q = (MyQueue *)malloc(sizeof(MyQueue));
    q-&amp;gt;top1 = -1;
    q-&amp;gt;top2 = -1;
    return q;
}

/** Push element x to the back of queue. */
void myQueuePush(MyQueue* obj, int x) {
    obj-&amp;gt;stack1[++(obj-&amp;gt;top1)] = x;
    return ;
}

/** Removes the element from in front of queue and returns that element. */
int myQueuePop(MyQueue* obj) {
    while (obj-&amp;gt;top1 != -1) {
        obj-&amp;gt;stack2[++(obj-&amp;gt;top2)] = obj-&amp;gt;stack1[(obj-&amp;gt;top1)--];
    }
    int t = obj-&amp;gt;stack2[(obj-&amp;gt;top2)--];
    while (obj-&amp;gt;top2 &amp;gt; -1) {
        obj-&amp;gt;stack1[++(obj-&amp;gt;top1)] = obj-&amp;gt;stack2[(obj-&amp;gt;top2)--];
    }
    return t;
}

/** Get the front element. */
int myQueuePeek(MyQueue* obj) {
    while (obj-&amp;gt;top1 != -1) {
        obj-&amp;gt;stack2[++(obj-&amp;gt;top2)] = obj-&amp;gt;stack1[(obj-&amp;gt;top1)--];
    }
    int t = obj-&amp;gt;stack2[(obj-&amp;gt;top2)];
    while (obj-&amp;gt;top2 &amp;gt; -1) {
        obj-&amp;gt;stack1[++(obj-&amp;gt;top1)] = obj-&amp;gt;stack2[(obj-&amp;gt;top2)--];
    }
    return t;
}

/** Returns whether the queue is empty. */
bool myQueueEmpty(MyQueue* obj) {
    return obj-&amp;gt;top1 == -1;
}

void myQueueFree(MyQueue* obj) {
    if (obj == NULL) return ;
    free(obj);
    return ;
}

/**
 * Your MyQueue struct will be instantiated and called as such:
 * MyQueue* obj = myQueueCreate();
 * myQueuePush(obj, x);
 
 * int param_2 = myQueuePop(obj);
 
 * int param_3 = myQueuePeek(obj);
 
 * bool param_4 = myQueueEmpty(obj);
 
 * myQueueFree(obj);
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class MyQueue {
public:
    stack&amp;lt;int&amp;gt; s1, s2;
    /** Initialize your data structure here. */
    MyQueue() {

    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        s1.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        while(!s1.empty()) {
            s2.push(s1.top());
            s1.pop();
        }
        int t = s2.top();
        s2.pop();
        while(!s2.empty()) {
            s1.push(s2.top());
            s2.pop();
        }
        return t;
    }
    
    /** Get the front element. */
    int peek() {
        while(!s1.empty()) {
            s2.push(s1.top());
            s1.pop();
        }
        int t = s2.top();
        while(!s2.empty()) {
            s1.push(s2.top());
            s2.pop();
        }
        return t;
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return s1.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj-&amp;gt;push(x);
 * int param_2 = obj-&amp;gt;pop();
 * int param_3 = obj-&amp;gt;peek();
 * bool param_4 = obj-&amp;gt;empty();
 */
&lt;/code&gt;&lt;/pre&gt;
">æ ˆ-åˆ·é¢˜é›†</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/å †ä¼˜å…ˆé˜Ÿåˆ—-åˆ·é¢˜é›†/"" data-c="
          &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&#34;1-leetcode-23åˆå¹¶kä¸ªå‡åºé“¾è¡¨&#34;&gt;1. LeetCode-23(åˆå¹¶Kä¸ªå‡åºé“¾è¡¨)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/Kl5pJP9D1Fw3sjC.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
#define SWAP(a, b) {\
    __typeof(a) _t = a;\
    a = b; b = _t;\
}

typedef struct pq {
    struct ListNode **data;
    int cnt, size;
} PQ;

PQ *init(int n) {
    PQ *p = (PQ *)malloc(sizeof(PQ));
    p-&amp;gt;data = (struct ListNode **)malloc(sizeof(struct ListNode *) * (n + 1));
    p-&amp;gt;cnt = 0;
    p-&amp;gt;size = n;
    return p;
}

void clear(PQ *q) {
    if (q == NULL) return ;
    free(q-&amp;gt;data);
    free(q);
    return ;
}

int empty(PQ *q) {
    return q-&amp;gt;cnt == 0;
}

struct ListNode *top(PQ *q) {
    return q-&amp;gt;data[1];
}

void push(PQ *q, struct ListNode *node) {
    if (q == NULL) return ;
    if (q-&amp;gt;cnt == q-&amp;gt;size) return ;
    q-&amp;gt;data[++(q-&amp;gt;cnt)] = node;
    int ind = q-&amp;gt;cnt;
    while (ind &amp;gt;&amp;gt; 1 &amp;amp;&amp;amp; q-&amp;gt;data[ind]-&amp;gt;val &amp;lt; q-&amp;gt;data[ind &amp;gt;&amp;gt; 1]-&amp;gt;val) {
        SWAP(q-&amp;gt;data[ind], q-&amp;gt;data[ind &amp;gt;&amp;gt; 1]);
        ind &amp;gt;&amp;gt;= 1;
    }
    return ;
}

void pop(PQ *q) {
    if (q == NULL) return ;
    if (empty(q)) return ;
    q-&amp;gt;data[1] = q-&amp;gt;data[(q-&amp;gt;cnt)--];
    int ind = 1;
    while (ind &amp;lt;&amp;lt; 1 &amp;lt;= q-&amp;gt;cnt) {
        int tmp = ind, dl = ind &amp;lt;&amp;lt; 1, dr = ind &amp;lt;&amp;lt; 1 | 1;
        if (q-&amp;gt;data[tmp]-&amp;gt;val &amp;gt; q-&amp;gt;data[dl]-&amp;gt;val) tmp = dl;
        if (dr &amp;lt;= q-&amp;gt;cnt &amp;amp;&amp;amp; q-&amp;gt;data[tmp]-&amp;gt;val &amp;gt; q-&amp;gt;data[dr]-&amp;gt;val) tmp = dr;
        if (tmp == ind) break;
        SWAP(q-&amp;gt;data[ind], q-&amp;gt;data[tmp]);
        ind = tmp;
    } 
    return ;
}

struct ListNode* mergeKLists(struct ListNode** lists, int listsSize){
    // åŠ¨æ€ç”³è¯· dummyå¹¶åˆå§‹åŒ–
    struct ListNode *dummy = (struct ListNode *)calloc(1, sizeof(struct ListNode));
    struct ListNode *head = dummy;
    if (listsSize == 0) return NULL;
    PQ *pq = init(10005);
    for (int i = 0; i &amp;lt; listsSize; ++i) {
        if (lists[i]) push(pq, lists[i]);
    }
    while (!empty(pq)) {
        struct ListNode *node = top(pq); pop(pq);
        head-&amp;gt;next = node;
        head = head-&amp;gt;next;
        if (node-&amp;gt;next) push(pq, node-&amp;gt;next);
    }
    clear(pq);
    struct ListNode *ans = dummy-&amp;gt;next;
    free(dummy);
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
/*  // é‡è½½å°äºå·
    struct obj {
        int val;
        ListNode *ptr;
        bool operator&amp;lt;(const obj &amp;amp;b) const {
            return this-&amp;gt;val &amp;gt; b.val; // å¤§äºå·æ˜¯å°æ ¹å †ï¼Œå°äºå·æ˜¯å¤§æ ¹å †
        }
    };
*/  // ä»¿å‡½æ•°ï¼Œé‡è½½()
    struct CMP {
        bool operator()(const ListNode *a, const ListNode *b) {
            return a-&amp;gt;val &amp;gt; b-&amp;gt;val; // å¤§äºå·æ˜¯å°æ ¹å †
        }
    };

    ListNode* mergeKLists(vector&amp;lt;ListNode*&amp;gt;&amp;amp; lists) {
        //priority_queue&amp;lt;obj&amp;gt; pq;
        // ç¬¬1ä¸ªå‚æ•°æ˜¯æ•°æ®ç±»å‹ï¼Œ2å‚æ•°æ˜¯å®¹å™¨ï¼Œ3å‚æ•°æ˜¯æ¯”è¾ƒå‡½æ•° 
        priority_queue&amp;lt;ListNode *, vector&amp;lt;ListNode *&amp;gt;, CMP&amp;gt; pq;
        for (auto node : lists) {
            if (node) pq.push(node);
        }
        ListNode dummy;
        ListNode *head = &amp;amp;dummy;
        while (!pq.empty()) {
            auto t = pq.top(); pq.pop();
            head-&amp;gt;next = t;
            head = head-&amp;gt;next;
            if (t-&amp;gt;next) pq.push(t-&amp;gt;next);
        }
        return dummy.next;
    }
};
/*
// å½’å¹¶æ“ä½œ
class Solution {
public:
    ListNode *mySort(ListNode *a, ListNode *b) {
        if (a == NULL || b == NULL) return a ? a : b;
        ListNode dummy;
        ListNode *head = &amp;amp;dummy, *p1 = a, *p2 = b;
        while (p1 || p2) {
            if (!p2 || (p1 &amp;amp;&amp;amp; p1-&amp;gt;val &amp;lt; p2-&amp;gt;val)) {
                head-&amp;gt;next = p1;
                p1 = p1-&amp;gt;next;
                head = head-&amp;gt;next;
            } else {
                head-&amp;gt;next = p2;
                p2 = p2-&amp;gt;next;
                head = head-&amp;gt;next;
            }
        }
        return dummy.next;
    }
	// æŠŠåˆ†æ²»é“¾è¡¨ï¼ŒæŠŠå·¦åŠéƒ¨åˆ†ï¼Œå’Œå³åŠéƒ¨åˆ†å†å½’å¹¶
    ListNode *merge(vector&amp;lt;ListNode *&amp;gt; &amp;amp;arr, int l, int r) {
        if (l &amp;gt; r) return nullptr;
        if (l == r) return arr[l];
        int mid = l + (r - l) / 2;
        return mySort(merge(arr, l, mid), merge(arr, mid + 1, r));
    }

    ListNode* mergeKLists(vector&amp;lt;ListNode*&amp;gt;&amp;amp; lists) {
        return merge(lists, 0, lists.size() - 1);
    }
};
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2leetcode-264ä¸‘æ•°ii&#34;&gt;2.LeetCode-264(ä¸‘æ•°â…¡)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/h6i7ekWmn3S8tLC.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    typedef long long LL;
   
    int nthUglyNumber(int n) {
        if (n == 1) return 1;
        vector&amp;lt;LL&amp;gt; dp(n + 1);
        dp[1] = 1; // åˆå§‹åŒ–dpæ•°ç»„çš„ç¬¬ä¸€ä¸ªä½ç½®
        LL p2 = 1, p3 = 1, p5 = 1; // æ„å»º3ä¸ªæŒ‡é’ˆï¼Œåˆå§‹åŒ–æŒ‡å®šdpæ•°ç»„çš„1ä½ç½®
        for (int i = 2; i &amp;lt;= n; ++i) {
            // æŒ‡é’ˆä¹˜ä¸Šä¹‹å‰dpæ•°ç»„çš„å€¼ï¼Œå–æœ€å°å€¼ï¼Œæ”¾å…¥dpæ•°ç»„
            LL num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5;
            dp[i] = min(min(num2, num3), num5);
            // å¯ä»¥å»é‡
            if (dp[i] == num2) (p2)++;
            if (dp[i] == num3) (p3)++;
            if (dp[i] == num5) (p5)++;
        }
        return dp[n];
    }
};

/*
class Solution {
public:
    typedef long long LL;
    struct CMP {
        bool operator()(const LL a, const LL b) {
            return a &amp;gt; b;
        }
    };
    int nthUglyNumber(int n) {
        if (n == 1) return 1;
        LL nums[3] = {2, 3, 5}, ans = 0;
        priority_queue&amp;lt;LL, vector&amp;lt;LL&amp;gt;, CMP&amp;gt; pq;
        unordered_set&amp;lt;LL&amp;gt; mySet; // é›†åˆå»é‡
        pq.push(1); mySet.insert(1);
        for (int i = 1; i &amp;lt;= n; ++i) {
            LL uglyNum = pq.top(); pq.pop();
            ans = uglyNum;
            // ä¸‘æ•°çš„2ï¼Œ3ï¼Œ5å€æ•°ä¸€å®šæ˜¯ä¸‘æ•°
            for (int i = 0; i &amp;lt; 3; ++i) {
                LL t = uglyNum * nums[i];
                if (mySet.count(t) == 0) {
                    pq.push(t); mySet.insert(t);
                }
            }
        }
        return ans;
    }
};
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3leetcode-295æ•°æ®æµçš„ä¸­ä½æ•°&#34;&gt;3.LeetCode-295(æ•°æ®æµçš„ä¸­ä½æ•°)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/IqPrBfsovkNnp3c.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class MedianFinder {
public:
    /** initialize your data structure here. */
    // ä½¿ç”¨ä¸¤ä¸ªå †ï¼ˆå¤§å°æ ¹å †ï¼‰ï¼Œåœ¨ä¸¤ä¸ªå †å€’æ¥å€’å»ï¼Œå¦‚æœå…ƒç´ ä¸ªæ•°æ˜¯å¥‡æ•°ï¼Œå°æ ¹å †å¤š1
    void addNum(int num) {
        bigHeap.push(num); // æŠŠæ¯ä¸ªæ•°æ®å…ˆæ”¾å…¥å¤§æ ¹å †
        // æŠŠå¤§æ ¹å †çš„å †é¡¶å…ƒç´ å…ƒç´ å¼¹å‡ºæ”¾å…¥å°æ ¹å †ï¼ˆå…³é”®ï¼‰
        smallHeap.push(bigHeap.top()); bigHeap.pop();
        int l = bigHeap.size(), r = smallHeap.size();
        // å¦‚æœå°æ ¹çš„å…ƒç´ æ¯”å¤§æ ¹å †çš„å…ƒç´ å¤šï¼ŒæŠŠå †é¡¶å…ƒç´ å¼¹å‡ºæ”¾å›å¤§æ ¹å †
        // ä¿è¯å¤§æ ¹å †çš„å…ƒç´ æ¯”å°æ ¹å †çš„å…ƒç´ ç›¸ç­‰æˆ–å¤š1ä¸ª
        if (r &amp;gt; l) { 
            bigHeap.push(smallHeap.top());
            smallHeap.pop();
        }
        return ;
    }
    
    double findMedian() {
        int l = bigHeap.size(), r = smallHeap.size();
        return l - r ? (double)bigHeap.top() : (smallHeap.top() + bigHeap.top()) / 2.0;
    }
private:
    priority_queue&amp;lt;int&amp;gt; bigHeap;
    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt; &amp;gt; smallHeap;
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj-&amp;gt;addNum(num);
 * double param_2 = obj-&amp;gt;findMedian();
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4leetcode-313è¶…çº§ä¸‘æ•°&#34;&gt;4.LeetCode-313(è¶…çº§ä¸‘æ•°)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/BqHwrFXWVsY1lc2.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/*
// æœ€å°å †  + é›†åˆå»é‡
// ä¸‘æ•°çš„æŠ€å·§å°±æ˜¯ï¼Œä¸‘æ•° * ä¸‘æ•° è¿˜æ˜¯ä¸‘æ•°
class Solution {
public:
    typedef long long LL; // æ•°æ®èŒƒå›´
    int nthSuperUglyNumber(int n, vector&amp;lt;int&amp;gt;&amp;amp; primes) {
        if (n == 1) return 1;
        priority_queue&amp;lt;LL, vector&amp;lt;LL&amp;gt;, greater&amp;lt;LL&amp;gt; &amp;gt; pq; // æœ€å°å †
        unordered_set&amp;lt;LL&amp;gt; mySet; // é›†åˆ
        pq.push(1); mySet.insert(1);
        LL ans = 0;
        for (int i = 1; i &amp;lt;= n; ++i) {
            LL uglyNum = pq.top(); pq.pop();
            ans = uglyNum; // æŠŠæœ€å°ä¸‘æ•°æ‹¿å‡ºæ¥
            for (auto it : primes) {
                LL t = uglyNum * it; // ä¸‘æ•° * ä¸‘æ•° è¿˜æ˜¯ä¸‘æ•°
                if (mySet.insert(t).second) {
                    pq.push(t);
                }
            }
        }
        return ans;
    }
};
*/
// ç”¨åŠ¨æ€è§„åˆ’ æ¯æ¬¡ æŠŠæœ€å°çš„ä¸‘æ•°æ”¾å…¥ dpæ•°ç»„ï¼Œç„¶åç”¨æœ€å°çš„ä¸‘æ•° * primesé‡Œé¢çš„ä¸‘æ•°ï¼Œ åœ¨æŠŠæœ€å°ä¸‘æ•°æ”¾å…¥dp
class Solution {
public:
    typedef long long LL;
    int nthSuperUglyNumber(int n, vector&amp;lt;int&amp;gt;&amp;amp; primes) {
        if (n == 1) return 1;
        vector&amp;lt;LL&amp;gt; dp(n + 1, 0); // ç­”æ¡ˆDP
        int pSize = primes.size();
        vector&amp;lt;LL&amp;gt; ptr(pSize, 1); // æŒ‡é’ˆæ•°ç»„ï¼Œåˆå§‹æŒ‡å‘dp[1]
        dp[1] = 1; 
        for (int i = 2; i &amp;lt;= n; ++i) {
            // éå†primesæ•°ç»„ï¼Œ ç”¨æœ€å°ä¸‘æ•° * æ•°ç»„çš„æ¯ä¸ªå…ƒç´ ï¼Œå–æœ€å°å€¼æ”¾å…¥dp[i]
            LL t = dp[ptr[0]] * primes[0]; 
            for (int j = 1; j &amp;lt; pSize; ++j) {
                t = min(t, dp[ptr[j]] * primes[j]); 
            }
            dp[i] = t;
            // è¢«å–èµ°çš„å…ƒç´ çš„æŒ‡é’ˆ + 1ï¼ˆç›¸åŒçš„å…ƒç´ çš„æŒ‡é’ˆéƒ½ + 1ï¼‰
            for (int k = 0; k &amp;lt; pSize; ++k) {
                if (dp[i] == dp[ptr[k]] * primes[k]) ptr[k]++;
            }
        }
        return dp[n];
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5leetcode-703æ•°æ®æµä¸­çš„ç¬¬kå¤§å…ƒç´ &#34;&gt;5.LeetCode-703(æ•°æ®æµä¸­çš„ç¬¬Kå¤§å…ƒç´ )&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/EsAC1kB6hM2rIfy.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class KthLargest {
public:
    // æ”¾å…¥æœ€å°å †
    KthLargest(int k, vector&amp;lt;int&amp;gt;&amp;amp; nums) : _k(k) {
        for (auto it : nums) { add(it); } // è¿™é‡Œadd()å‡½æ•°ï¼Œæ¯æ¬¡éƒ½ä¼šè°ƒç”¨
    }
    int add(int val) {
        pq.push(val);
        while (pq.size() &amp;gt; _k) pq.pop(); // è®©å †é¡¶çš„å…ƒç´ ç­‰äºç¬¬Kå¤§å…ƒç´ ï¼ˆè®©å †åªå‰©Kä¸ªå…ƒç´ ï¼‰
        return pq.top();
    }
    int _k;
    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt; &amp;gt; pq;
    
};

/**
 * Your KthLargest object will be instantiated and called as such:
 * KthLargest* obj = new KthLargest(k, nums);
 * int param_1 = obj-&amp;gt;add(val);
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define SWAP(a, b) {\
    __typeof(a) _t = a;\
    a = b; b = _t;\
}

typedef struct {
    int *data;
    int cnt, size;
} KthLargest;

KthLargest *init(int n) {
    KthLargest *k = (KthLargest *)malloc(sizeof(KthLargest));
    k-&amp;gt;data = (int *)malloc(sizeof(int) * ( n + 1));
    k-&amp;gt;cnt = 0;
    k-&amp;gt;size = n;
    return k;
}

int empty(KthLargest *k) {
    return k-&amp;gt;cnt == 0;
}

int top(KthLargest *k) {
    return k-&amp;gt;data[1];
}

void push(KthLargest *k, int val) {
    if (k == NULL) return ;
    if (k-&amp;gt;cnt == k-&amp;gt;size) return ;
    k-&amp;gt;data[++(k-&amp;gt;cnt)] = val;
    int ind = k-&amp;gt;cnt;
    while (ind &amp;gt;&amp;gt; 1 &amp;amp;&amp;amp; k-&amp;gt;data[ind] &amp;lt; k-&amp;gt;data[ind &amp;gt;&amp;gt; 1]) {
        SWAP(k-&amp;gt;data[ind], k-&amp;gt;data[ind &amp;gt;&amp;gt; 1]);
        ind &amp;gt;&amp;gt;= 1;
    }
    return ;
}

void pop(KthLargest *k) {
    if (k == NULL) return ;
    if (empty(k)) return ;
    k-&amp;gt;data[1] = k-&amp;gt;data[(k-&amp;gt;cnt)--];
    int ind = 1;
    while (ind &amp;lt;&amp;lt; 1 &amp;lt;= k-&amp;gt;cnt) {
        int tmp = ind, dl = ind &amp;lt;&amp;lt; 1, dr = ind &amp;lt;&amp;lt; 1 | 1;
        if (k-&amp;gt;data[tmp] &amp;gt; k-&amp;gt;data[dl]) tmp = dl;
        if (dr &amp;lt;= k-&amp;gt;cnt &amp;amp;&amp;amp; k-&amp;gt;data[tmp] &amp;gt; k-&amp;gt;data[dr]) tmp = dr;
        if (tmp == ind) break;
        SWAP(k-&amp;gt;data[tmp], k-&amp;gt;data[ind]);
        ind = tmp;
    }
    return ;
}

int _k;
KthLargest* kthLargestCreate(int k, int* nums, int numsSize) {
    KthLargest *pq = init(10005);
    for (int i = 0; i &amp;lt; numsSize; ++i) {
        push(pq, nums[i]);
    }
    _k = k;
    return pq;
}

int kthLargestAdd(KthLargest* obj, int val) {
    push(obj, val);
    while (obj-&amp;gt;cnt &amp;gt; _k) {
        pop(obj);
    }
    return top(obj);
}

void kthLargestFree(KthLargest* obj) {
    if (obj == NULL) return ;
    free(obj-&amp;gt;data);
    free(obj);
    return ;
}

/**
 * Your KthLargest struct will be instantiated and called as such:
 * KthLargest* obj = kthLargestCreate(k, nums, numsSize);
 * int param_1 = kthLargestAdd(obj, val);
 
 * kthLargestFree(obj);
*/
&lt;/code&gt;&lt;/pre&gt;
">å †ä¼˜å…ˆé˜Ÿåˆ—-åˆ·é¢˜é›†</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://azhanglai-github-io.vercel.app/é“¾è¡¨-åˆ·é¢˜é›†/"" data-c="
          &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&#34;1-leetcode-19åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬nä¸ªç»“ç‚¹&#34;&gt;1. LeetCode-19(åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªç»“ç‚¹)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/2NM7BIVXUCstheL.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
// Cè¯­è¨€åŒæŒ‡é’ˆè§£æ³•
struct ListNode* removeNthFromEnd(struct ListNode* head, int n){
    struct ListNode dummy; // æ„å»ºè™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆä¸éœ€è¦ç”³è¯·åŠ¨æ€ç©ºé—´ï¼‰
    dummy.next = head;     
    struct ListNode *p = &amp;amp;(dummy); // æ…¢æŒ‡é’ˆ
    struct ListNode *q = &amp;amp;(dummy); // å¿«æŒ‡é’ˆï¼ˆå¿«nä¸ªä½ç½®ï¼‰
    while (n--) q = q-&amp;gt;next;     // å¿«è¿›åˆ°nçš„ä½ç½®
    while (q-&amp;gt;next) {  
        // å½“å¿«æŒ‡é’ˆçš„ä¸‹ä¸€ä¸ªä½ç½®ä¸ºNULLæ—¶ï¼Œé‚£ä¹ˆæ…¢æŒ‡é’ˆçš„ä¸‹ä¸€ä¸ªä½ç½®å°±æ˜¯è¦åˆ é™¤çš„ä½ç½®
        p = p-&amp;gt;next;
        q = q-&amp;gt;next;
    }
    // åˆ é™¤æ“ä½œ
    struct ListNode *free_node = p-&amp;gt;next;
    p-&amp;gt;next = free_node-&amp;gt;next;
    free(free_node);
    return dummy.next; è¿”å›çœŸæ­£çš„å¤´ç»“ç‚¹
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *dummy = new ListNode(0, head);
        ListNode *p = dummy;
        ListNode *q = dummy;
        while (n--) q = q-&amp;gt;next;
        while (q-&amp;gt;next != nullptr) {
            p = p-&amp;gt;next;
            q = q-&amp;gt;next;
        }
        ListNode *delete_node = p-&amp;gt;next;
        p-&amp;gt;next = delete_node-&amp;gt;next;
        delete delete_node;
        ListNode *ans = dummy-&amp;gt;next;
        delete dummy;
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2leetcode-24ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹&#34;&gt;2.LeetCode-24(ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/37hcQJUEYPXNewd.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
// è¿­ä»£æ³•äº¤æ¢
struct ListNode* swapPairs(struct ListNode* head){
    struct ListNode dummy; // æ„å»ºè™šæ‹Ÿå¤´ç»“ç‚¹ï¼ˆé™æ€åˆ†é…ï¼‰
    dummy.next = head; 
    struct ListNode *t = &amp;amp;dummy; // å–è™šæ‹Ÿå¤´èŠ‚ç‚¹åœ°å€
    while(t-&amp;gt;next != NULL &amp;amp;&amp;amp; t-&amp;gt;next-&amp;gt;next != NULL) {
        // å½“ç›®å‰çš„èŠ‚ç‚¹çš„ä¸‹ä¸€ä½ç½®å’Œä¸‹ä¸‹ä½ç½®éƒ½ä¸ºç©ºæ—¶ï¼ˆé¿å…ç©ºé“¾è¡¨æ—¶ï¼Œæ²¡æœ‰ä¸‹ä¸‹ä½ç½®ï¼‰
        // äº¤æ¢æ“ä½œ
        /*
        0-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4
        0-&amp;gt;2  1-&amp;gt;3 2-&amp;gt;1  0 = 1
        2-&amp;gt;1(0)-&amp;gt;3-&amp;gt;4
        */
        struct ListNode *p = t-&amp;gt;next; 
        struct ListNode *q = t-&amp;gt;next-&amp;gt;next;
        t-&amp;gt;next = q; 
        p-&amp;gt;next = q-&amp;gt;next;
        q-&amp;gt;next = p;
        t = p;
    } 
    return dummy.next;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode dummy(0, head);
        ListNode *t = &amp;amp;dummy;
        while (t-&amp;gt;next &amp;amp;&amp;amp; t-&amp;gt;next-&amp;gt;next) {
            ListNode *p = t-&amp;gt;next;
            ListNode *q = t-&amp;gt;next-&amp;gt;next;
            t-&amp;gt;next = q;
            p-&amp;gt;next = q-&amp;gt;next;
            q-&amp;gt;next = p;
            t = p;
        }
        return dummy.next;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3leetcode-83åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ &#34;&gt;3.LeetCode-83(åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ )&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/eABXgG4uniJDW82.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
// è¿­ä»£æ³•åˆ é™¤
struct ListNode* deleteDuplicates(struct ListNode* head){
    if (head == NULL) return head; // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œç›´æ¥è¿”å›head
    struct ListNode dummy;
    dummy.next = head; 
    struct ListNode *p = head, *q;
    while (p-&amp;gt;next) {
        // å½“å‰ä½ç½®å’Œä¸‹ä¸€ä½ç½®çš„å€¼ä¸€æ ·ï¼Œåˆ™ç›´æ¥åˆ é™¤ä¸‹ä¸€ä½ç½®çš„èŠ‚ç‚¹
        // å€¼ä¸ä¸€æ ·ï¼Œå¾€å‰éå†
        if (p-&amp;gt;val == p-&amp;gt;next-&amp;gt;val) {
            q = p-&amp;gt;next;
            p-&amp;gt;next = q-&amp;gt;next;
            free(q);
        } else {
            p = p-&amp;gt;next;
        }
    }
    return dummy.next;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head) return head;
        ListNode dummy(0, head);
        ListNode *p = head, *q;
        while (p-&amp;gt;next) {
            if (p-&amp;gt;val == p-&amp;gt;next-&amp;gt;val) {
                q = p-&amp;gt;next;
                p-&amp;gt;next = q-&amp;gt;next;
                delete q;
            } else {
                p = p-&amp;gt;next;
            }
        }
        return dummy.next;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4leetcode-141ç¯å½¢é“¾è¡¨&#34;&gt;4.LeetCode-141(ç¯å½¢é“¾è¡¨)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/J73XjUtRfF1kT4h.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
// å¿«æ…¢æŒ‡é’ˆ
bool hasCycle(struct ListNode *head) {
    // å½“é“¾è¡¨æ²¡æœ‰èŠ‚ç‚¹å’Œåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œè¿”å›false(æ— ç¯)
    if (head == NULL || head-&amp;gt;next == NULL) return false;
    // æ„å»ºå¿«æ…¢æŒ‡é’ˆ
    struct ListNode *slow = head;
    struct ListNode *fast = head-&amp;gt;next;
    while (slow != fast) {
        // å½“å¿«æ…¢æŒ‡é’ˆç›¸ç­‰æ—¶ï¼Œè¯´æ˜æœ‰ç¯
        // å½“å¿«æŒ‡é’ˆè·‘åˆ°NULLï¼Œè¯´æ˜æ— ç¯
        if (fast == NULL || fast-&amp;gt;next == NULL) return false;
        slow = slow-&amp;gt;next; // æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥
        fast = fast-&amp;gt;next-&amp;gt;next; // å¿«æŒ‡é’ˆèµ°ä¸¤æ­¥
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (!head || !head-&amp;gt;next) return false;
        ListNode *slow = head;
        ListNode *fast = head-&amp;gt;next;
        while (slow != fast) {
            if (!fast || !fast-&amp;gt;next) return false;
            slow = slow-&amp;gt;next;
            fast = fast-&amp;gt;next-&amp;gt;next;
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5leetcode-160ç›¸äº¤é“¾è¡¨&#34;&gt;5.LeetCode-160(ç›¸äº¤é“¾è¡¨)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/hGMpxkbA1V7H9y2.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    // å¦‚æœAé“¾è¡¨æˆ–Bé“¾è¡¨ä¸ºç©ºï¼Œé‚£ä¹ˆè‚¯å®šä¸ç›¸äº¤äº†
    if (headA == NULL || headB == NULL) return NULL;
    struct ListNode *pA = headA, *pB = headB;
    // å¦‚æœç›¸äº¤ï¼Œç›¸äº¤éƒ¨åˆ†é•¿åº¦ä¸ºc,å‡è®¾Aé“¾è¡¨é•¿åº¦ä¸º a + c, Bé“¾è¡¨é•¿åº¦ä¸º b + cã€‚
    // é‚£ä¹ˆ Aé“¾è¡¨èµ° a + c + b, Bé“¾è¡¨èµ° b + c + a å¿…ç›¸äº¤ pA == pB
    while (pA != pB) {
        pA = (pA == NULL ? headB : pA-&amp;gt;next); // A ä¸€ç›´èµ°ï¼Œèµ°åˆ°NULLï¼Œå»èµ° B
        pB = (pB == NULL ? headA : pB-&amp;gt;next); // B ä¸€ç›´èµ°ï¼Œèµ°åˆ°NULLï¼Œå»èµ° A
    }
    return pA;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (!headA || !headB) return NULL;
        ListNode *pA = headA, *pB = headB;
        while (pA != pB) {
            pA = (pA == NULL ? headB : pA-&amp;gt;next);
            pB = (pB == NULL ? headA : pB-&amp;gt;next);
        }
        return pA;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6leetcode-202å¿«ä¹æ•°&#34;&gt;6.LeetCode-202(å¿«ä¹æ•°)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/9hWC3RwaqnL4TD5.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// è®¡ç®—æ¯ä¸ªæ•°å­—çš„ä¸‹ä¸€ä¸ªæ•°å­—ï¼Œä¾‹å¦‚æ•°å­—19 çš„ä¸‹ä¸€ä¸ª æ•°å­—æ˜¯ 9 * 9 + 1 * 1 = 82
int getNextNum(int n) {
    int ans = 0, t = 0;
    while (n) {
        t = n % 10; // å–ä¸ªä½
        ans += t * t;
        n /= 10; // å‰ªé™¤ä¸ªä½
    }
    return ans;
}
// å¿«ä¹æ•°æ˜¯æ²¡æœ‰ç¯çš„ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰æ²¡æœ‰ç¯å¯ä»¥ç”¨å¿«æ…¢æŒ‡é’ˆ
// å¿«æ…¢æŒ‡é’ˆ
bool isHappy(int n){
    int slow_num = n; // æ„å»ºæ…¢æŒ‡é’ˆï¼ˆå½“å‰æ•°å­—ï¼‰
    int fast_num = getNextNum(n); // æ„å»ºå¿«æŒ‡é’ˆï¼ˆä¸‹ä¸€æ•°å­—ï¼‰
    while (fast_num != 1 &amp;amp;&amp;amp; fast_num != slow_num) {
        // å½“å¿«æŒ‡é’ˆç­‰äº 1ï¼ˆå¿«ä¹æ•°ï¼‰ å’Œ å¿«æŒ‡é’ˆå’Œæ»¡æŒ‡é’ˆç›¸ç­‰ï¼ˆæœ‰ç¯ï¼Œä¸æ˜¯å¿«ä¹æ•°ï¼‰ å¾ªç¯ç»“æŸ
        slow_num = getNextNum(slow_num); // æ…¢æŒ‡é’ˆèµ°ä¸€æ­¥
        fast_num = getNextNum(getNextNum(fast_num)); // å¿«æŒ‡é’ˆèµ°ä¸¤æ­¥
    }
    return fast_num == 1; // åˆ¤æ–­æ˜¯ä¸æ˜¯å¿«ä¹æ•°
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    int getNextNum(int n) {
        int ans = 0, t = 0;
        while(n) {
            t = n % 10;
            ans += t * t;
            n /= 10;
        }
        return ans;
    }
    bool isHappy(int n) {
        int slow_num = n;
        int fast_num = getNextNum(n);
        while (fast_num != 1 &amp;amp;&amp;amp; fast_num != slow_num) {
            slow_num = getNextNum(slow_num);
            fast_num = getNextNum(getNextNum(fast_num));
        }
        return fast_num == 1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7leetcode-203ç§»é™¤é“¾è¡¨å…ƒç´ &#34;&gt;7.LeetCode-203(ç§»é™¤é“¾è¡¨å…ƒç´ )&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/3rhAXsfmxUdcakv.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
 /* é€’å½’æ³•
struct ListNode* removeElements(struct ListNode* head, int val){
    if (!head) return head;
    head-&amp;gt;next = removeElements(head-&amp;gt;next, val);
    return head-&amp;gt;val == val ? head-&amp;gt;next : head; 
}
*/
// è¿­ä»£æ³•
struct ListNode* removeElements(struct ListNode* head, int val){
    if (!head) return head; // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œé‚£ä¹ˆç›´æ¥è¿”å›head
    struct ListNode dummy; // æ„å»ºè™šæ‹Ÿå¤´ç»“ç‚¹
    dummy.next = head;
    struct ListNode *p = &amp;amp;dummy, *q;
    while(p-&amp;gt;next) {
        // å¦‚æœè¯¥ç»“ç‚¹çš„å€¼æ˜¯è¦åˆ é™¤çš„å€¼ï¼Œåˆ é™¤æ“ä½œ
      	// å¦‚æœä¸æ˜¯ï¼Œéå†ä¸‹ä¸€ç»“ç‚¹
        if (p-&amp;gt;next-&amp;gt;val == val) {
            q = p-&amp;gt;next;
            p-&amp;gt;next = q-&amp;gt;next;
            free(q);
        } else {
            p = p-&amp;gt;next;
        }
    }
    return dummy.next;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode dummy(0, head);
        ListNode *p = &amp;amp;dummy, *q;
        while (p-&amp;gt;next) {
            if (p-&amp;gt;next-&amp;gt;val == val) {
                q = p-&amp;gt;next;
                p-&amp;gt;next = q-&amp;gt;next;
                delete q;
            } else {
                p = p-&amp;gt;next;
            }
        }
        return dummy.next;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;8leetcode-206åè½¬é“¾è¡¨&#34;&gt;8.LeetCode-206(åè½¬é“¾è¡¨)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/ZXVcHRegOIy8G2l.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
// å¤´æ’æ³•
struct ListNode* reverseList(struct ListNode* head){
    // åŠ¨æ€åˆ†é…ç©ºé—´ï¼Œæ„å»ºè™šæ‹Ÿå¤´ç»“ç‚¹
    struct ListNode *dummy = (struct ListNode *)malloc(sizeof(struct ListNode));
    dummy-&amp;gt;next = head;
    struct ListNode *p = dummy-&amp;gt;next, *q;
    dummy-&amp;gt;next = NULL;  // æŠŠNULLæ’å…¥å¤´
    // å¤´æ’æ³•æ“ä½œ
    while (p) {
        q = p-&amp;gt;next;
        p-&amp;gt;next = dummy-&amp;gt;next;
        dummy-&amp;gt;next = p;
        p = q;
    }
    // å›æ”¶è™šæ‹Ÿå¤´ç»“ç‚¹çš„ç©ºé—´
    struct ListNode *ans = dummy-&amp;gt;next;
    free(dummy);
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *dummy = new ListNode(0, head);
        ListNode *p = dummy-&amp;gt;next, *q;
        dummy-&amp;gt;next = nullptr;
        while (p) {
            q = p-&amp;gt;next;
            p-&amp;gt;next = dummy-&amp;gt;next;
            dummy-&amp;gt;next = p;
            p = q;
        }
        ListNode *ans = dummy-&amp;gt;next;
        delete dummy;
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;9leetcode-234å›æ–‡é“¾è¡¨&#34;&gt;9.LeetCode-234(å›æ–‡é“¾è¡¨)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/NJH7Aqof8FVI6tu.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

/* æŠŠé“¾è¡¨éå†åˆ°æ•°ç»„ï¼Œåœ¨åˆ¤æ–­
bool isPalindrome(struct ListNode* head){
    int arr[100005], cnt = 0;
    for (struct ListNode *p = head; p; p = p-&amp;gt;next) {
        arr[cnt++] = p-&amp;gt;val;
    }
    int begin = 0, end = cnt - 1;
    for (int i = 0; i &amp;lt; cnt / 2; i++) {
        if (arr[begin] == arr[end]) {
            begin++, end--;
        } else {
            return false;
        }
    }
    return true;
}
*/ 
//åˆ©ç”¨å¿«æ…¢æŒ‡é’ˆ æ‰¾åˆ°é“¾è¡¨ä¸­é—´é“¾è¡¨çš„ä¸Šä¸€ä¸ªç»“ç‚¹
struct ListNode *Mid(struct ListNode *h) {
    struct ListNode *slow = h;
    struct ListNode *fast = h;
    while (fast-&amp;gt;next &amp;amp;&amp;amp; fast-&amp;gt;next-&amp;gt;next) {
        slow = slow-&amp;gt;next;
        fast = fast-&amp;gt;next-&amp;gt;next;
    } 
    return slow;
}
// ç¿»è½¬é“¾è¡¨æ“ä½œ
struct ListNode *End(struct ListNode *h) {
    struct ListNode *dummy = (struct ListNode *)malloc(sizeof(struct ListNode));
    dummy-&amp;gt;next = h;
    struct ListNode *p = dummy-&amp;gt;next, *q;
    dummy-&amp;gt;next = NULL;
    while (p) {
        q = p-&amp;gt;next;
        p-&amp;gt;next = dummy-&amp;gt;next;
        dummy-&amp;gt;next = p;
        p = q;
    }
    struct ListNode *ans = dummy-&amp;gt;next;
    free(dummy);
    return ans;
}

bool isPalindrome(struct ListNode* head){
    // å½“é“¾è¡¨åªæœ‰ä¸€ä¸ªå…ƒç´ æˆ–æ²¡æœ‰å…ƒç´ æ—¶ï¼Œæ˜¯ true
    if (!head || !head-&amp;gt;next) return true; 
    struct ListNode *mid = Mid(head); // æ‰¾ä¸­é—´ç»“ç‚¹çš„ä¸Šä¸€ä¸ªç»“ç‚¹
    struct ListNode *rev_mid = End(mid-&amp;gt;next); // æŠŠä»ä¸­é—´ç»“ç‚¹åˆ°ç»“å°¾éƒ¨åˆ†çš„é“¾è¡¨ç¿»è½¬

    struct ListNode *first = head; // æŒ‡é’ˆæŒ‡å‘åŸå§‹é“¾è¡¨çš„å¤´
    struct ListNode *second = rev_mid; // æŒ‡é’ˆæŒ‡å‘ç¿»è½¬éƒ¨åˆ†çš„é“¾è¡¨å¤´
    int flag = 1; // æ ‡è®°
    while (flag &amp;amp;&amp;amp; second) {
        // å½“ç¿»è½¬é“¾è¡¨èµ°åˆ°ç©ºï¼Œæˆ–ä¸æ˜¯å›æ–‡é“¾è¡¨åˆ™åœæ­¢å¾ªç¯
        if (first-&amp;gt;val != second-&amp;gt;val) {
            flag = 0;
            break;
        }
        first = first-&amp;gt;next;
        second = second-&amp;gt;next; 
    }
    mid-&amp;gt;next = End(rev_mid); // æŠŠé“¾è¡¨æ¢å¤åŸçŠ¶
    return flag;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;10leetcode-237åˆ é™¤é“¾è¡¨ä¸­çš„èŠ‚ç‚¹&#34;&gt;10.LeetCode-237(åˆ é™¤é“¾è¡¨ä¸­çš„èŠ‚ç‚¹)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://i.loli.net/2021/09/12/DF3vg8YIjU7eCfG.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
void deleteNode(struct ListNode* node) {
    // æŠŠä¸‹ä¸€ä¸ªç»“ç‚¹å½“åšè¦åˆ é™¤çš„ç»“ç‚¹
    node-&amp;gt;val = node-&amp;gt;next-&amp;gt;val; 
    node-&amp;gt;next = node-&amp;gt;next-&amp;gt;next;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node-&amp;gt;val = node-&amp;gt;next-&amp;gt;val;
        node-&amp;gt;next = node-&amp;gt;next-&amp;gt;next;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">é“¾è¡¨-åˆ·é¢˜é›†</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + 'ç§’ä¹‹å‰';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + 'åˆ†é’Ÿä¹‹å‰';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + 'å°æ—¶ä¹‹å‰';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + 'å¤©ä¹‹å‰';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //æ‹¿æ¥ä¸»ä¹‰(çœŸé¦™)^_^ï¼ŒClipboard å®ç°æ‘˜è‡ªæ˜é‡‘ https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // åˆ¤æ–­æ˜¯ä¸æ˜¯iosç«¯
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //åˆ›å»ºæ–‡æœ¬å…ƒç´ 
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //é€‰æ‹©å†…å®¹
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //å¤åˆ¶åˆ°å‰ªè´´æ¿
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("å¤åˆ¶é”™è¯¯ï¼è¯·æ‰‹åŠ¨å¤åˆ¶ï¼")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === 'å¤åˆ¶æˆåŠŸ') {
        return;
      }
      e.srcElement.textContent = 'å¤åˆ¶æˆåŠŸ';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === 'å¤åˆ¶æˆåŠŸ') {
            elem.textContent = 'å¤åˆ¶ä»£ç '
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = 'å¤åˆ¶ä»£ç ';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>


<script src="/media/js/mouse/love.js"></script>


<script src="/media/js/cool.js"></script>



</html>